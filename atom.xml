<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lightsmile&#39;s Blog</title>
  
  <subtitle>lightsmile</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.iamlightsmile.com/"/>
  <updated>2020-01-18T11:09:40.030Z</updated>
  <id>http://www.iamlightsmile.com/</id>
  
  <author>
    <name>lightsmile</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>light系列库设想架构</title>
    <link href="http://www.iamlightsmile.com/articles/light%E7%B3%BB%E5%88%97%E5%BA%93%E8%AE%BE%E6%83%B3%E6%9E%B6%E6%9E%84/"/>
    <id>http://www.iamlightsmile.com/articles/light系列库设想架构/</id>
    <published>2020-01-08T12:22:20.000Z</published>
    <updated>2020-01-18T11:09:40.030Z</updated>
    
    <content type="html"><![CDATA[<p>自己开发或整合的一系列light库之间的架构组织关系如图所示：</p><p><img src="https://s2.ax1x.com/2020/01/08/l2Tfne.png" alt="l2Tfne.png"></p><a id="more"></a><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>如上图所示，整个light系列库之间的组织架构共分为：</p><ul><li>工具层<ul><li>lightSpider</li><li>lightUtils</li><li>lightDict</li><li>其他light库</li><li>其他工具库</li></ul></li><li>算法层<ul><li>lightNLP</li><li>lightKG</li><li>通用神经网络模型算法</li><li>其他NLP框架</li><li>其他KG框架</li></ul></li><li>业务层<ul><li>lightText</li><li>lightKB</li><li>其他相关业务</li></ul></li><li>界面层<ul><li>浏览器前端</li></ul></li></ul><p>整个架构的中心都是围绕着自然语言处理和知识图谱两个大的方向。目的是搭一个比较通用的架子，然后可以在上面展开一些尝试性、探索性的实验和业务，根本上是作为自己想法的舞台。</p><h2 id="工具层"><a href="#工具层" class="headerlink" title="工具层"></a>工具层</h2><p>工具层包括<a href="https://github.com/smilelight/lightSpider" target="_blank" rel="noopener"><code>lightSpider</code></a>、<a href="https://github.com/smilelight/lightUtils" target="_blank" rel="noopener"><code>lightUtils</code></a>、<a href="https://github.com/smilelight/lightDict" target="_blank" rel="noopener"><code>lightDict</code></a>、其他light库以及其他工具库（如NLTK）。</p><p>其中<a href="https://github.com/smilelight/lightSpider" target="_blank" rel="noopener"><code>lightSpider</code></a>是用来获取网上的知识（以网上各网站的公开语料）。<a href="https://github.com/smilelight/lightUtils" target="_blank" rel="noopener"><code>lightUtils</code></a>则是一些较通用的工具类库，包含了比如说日志打印、获取系统可用tcp端口等功能。<a href="https://github.com/smilelight/lightDict" target="_blank" rel="noopener"><code>lightDict</code></a>则包含了一些在网上搜集到的中文的字典词典资料，并且构建了一个lib以方便使用。其他light库则视以后需求增加。</p><h2 id="算法层"><a href="#算法层" class="headerlink" title="算法层"></a>算法层</h2><p>算法层包括<a href="https://github.com/smilelight/lightNLP" target="_blank" rel="noopener"><code>lightNLP</code></a>、<a href="https://github.com/smilelight/lightKG" target="_blank" rel="noopener"><code>lightKG</code></a>、其他NLP框架（比如说<a href="https://github.com/fastnlp/fastNLP" target="_blank" rel="noopener"><code>fastNLP</code></a>）、其他KG框架（比如说<a href="https://github.com/thunlp/OpenNRE" target="_blank" rel="noopener"><code>OpenNRE</code></a>）以及其他通用神经网络模型算法，包括但不限于强化学习、对抗学习、终生学习等。</p><h2 id="业务层"><a href="#业务层" class="headerlink" title="业务层"></a>业务层</h2><p>业务层构建于算法层之上包括各种知识图谱任务和自然语言处理技术，比如关键词抽取、文本摘要、文本分类、命名实体识别、信息抽取、文本生成、实体链接、本体分类与构建、知识存储等功能，会用到各种算法知识和技术，包括基于深度学习的、基于机器学习的、基于规则的，基于监督学习的、基于弱监督学习的、基于无监督学习的等等。</p><h2 id="界面层（用户层）"><a href="#界面层（用户层）" class="headerlink" title="界面层（用户层）"></a>界面层（用户层）</h2><p>用户层则主要考虑采用Vue+Flask等技术，在可视化方面主要采用2D层面，但在一些本体与事件展示时更倾向于使用3D效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己开发或整合的一系列light库之间的架构组织关系如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/01/08/l2Tfne.png&quot; alt=&quot;l2Tfne.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="light" scheme="http://www.iamlightsmile.com/categories/light/"/>
    
    
      <category term="light系列库" scheme="http://www.iamlightsmile.com/tags/light%E7%B3%BB%E5%88%97%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>centos安装miniconda</title>
    <link href="http://www.iamlightsmile.com/articles/centos%E5%AE%89%E8%A3%85miniconda/"/>
    <id>http://www.iamlightsmile.com/articles/centos安装miniconda/</id>
    <published>2020-01-07T08:06:09.000Z</published>
    <updated>2020-01-18T11:10:36.754Z</updated>
    
    <content type="html"><![CDATA[<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-下载miniconda"><a href="#1-下载miniconda" class="headerlink" title="1. 下载miniconda"></a>1. 下载miniconda</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~ &amp;&amp; mkdir tmp &amp;&amp; <span class="built_in">cd</span> tmp</span><br><span class="line">wget https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><h3 id="2-运行miniconda安装脚本"><a href="#2-运行miniconda安装脚本" class="headerlink" title="2. 运行miniconda安装脚本"></a>2. 运行miniconda安装脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh Miniconda3-latest-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><h3 id="3-验证是否安装成功"><a href="#3-验证是否安装成功" class="headerlink" title="3. 验证是否安装成功"></a>3. 验证是否安装成功</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda -V</span><br></pre></td></tr></table></figure><p>若输出类似<code>conda 4.7.12</code>，说明安装conda环境成功。如提示：<code>zsh：command not find:conda</code>，则需要将<code>conda</code>配置到路径变量中，详情参考<a href="https://www.jianshu.com/p/13f5d20e61f8" target="_blank" rel="noopener">zsh：command not find:conda 的详细解决办法 - 简书</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerlink&quot; title=&quot;步骤&quot;&gt;&lt;/a&gt;步骤&lt;/h2&gt;&lt;h3 id=&quot;1-下载miniconda&quot;&gt;&lt;a href=&quot;#1-下载miniconda&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.iamlightsmile.com/categories/Linux/"/>
    
    
      <category term="CentOS" scheme="http://www.iamlightsmile.com/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>购买国内云服务器与备案注册</title>
    <link href="http://www.iamlightsmile.com/articles/%E8%B4%AD%E4%B9%B0%E5%9B%BD%E5%86%85%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E5%A4%87%E6%A1%88%E6%B3%A8%E5%86%8C/"/>
    <id>http://www.iamlightsmile.com/articles/购买国内云服务器与备案注册/</id>
    <published>2020-01-07T06:50:32.000Z</published>
    <updated>2020-01-18T11:14:19.374Z</updated>
    
    <content type="html"><![CDATA[<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>我真傻，真的。没想到腾讯云有120元/年，同样配置的学生优惠活动：<a href="https://cloud.tencent.com/act/campus" target="_blank" rel="noopener">腾讯云学生服务器_学生机_云服务器优惠套餐-云+校园 - 腾讯云</a>，只是主机只能选上海或者深圳。并且25岁以下免学生认证，立马我就把之前用了500优惠券+600多买的云服务器给退了。。。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>突然大发兴致，想要购买国内云服务器，并且配置域名以及备案注册，想要搞事情，具体搞什么还没想好，比如说爬虫或者部署demo之类的。虽然自己也有搬瓦工的服务器，虽然也算物美价廉，但是毕竟不能备案绑定域名，况且内存和国内访问速度都比较慢，还是搞个真正的云服务器比较好。</p><a id="more"></a><h2 id="调研"><a href="#调研" class="headerlink" title="调研"></a>调研</h2><p>这里主要是比较各厂商（主要是阿里云、腾讯云两家）的云服务器产品的性能和价格。发现网上阿里口碑不错，如果不差钱就选阿里好了，而腾讯云价格相对较低一些，毕竟起步较晚，一些布局和服务等没有阿里云那么完善，只能在价格上搞搞事情了。</p><p>虽然各厂商都对新用户有比较大的力度优惠，然而奈何自己都不是。在阿里云上买过域名和OSS，也在腾讯云上买过域名。</p><p>下面是阿里云的：</p><p><img src="https://s2.ax1x.com/2020/01/07/l6fWvR.jpg" alt="l6fWvR.jpg"></p><p>链接地址为：<a href="https://promotion.aliyun.com/ntms/act/qwbk.html?spm=5176.13727575.J_7116760870.4.57c93b5afY11df&amp;aly_as=dk6i2qQ0" target="_blank" rel="noopener">全民云计算_云服务器促销_便宜云服务器活动_阿里云</a></p><p>优惠链接地址：<a href="https://www.dute.me/aliyun/" target="_blank" rel="noopener">阿里云2020年1月最新优惠信息 - 独特优惠码</a></p><p>下面是腾讯云的：</p><p><img src="https://s2.ax1x.com/2020/01/07/l6hEMn.jpg" alt="l6hEMn.jpg"></p><p>链接地址为：<a href="https://buy.cloud.tencent.com/cvm?tab=lite" target="_blank" rel="noopener">云服务器选购 - 腾讯云</a></p><p>优惠链接地址：<a href="https://cloud.tencent.com/act/vouchers/list?fromSource=gwzcw.2477393.2477393.2477393&amp;utm_medium=cpc&amp;utm_id=gwzcw.2477393.2477393.2477393&amp;from=console&amp;cps_key=2d38bc39c4bd798861417be7ca167f7c" target="_blank" rel="noopener">腾讯云优惠券_代金券_云服务器折扣券-腾讯云</a></p><p>其中里面一些优惠确实算是挺大的：</p><p><img src="https://s2.ax1x.com/2020/01/07/l64vAf.jpg" alt="l64vAf.jpg"></p><p>最终左右权衡之后，觉得确实腾讯云的性价比更高一些，况且适合自己以后部署爬虫等需要长时间消耗CPU等资源的应用。</p><h2 id="购买域名及备案"><a href="#购买域名及备案" class="headerlink" title="购买域名及备案"></a>购买域名及备案</h2><h3 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h3><p>自己其实已经有3个域名了，但是都不太合适作为新服务器的域名，于是自己又买了一个域名：lightsmile.cn。哎，感叹一下lightsmile.com这个域名早就被别人买了，并且价格还挺高，所以自己看来短期内无法把它搞到手。</p><p>域名买了之后需要实名注册，然后设置解析，具体不表。</p><h3 id="备案"><a href="#备案" class="headerlink" title="备案"></a>备案</h3><p>备案的话，现在其实都算挺方便的。无论是阿里云还是腾讯云，直接在电脑上操作或者使用微信小程序操作，然后上传一些资料，比如个人身份证件图片以及一些必要的备案信息等，然后就可以默默等待审核结果了。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>不得不说，买个云服务器确实还挺贵的，自己也没有什么资金收入，还得找家里一直要钱。客观对比一下，我发现自己其实和一些大学生年轻人是一样的，只不过他们喜欢把钱投资到喜欢的衣服和鞋子，而我则喜欢购买互联网产品，充一些有助于自己成长的平台的会员。但归根结底都是图自己爽。</p><p>虽然有了自己的云服务器之后又可以有一番作为，但是确实还是很肉疼啊。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.vpsss.net/16214.html" target="_blank" rel="noopener">1核 2G云服务器选择腾讯云还是阿里云？-魏艾斯博客</a></li><li><a href="https://www.jianshu.com/p/03b099a5d1f0" target="_blank" rel="noopener">阿里云和腾讯云哪个好？云服务器如何选择？ - 简书</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;更新&quot;&gt;&lt;a href=&quot;#更新&quot; class=&quot;headerlink&quot; title=&quot;更新&quot;&gt;&lt;/a&gt;更新&lt;/h2&gt;&lt;p&gt;我真傻，真的。没想到腾讯云有120元/年，同样配置的学生优惠活动：&lt;a href=&quot;https://cloud.tencent.com/act/campus&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;腾讯云学生服务器_学生机_云服务器优惠套餐-云+校园 - 腾讯云&lt;/a&gt;，只是主机只能选上海或者深圳。并且25岁以下免学生认证，立马我就把之前用了500优惠券+600多买的云服务器给退了。。。&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;突然大发兴致，想要购买国内云服务器，并且配置域名以及备案注册，想要搞事情，具体搞什么还没想好，比如说爬虫或者部署demo之类的。虽然自己也有搬瓦工的服务器，虽然也算物美价廉，但是毕竟不能备案绑定域名，况且内存和国内访问速度都比较慢，还是搞个真正的云服务器比较好。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://www.iamlightsmile.com/categories/Linux/"/>
    
    
      <category term="CentOS" scheme="http://www.iamlightsmile.com/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>高速下载国外数据软件</title>
    <link href="http://www.iamlightsmile.com/articles/%E9%AB%98%E9%80%9F%E4%B8%8B%E8%BD%BD%E5%9B%BD%E5%A4%96%E6%95%B0%E6%8D%AE%E8%BD%AF%E4%BB%B6/"/>
    <id>http://www.iamlightsmile.com/articles/高速下载国外数据软件/</id>
    <published>2020-01-04T05:34:01.000Z</published>
    <updated>2020-01-18T11:13:40.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>很多时候要下载国外网站的数据和软件包的时候默认浏览器下载速度极慢，甚至可能到几k/s，要下载个几M的东西都要花好长时间。</p><a id="more"></a><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>突然想到自己有办理搬瓦工的服务器呀~。使用代理服务器下载想要的数据，然后再传到自己的电脑不就好了嘛。</p><h2 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h2><h3 id="1-获取下载链接地址"><a href="#1-获取下载链接地址" class="headerlink" title="1.获取下载链接地址"></a>1.获取下载链接地址</h3><p>如图，使用Chrome浏览器下载，然后右键点击URL选择“复制链接地址”。<br><img src="https://s2.ax1x.com/2020/01/04/lwmEdO.jpg" alt="lwmEdO.jpg"></p><h3 id="2-使用代理服务器下载数据"><a href="#2-使用代理服务器下载数据" class="headerlink" title="2.使用代理服务器下载数据"></a>2.使用代理服务器下载数据</h3><p>如图，使用Xshell等终端软件登录代理服务器，执行<code>wget xxx</code>命令：<br><img src="https://s2.ax1x.com/2020/01/04/lwmKSA.jpg" alt="lwmKSA.jpg"></p><h3 id="3-将数据从代理服务器传至本机"><a href="#3-将数据从代理服务器传至本机" class="headerlink" title="3.将数据从代理服务器传至本机"></a>3.将数据从代理服务器传至本机</h3><p>如图，使用Xftp等文件传输软件连接至代理服务器，将下载文件传输到本地：<br><img src="https://s2.ax1x.com/2020/01/04/lwm3ef.jpg" alt="lwm3ef.jpg"></p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>虽然在将文件从代理服务器传输到本机的过程中可能速度也不快，但是起码可用了，200k也算可以接受了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;很多时候要下载国外网站的数据和软件包的时候默认浏览器下载速度极慢，甚至可能到几k/s，要下载个几M的东西都要花好长时间。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://www.iamlightsmile.com/categories/Linux/"/>
    
    
      <category term="小窍门" scheme="http://www.iamlightsmile.com/tags/%E5%B0%8F%E7%AA%8D%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>程序猿注意颈椎保护</title>
    <link href="http://www.iamlightsmile.com/articles/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E6%B3%A8%E6%84%8F%E9%A2%88%E6%A4%8E%E4%BF%9D%E6%8A%A4/"/>
    <id>http://www.iamlightsmile.com/articles/程序猿注意颈椎保护/</id>
    <published>2020-01-03T12:51:42.000Z</published>
    <updated>2020-01-18T11:13:03.441Z</updated>
    
    <content type="html"><![CDATA[<p>下面是一些视频网址和文字教程，在这里分享一下：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/26272432" target="_blank" rel="noopener">亲身实践，颈椎病自愈法 - 知乎</a></li><li><a href="https://www.bilibili.com/video/av45286925?from=search&amp;seid=10143354984380683087" target="_blank" rel="noopener">老中医治疗你的颈椎病_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></li><li><a href="https://www.bilibili.com/video/av24999820?from=search&amp;seid=10143354984380683087" target="_blank" rel="noopener">10分钟颈椎操颈椎病的自我治疗，每天10分钟，轻松20年！_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下面是一些视频网址和文字教程，在这里分享一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26272432&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;亲身实践，颈椎病自愈法 - 知乎&lt;/a&gt;&lt;
      
    
    </summary>
    
      <category term="程序人生" scheme="http://www.iamlightsmile.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="颈椎病" scheme="http://www.iamlightsmile.com/tags/%E9%A2%88%E6%A4%8E%E7%97%85/"/>
    
  </entry>
  
  <entry>
    <title>简单调研操作Neo4j的Python库</title>
    <link href="http://www.iamlightsmile.com/articles/%E7%AE%80%E5%8D%95%E8%B0%83%E7%A0%94%E6%93%8D%E4%BD%9CNeo4j%E7%9A%84Python%E5%BA%93/"/>
    <id>http://www.iamlightsmile.com/articles/简单调研操作Neo4j的Python库/</id>
    <published>2020-01-03T12:49:41.000Z</published>
    <updated>2020-01-03T12:53:57.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如<a href="https://neo4j.com/developer/python/" target="_blank" rel="noopener">官网</a>所述，目前用于操作Neo4j的Python库主要包括如下几种：</p><ul><li>Neo4j Python Driver（官方提供，长期更新支持）</li><li>Py2neo（非官方看网上教程多数都是这个）</li><li>Neomodel（也是社区版）</li></ul><a id="more"></a><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><div class="table-container"><table><thead><tr><th>对比\模型</th><th>Neo4j Driver</th><th>Py2neo</th><th>Neomodel</th></tr></thead><tbody><tr><td>代码活跃程度</td><td>最近更新于一个月内</td><td>最近更新于8个月前</td><td>不明</td></tr><tr><td>国内适用范围</td><td>较少</td><td>很多</td><td>不明</td></tr><tr><td>代码特性</td><td>一般</td><td>简洁</td><td>一般</td></tr><tr><td>说明文档内容</td><td>较少</td><td>一般</td><td>不明</td></tr><tr><td>配套文档版本</td><td>最新</td><td>最新源码和文档有冲突</td><td>不明</td></tr></tbody></table></div><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>经过对比，还是先结合源码来学习Py2neo吧。大家都用，并且代码用起来确实比较舒服~并且，本质上也只是一个使用Neo4j的接口，无非语句不通而已，但最终执行的增删改查都是一样的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://py2neo.org/v4/index.html" target="_blank" rel="noopener">The Py2neo v4 Handbook — The Py2neo v4 Handbook</a></li><li><a href="https://www.jianshu.com/p/69f6ecafe563" target="_blank" rel="noopener">Neo4j系列-新手入门（二） - 简书</a></li><li><a href="https://cuiqingcai.com/4778.html" target="_blank" rel="noopener">Neo4j简介及Py2Neo的用法 | 静觅</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;如&lt;a href=&quot;https://neo4j.com/developer/python/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt;所述，目前用于操作Neo4j的Python库主要包括如下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Neo4j Python Driver（官方提供，长期更新支持）&lt;/li&gt;
&lt;li&gt;Py2neo（非官方看网上教程多数都是这个）&lt;/li&gt;
&lt;li&gt;Neomodel（也是社区版）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://www.iamlightsmile.com/tags/Python/"/>
    
      <category term="Neo4j" scheme="http://www.iamlightsmile.com/tags/Neo4j/"/>
    
  </entry>
  
  <entry>
    <title>使用ReadtheDocs给项目添加教程文档</title>
    <link href="http://www.iamlightsmile.com/articles/%E4%BD%BF%E7%94%A8ReadtheDocs%E7%BB%99%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E6%95%99%E7%A8%8B%E6%96%87%E6%A1%A3/"/>
    <id>http://www.iamlightsmile.com/articles/使用ReadtheDocs给项目添加教程文档/</id>
    <published>2020-01-03T12:43:18.000Z</published>
    <updated>2020-01-03T12:54:06.042Z</updated>
    
    <content type="html"><![CDATA[<p>当开源项目的内容比较多、比较杂的时候，就需要将一些说明性的东西、如教程、文档等东西从<code>README.md</code>文件中剥离出来搞一个文档，许多项目都是如此，于是自己也简单学了一下使用ReadtheDocs。</p><a id="more"></a><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-从ReadtheDocs官网注册账号并连接到Github"><a href="#1-从ReadtheDocs官网注册账号并连接到Github" class="headerlink" title="1.从ReadtheDocs官网注册账号并连接到Github"></a>1.从ReadtheDocs官网注册账号并连接到Github</h3><p>ReadtheDocs官网地址：<a href="https://readthedocs.org/" target="_blank" rel="noopener">首页 | Read the Docs</a></p><p>在注册成功后在<code>设置-&gt;已连接的服务</code>中点击<code>Connect to Github</code>：<br><img src="https://s2.ax1x.com/2020/01/03/la76ts.jpg" alt="la76ts.jpg"></p><h3 id="2-在Github上创建一个项目，如test-cookbook，并将其克隆到本地。"><a href="#2-在Github上创建一个项目，如test-cookbook，并将其克隆到本地。" class="headerlink" title="2.在Github上创建一个项目，如test-cookbook，并将其克隆到本地。"></a>2.在Github上创建一个项目，如<code>test-cookbook</code>，并将其克隆到本地。</h3><h3 id="3-安装Sphinx"><a href="#3-安装Sphinx" class="headerlink" title="3.安装Sphinx"></a>3.安装Sphinx</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install sphinx</span><br></pre></td></tr></table></figure><h3 id="4-创建工程"><a href="#4-创建工程" class="headerlink" title="4.创建工程"></a>4.创建工程</h3><p>将路径切换到项目根目录下，执行以下命令：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sphinx-quickstart</span></span><br></pre></td></tr></table></figure></p><h3 id="5-对工程进程配置"><a href="#5-对工程进程配置" class="headerlink" title="5.对工程进程配置"></a>5.对工程进程配置</h3><p>项目的配置，主要是更改<code>source/conf.py</code>文件。</p><h4 id="5-1-更改主题"><a href="#5-1-更改主题" class="headerlink" title="5.1 更改主题"></a>5.1 更改主题</h4><p>在项目中更改或添加以下代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sphinx_rtd_theme</span><br><span class="line">html_theme = <span class="string">"sphinx_rtd_theme"</span></span><br><span class="line">html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]</span><br></pre></td></tr></table></figure></p><h4 id="5-2-添加markdown支持"><a href="#5-2-添加markdown支持" class="headerlink" title="5.2 添加markdown支持"></a>5.2 添加markdown支持</h4><p>首先安装<code>recommonmark</code><br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> recommonmark</span><br></pre></td></tr></table></figure></p><p>并在项目中增加以下代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> recommonmark.parser <span class="keyword">import</span> CommonMarkParser</span><br><span class="line">source_parsers = &#123;</span><br><span class="line">    <span class="string">'.md'</span>: CommonMarkParser,</span><br><span class="line">&#125;</span><br><span class="line">source_suffix = [<span class="string">'.rst'</span>, <span class="string">'.md'</span>]</span><br></pre></td></tr></table></figure></p><h3 id="6-导入到ReadtheDocs"><a href="#6-导入到ReadtheDocs" class="headerlink" title="6.导入到ReadtheDocs"></a>6.导入到ReadtheDocs</h3><p>在ReadtheDocs个人面板点击<code>Import a Project</code>：<br><img src="https://s2.ax1x.com/2020/01/03/la7BnS.jpg" alt="la7BnS.jpg"><br>然后选择对应的项目，如果项目列表为空或者未显示当前项目，点击右上角等待刷新项目即可：</p><p><img src="https://s2.ax1x.com/2020/01/03/la7fXT.jpg" alt="la7fXT.jpg"></p><p>之后可以对项目进行一些设置，如图：</p><p><img src="https://s2.ax1x.com/2020/01/03/la7HhR.jpg" alt="la7HhR.jpg"></p><h3 id="7-向工程中添加实际教程和文档"><a href="#7-向工程中添加实际教程和文档" class="headerlink" title="7.向工程中添加实际教程和文档"></a>7.向工程中添加实际教程和文档</h3><p>如新建<code>.rst</code>或<code>.md</code>文件，并修改项目的<code>index.rst</code>等，具体请参考最后的参考链接。</p><h3 id="8-生成文档"><a href="#8-生成文档" class="headerlink" title="8.生成文档"></a>8.生成文档</h3><p>在项目根目录执行<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">make html</span></span><br></pre></td></tr></table></figure></p><p>以生成html格式的文档。</p><p>可能在生成文档会失败，如遇到<code>Sphinx error: master file [..]/checkouts/latest/contents.rst not found</code>这样的错误，可以参考<a href="https://github.com/readthedocs/readthedocs.org/issues/2569" target="_blank" rel="noopener">Sphinx error: master file [..]/checkouts/latest/contents.rst not found · Issue #2569 · readthedocs/readthedocs.org</a>来解决。</p><h3 id="9-预览效果"><a href="#9-预览效果" class="headerlink" title="9.预览效果"></a>9.预览效果</h3><p>进入<code>build/html</code>目录下用浏览器打开其中的<code>index.html</code>来预览项目文档。如：<br><img src="https://s2.ax1x.com/2020/01/03/la7vnO.jpg" alt="la7vnO.jpg"></p><h3 id="10-push到Github仓库"><a href="#10-push到Github仓库" class="headerlink" title="10.push到Github仓库"></a>10.push到Github仓库</h3><p>三连<code>git</code>：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> .</span></span><br><span class="line"><span class="bash">git commit -m <span class="string">"update cookbook"</span></span></span><br><span class="line"><span class="bash">git push</span></span><br></pre></td></tr></table></figure></p><h3 id="11-查看在线效果"><a href="#11-查看在线效果" class="headerlink" title="11.查看在线效果"></a>11.查看在线效果</h3><p>在ReadtheDocs的项目主页点击<code>阅读文档</code>以查看实际效果：<br><img src="https://s2.ax1x.com/2020/01/03/laHF3t.jpg" alt="laHF3t.jpg"></p><p>效果如：<br><img src="https://s2.ax1x.com/2020/01/03/laHpAH.jpg" alt="laHpAH.jpg"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/78e9e1b8553a" target="_blank" rel="noopener">如何用 ReadtheDocs、Sphinx 快速搭建写书环境 - 简书</a></li><li><a href="https://www.xncoding.com/2017/01/22/fullstack/readthedoc.html" target="_blank" rel="noopener">使用ReadtheDocs托管文档 | 飞污熊博客</a></li><li><a href="https://github.com/readthedocs/readthedocs.org/issues/2569" target="_blank" rel="noopener">Sphinx error: master file [..]/checkouts/latest/contents.rst not found · Issue #2569 · readthedocs/readthedocs.org</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当开源项目的内容比较多、比较杂的时候，就需要将一些说明性的东西、如教程、文档等东西从&lt;code&gt;README.md&lt;/code&gt;文件中剥离出来搞一个文档，许多项目都是如此，于是自己也简单学了一下使用ReadtheDocs。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>实用命令行工具-Gow</title>
    <link href="http://www.iamlightsmile.com/articles/%E5%AE%9E%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-Gow/"/>
    <id>http://www.iamlightsmile.com/articles/实用命令行工具-Gow/</id>
    <published>2020-01-03T12:37:36.000Z</published>
    <updated>2020-01-03T12:42:26.995Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Windows和Linux对于程序员来说，就像张爱玲笔下的红玫瑰和白玫瑰。对于有钱的成年人来说，选择自然是“我全都要”，然而对于目前经济窘迫、只有一台爱机的我，鱼和熊掌也许并不是那么容易兼得。</p></blockquote><a id="more"></a><p><img src="https://s2.ax1x.com/2020/01/03/laTxFs.jpg" alt="laTxFs.jpg"></p><h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h1><p>Windows除了开发感觉干啥都很方便，而Linux除了开发感觉啥都不方便。<br>Linux的很大的一个很大的优点就在于有大量丰富的命令行工具，能够在命令行里敲几个字就能解决的事情为什么要费力用鼠标点来点去呢？使用键盘的比例越高，往往说明生产效率越高。<br>所以选择Windows作为平时的生活开发系统而言，如果Windows上也能很方便的使用那些命令行工具就很完美了，比如说<code>head</code>、<code>tail</code>等命令。<br>而<a href="https://github.com/bmatzelle/gow" target="_blank" rel="noopener">Gow(Gnu On Windows)</a>恰恰是满足了这一需求点的近乎完美工具。</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h1><blockquote><p>Gow (Gnu On Windows)是Cygwin的轻量级替代品。它使用了一个方便的Windows安装程序，安装了大约130个非常有用的开源UNIX应用程序，这些程序编译为本机win32二进制文件。它被设计为尽可能小，大约10 MB，而Cygwin根据不同的选项可以运行超过100 MB。</p><h1 id="2-下载"><a href="#2-下载" class="headerlink" title="2.下载"></a>2.下载</h1><p>下载页：<a href="https://github.com/bmatzelle/gow/releases" target="_blank" rel="noopener">Releases · bmatzelle/gow</a><br>如图：<img src="https://s2.ax1x.com/2020/01/03/la79S0.jpg" alt="la79S0.jpg">点击红框中的链接下载然后双击安装即可，非常简单易用~</p><h1 id="3-使用示例"><a href="#3-使用示例" class="headerlink" title="3.使用示例"></a>3.使用示例</h1><p>如图：<img src="https://s2.ax1x.com/2020/01/03/la7ETJ.jpg" alt="la7ETJ.jpg"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Windows和Linux对于程序员来说，就像张爱玲笔下的红玫瑰和白玫瑰。对于有钱的成年人来说，选择自然是“我全都要”，然而对于目前经济窘迫、只有一台爱机的我，鱼和熊掌也许并不是那么容易兼得。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="开发工具" scheme="http://www.iamlightsmile.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Windows" scheme="http://www.iamlightsmile.com/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>常用自然语言处理框架之StanfordNLP使用</title>
    <link href="http://www.iamlightsmile.com/articles/%E5%B8%B8%E7%94%A8%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6%E4%B9%8BStanfordNLP%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.iamlightsmile.com/articles/常用自然语言处理框架之StanfordNLP使用/</id>
    <published>2020-01-03T02:37:57.000Z</published>
    <updated>2020-01-03T02:52:11.399Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> stanfordnlp</span><br><span class="line"><span class="comment"># stanfordnlp.download('zh') 从网络上下载模型文件，超级慢</span></span><br><span class="line"></span><br><span class="line">zh_nlp = stanfordnlp.Pipeline(lang=<span class="string">'zh'</span>, models_dir=<span class="string">r"D:\Data\NLP\model\stanfordnlp"</span>)</span><br><span class="line"></span><br><span class="line">text = <span class="string">"清华大学是一所中国的一流大学。"</span></span><br><span class="line"></span><br><span class="line">zh_doc = zh_nlp(text)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, sent <span class="keyword">in</span> enumerate(zh_doc.sentences):</span><br><span class="line">    print(<span class="string">"[Sentence &#123;&#125;]"</span>.format(i+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> sent.words:</span><br><span class="line">        print(<span class="string">"&#123;:12s&#125;\t&#123;:12s&#125;\t&#123;:6s&#125;\t&#123;:d&#125;\t&#123;:12s&#125;"</span>.format(\</span><br><span class="line">              word.text, word.lemma, word.pos, word.governor, word.dependency_relation))</span><br><span class="line">    print(<span class="string">""</span>)</span><br></pre></td></tr></table></figure><p>首先应该先下载模型，然而如果是直接运行<code>stanfordnlp.download(&#39;zh&#39;)</code>命令，那么下载速度实在是太慢了，后来把它的源码下载下来，找到了对应了文件下载地址，然后使用Chrome下载，发现速度有所提升但是也很慢，最后尝试了一下先使用Xshell登录代理浏览器下载模型，然后使用Xftp将模型传输到本地，结果速度变快了好多，尤其是代理浏览器下载模型的速度超级快，达80M/s，太惊人了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="NLP" scheme="http://www.iamlightsmile.com/categories/NLP/"/>
    
    
      <category term="NLP" scheme="http://www.iamlightsmile.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>常用自然语言处理框架之StanfordCoreNLP使用</title>
    <link href="http://www.iamlightsmile.com/articles/%E5%B8%B8%E7%94%A8%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6%E4%B9%8BStanfordCoreNLP%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.iamlightsmile.com/articles/常用自然语言处理框架之StanfordCoreNLP使用/</id>
    <published>2020-01-03T02:26:54.000Z</published>
    <updated>2020-01-03T02:52:04.942Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> stanfordcorenlp <span class="keyword">import</span> StanfordCoreNLP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载模型</span></span><br><span class="line">nlp = StanfordCoreNLP(<span class="string">r"D:\Data\NLP\model\stanford_corenlp\stanford-corenlp-full-2018-10-05"</span>, lang=<span class="string">'zh'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">text = <span class="string">"清华大学是一所中国的一流大学。"</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'Tokenize:'</span>, nlp.word_tokenize(text))</span><br><span class="line">print(<span class="string">'Part of Speech:'</span>, nlp.pos_tag(text))</span><br><span class="line">print(<span class="string">'Named Entities:'</span>, nlp.ner(text))</span><br><span class="line">print(<span class="string">'Constituency Parsing:'</span>, nlp.parse(text))</span><br><span class="line">print(<span class="string">'Dependency Parsing:'</span>, nlp.dependency_parse(text))</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://blog.csdn.net/qq_35203425/article/details/80451243" target="_blank" rel="noopener">Python中使用Stanford CoreNLP_Mr番茄蛋的博客-CSDN博客</a></li><li><a href="https://www.jianshu.com/p/f825999d78bb" target="_blank" rel="noopener">在Mac OS中安装和使用Stanford NLP - 简书</a></li></ul><h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><p>按照网上教程下载模型并且运行代码后没反应，然后搜索网上相关解决方案，找到了<a href="https://www.cnblogs.com/monty12/p/10544524.html" target="_blank" rel="noopener">关于使用stanfordcorenlp一直运行不报错的解决方法 - monty12 - 博客园</a>，并且设置了logger.DEBUG后发现了类似以下报错信息，然后继续重装Java，经过反复两次发现还是不行。</p><pre><code>nitializing native server...INFO:root:java -Xmx4g -cp &quot;F:\space\wingide\stanfordnlp\*&quot; edu.stanford.nlp.pipeline.StanfordCoreNLPServer -port 9000INFO:root:Server shell PID: 8504INFO:root:Waiting until the server is available.INFO:root:Waiting until the server is available.</code></pre><p>后来从这个网址：<a href="https://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html" target="_blank" rel="noopener">Java SE Runtime Environment 8 - Downloads</a>，下载了如下红框中标出的链接重新安装Java之后，才提示安装了64位，并且程序可以正常运行。</p><p><img src="https://s2.ax1x.com/2020/01/03/lUi4iV.png" alt="lUi4iV.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="NLP" scheme="http://www.iamlightsmile.com/categories/NLP/"/>
    
    
      <category term="NLP" scheme="http://www.iamlightsmile.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>Github上开源Python仓库维护流程</title>
    <link href="http://www.iamlightsmile.com/articles/Github%E4%B8%8A%E5%BC%80%E6%BA%90Python%E4%BB%93%E5%BA%93%E7%BB%B4%E6%8A%A4%E6%B5%81%E7%A8%8B/"/>
    <id>http://www.iamlightsmile.com/articles/Github上开源Python仓库维护流程/</id>
    <published>2019-12-31T03:51:25.000Z</published>
    <updated>2020-01-18T11:10:20.336Z</updated>
    
    <content type="html"><![CDATA[<h2 id="steps"><a href="#steps" class="headerlink" title="steps"></a>steps</h2><h3 id="step1：-明确更新缘由"><a href="#step1：-明确更新缘由" class="headerlink" title="step1： 明确更新缘由"></a>step1： 明确更新缘由</h3><p>比如说有用户提出bug的issue，则可以考虑在空闲时分析问题甚至重现问题以寻找到bug，然后修改代码修复bug。</p><p>又如对项目进行重构或增加新的feature等，也相应的修改代码。</p><a id="more"></a><h3 id="step2：对修改后代码进行测试"><a href="#step2：对修改后代码进行测试" class="headerlink" title="step2：对修改后代码进行测试"></a>step2：对修改后代码进行测试</h3><p>对修改后的项目代码进行测试，以确保问题修复，或代码的修改完善并未影响其他的代码的正常运行。</p><h3 id="step3-根据需要修改项目配置和说明文件"><a href="#step3-根据需要修改项目配置和说明文件" class="headerlink" title="step3: 根据需要修改项目配置和说明文件"></a>step3: 根据需要修改项目配置和说明文件</h3><ol><li>在<code>README.md</code>中做说明。</li><li>修改<code>setup.py</code>文件中版本号</li></ol><h3 id="step4-提交代码到Github仓库"><a href="#step4-提交代码到Github仓库" class="headerlink" title="step4: 提交代码到Github仓库"></a>step4: 提交代码到Github仓库</h3><p>git的<code>add</code>、<code>commit</code>、<code>push</code>三连。</p><h3 id="step5-编译项目并更新到pypi源中"><a href="#step5-编译项目并更新到pypi源中" class="headerlink" title="step5: 编译项目并更新到pypi源中"></a>step5: 编译项目并更新到pypi源中</h3><p>参考我的另一篇文章：<a href="http://www.iamlightsmile.com/articles/python%E5%BA%93%E6%89%93%E5%8C%85%E5%88%86%E5%8F%91/">python库打包分发 | lightsmile’s Blog</a></p><h3 id="step6-友好回复提出问题的用户"><a href="#step6-友好回复提出问题的用户" class="headerlink" title="step6: 友好回复提出问题的用户"></a>step6: 友好回复提出问题的用户</h3><p>遵守“<strong>富强、民主、文明、和谐、自由、平等、公正、法治、爱国、敬业、诚信、友善</strong>”社会主义核心价值观，和用户进行友好沟通，告知用户已解决问题或其他说明。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;steps&quot;&gt;&lt;a href=&quot;#steps&quot; class=&quot;headerlink&quot; title=&quot;steps&quot;&gt;&lt;/a&gt;steps&lt;/h2&gt;&lt;h3 id=&quot;step1：-明确更新缘由&quot;&gt;&lt;a href=&quot;#step1：-明确更新缘由&quot; class=&quot;headerlink&quot; title=&quot;step1： 明确更新缘由&quot;&gt;&lt;/a&gt;step1： 明确更新缘由&lt;/h3&gt;&lt;p&gt;比如说有用户提出bug的issue，则可以考虑在空闲时分析问题甚至重现问题以寻找到bug，然后修改代码修复bug。&lt;/p&gt;
&lt;p&gt;又如对项目进行重构或增加新的feature等，也相应的修改代码。&lt;/p&gt;
    
    </summary>
    
      <category term="Github" scheme="http://www.iamlightsmile.com/categories/Github/"/>
    
    
      <category term="Github" scheme="http://www.iamlightsmile.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>2019回忆总结录</title>
    <link href="http://www.iamlightsmile.com/articles/2019%E5%9B%9E%E5%BF%86%E6%80%BB%E7%BB%93%E5%BD%95/"/>
    <id>http://www.iamlightsmile.com/articles/2019回忆总结录/</id>
    <published>2019-12-30T12:00:48.000Z</published>
    <updated>2020-01-18T11:06:08.993Z</updated>
    
    <content type="html"><![CDATA[<p>时光匆匆如流水，眨眼间，2019年就这么过去了。距离<a href="http://www.iamlightsmile.com/articles/%E4%BD%A0%E5%A5%BD%EF%BC%8C2019/">你好，2019</a>也马上就一年整了。</p><a id="more"></a><p>总体回顾这一年，也算奋斗和荒废都有。由于要考研以及积累学习，所以在2018年12月底辞职，然后回家。</p><p>在1月份，主要是学习Pytorch和torchtext，开始探索看项目源码。同时计划当一个网上的家教老师，平台是掌门，准备了一段时间，结果面试没有通过，妈了个巴子的。</p><p>在2月份开始鼓捣Manjaro，期间重装系统多次，真是痛并快乐着，现在回想起来：一方面在探索的过程中遇到困难，解决困难的历程很爽；另一方面说实在的，并没有积累到太多实用的计算机技术，有点浪费时间了（ps：Linux系统还是单独装吧，装个双系统放在普通硬盘里实在是挺慢的，可能和KDE环境占用内存较大也有关系；最近出于学习效率还是回到了Windows的怀抱，啊好香啊）。其间报了个上海的创意编程（就是教Scratch）老师，也经历了准备面试、远程面试通过等过程，然而在培训过程中感觉不太好于是主动退出了）</p><p>到了3月份，之前在网易云课堂报的自然语言处理工程师微专业开班了，于是主要是学习课程资源，积累相关知识；同时开始在Github上寻觅使用Pytorch实现的nlp任务的实现（最开始是文本分类，之后是命名实体识别），开始了不断学习源码之路；其间萌生了用torchtext照着实现一遍以增进自己对任务的理解、以及提升自己的实践动手能力的想法，便有了最初的lightNLP。同时也想着开发其他框架供自己使用，如lightKG、lightText、lightUtils。当时的定位主要是：</p><ul><li>lightNLP：lightNLP基于Pytorch和torchtext是一个深度学习自然语言处理框架，实现了如文本分类、命名实体识别、语句相似度、文本蕴涵、依存句法分析等功能。</li><li>lightKG：lightsmile个人的知识图谱框架</li><li>lightUtils：lightsmile个人的工具类库</li><li>lightText：lightText是中文文本处理框架，在设计上会包含各种词典资源，一些算法的传统或机器学习实现，包含广泛且更高级的功能，如对文本进行分析，抽取出关键词、分类、进行信息抽取等功能，会依赖于lightNLP的深度学习自然语言处理框架、lightKG的知识图谱框架、lightUitls的其他工具类库，以及包含一些词典资源等等各种资源。</li></ul><p>到了4月份，还是继续学习网易云课堂的自然语言处理课程，当然重心已经发生了转移，因为感觉自己在Github上寻找各nlp基础任务的简单实现并阅读源码的过程中学到挺多的，更甚于网易云课堂每周一更的录制课程，所以主要还是看代码，重新实现，以及学习微专业课程。</p><p>到了5月份，家里有人生病住院，我相对空闲所以去陪护，用去了一段时间。其他主要是继续上课，和看代码和敲代码，以及一些其他娱乐活动？忘了。</p><p>剩下的6~12月份，主要是复习备考，期间有认真复习的日子，也有荒废游戏的日子，甚至于连续几天熬夜打游戏，也有熬夜看小说，并没有多刻苦，也并没有很好地执行计划并坚决执行，甚至到了后期每天的真正学习时间反而更短了。</p><p>等考完后，发现心情一般，可能是发挥的一般，尤其是数学，考的极差，做了几套往年的真题，感觉还蛮简单的，于是就放松懈怠了，导致有的大题没写，有的只写了第一问，填空和选择也有不会的；也可能是因为自己平时就没有多努力，多刻苦，所以并没有放松解脱自由的感觉。</p><p>感谢学妹临考前每天的鼓励，真的挺感动的。</p><p>等考完后，本来想说玩游戏放松，可是不知道玩什么；本来想说看小说，可是备考期间也看了；那些本应该在考完后放松的事情让我在备考期间做了个遍，真想狠狠地扇自己！</p><p>同时自己也有太多想做的事，比如学习Vue、学习爬虫、继续完善lightNLP、继续丰富lightKG、学习fastNLP源码、学习Neo4j、阅读知识图谱技术相关论文、阅读自然语言处理相关论文等等，奈何精力有限，只能一步步慢慢来。</p><p>不得不说，这一路走来，有奋斗、也有颓废。关于内心的变化，感觉自己变得比以前更现实了，甚至是相当现实了，比去年还是满脑子空想的我相比现实的太多了。心态也更加平和、冷静，抗干扰能力有所提升，内心不会因为外界的言语有多少波动。不会再把精力浪费在认为不值得的人、不值得的事上面。把名看得更淡，把利看得更多。世界观也更加健全完善，看到世界上发生的许多事情新闻都已经很平静了。尽管几乎去年一整年没有和社会打交道，同样积累了些许人生道理。</p><p>不管满意与否，今年的历程对今后的道路会有什么影响，路都已经走过了，也不能再回头了。</p><p>无论等一个多月之后公布的考研初试成绩如何，无论在今后找工作的道路上遇到多少艰难险阻，我都会继续追求我的自然语言处理和知识图谱的理想永不放弃。</p><p>脑子里又回想起当时那个面临继续工作还是辞职考研两个选择的自己，我可以回答他：这条路走的不后悔。毕竟在月亮和六便士面前，我曾经选择了月亮。</p><p>2020，继续冲鸭！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时光匆匆如流水，眨眼间，2019年就这么过去了。距离&lt;a href=&quot;http://www.iamlightsmile.com/articles/%E4%BD%A0%E5%A5%BD%EF%BC%8C2019/&quot;&gt;你好，2019&lt;/a&gt;也马上就一年整了。&lt;/p&gt;
    
    </summary>
    
      <category term="随念" scheme="http://www.iamlightsmile.com/categories/%E9%9A%8F%E5%BF%B5/"/>
    
    
      <category term="个人" scheme="http://www.iamlightsmile.com/tags/%E4%B8%AA%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>如何理解WordEmbedding？</title>
    <link href="http://www.iamlightsmile.com/articles/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3WordEmbedding%EF%BC%9F/"/>
    <id>http://www.iamlightsmile.com/articles/如何理解WordEmbedding？/</id>
    <published>2019-04-22T08:15:12.000Z</published>
    <updated>2019-04-22T08:33:36.562Z</updated>
    
    <content type="html"><![CDATA[<p>之前自己也是懵懵懂懂的不太理解，经过一段时间的学习和思考，感觉自己有了新的认识，所以在这里分享一下，也算自己的总结了。</p><p>不谈数学原理，我认为理解Word Embedding可以从以下3个角度来理解。</p><a id="more"></a><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h2><p>《深度学习》一书中有以下几句话，略有小改：</p><blockquote><ul><li>简单的机器学习算法的性能在很大程度上依赖于给定数据的表示。</li><li>使用机器学习来发掘表示本身的方法即表示学习。</li><li>从原始数据中提取高层次、抽象的特征是非常困难的。</li><li>深度学习通过其他较简单的表示来表达复杂表示。</li><li>我们可以认为不同数学函数的每一次应用都为输入提供了新的表示。</li><li>分布式表示的思想是系统的每一个输入都应该由多个特征表示，并且每一个特征都应该参与到多个可能输入的表示。</li><li>联结主义的中心思想是当网络把大量简单的计算单元连接在一起时可以实现智能行为。</li><li>万能近似定理表明，神经网络可以近似从任何有限离散空间映射到另一个的任意函数。</li></ul></blockquote><p>其实我认为深度学习的应用核心就是上面几句话。</p><p>接下来我拿传统的确定性算法、机器学习和深度学习做一个简单的对比。</p><p>原来对于一些流程比较清晰简单的任务，我们的做法是编写确定性的算法来实现，而对于那些很复杂的，难以用简单的规则去说明的任务通常束手无策。</p><p>机器学习的作用则是直接从数据中去学习，总结规律，但通常我们要花费大量的精力在特征工程上面，同时对于许多任务来说，我们很难知道应该提取哪些特征。<br>而深度学习则表示：特征不用你们整，只要你们给的数据足够好，我保证给你们一个更好的模型。</p><p>上面这句话的意思是，原来特征工程的累活我们不用做了，深度学习可以自己学到好的特征，同时万能近似定理也确保了深度神经网络可以保证模型学习效果的上限很高，当前前提是我们给的数据比较好。</p><p>以上交代了下背景，接下来言归正传。</p><p>自然语言要作为神经网络模型的输入之前，我们首先需要将其映射为计算机可以表示的形式。</p><p>独热编码最简单，将每一个字或者词都唯一编码成了01向量，除了维度灾难，我认为最大的缺点就是在这一映射过程中丢掉了许多词或者字的词义和语义特征，除了表示唯一以外，不包含任意其它信息。</p><p>这时我们应该思考：那什么样的表示才算好的表示？表示中应该保留哪些特征又如何保留这些特征呢？</p><p>怀着对上面问题的疑问，我们来看一下他山之石。</p><h2 id="2-卷积神经网络的工作原理"><a href="#2-卷积神经网络的工作原理" class="headerlink" title="2.卷积神经网络的工作原理"></a>2.卷积神经网络的工作原理</h2><p>我们都知道卷积神经网络中最主要的部分：卷积层、池化层、激活层的作用就是提取和匹配局部特征，将特征提取结果作为全连接层的输入从而得到最终的输出。</p><p>其中的每一个卷积核都可以被视为一个特征过滤器，卷积神经网络通过依次的扫描输入并进行卷积运算提取得到哪些位置可能包含哪些特征的信息，随后这些特征位置信息被进一步的提取从而得到更高级、更抽象的特征。</p><p>举个例子，如在识别图片中是否包含人时，卷积神经网络大致的作用原理如首先提取出某些位置是否是横线、竖线还是斜线以及颜色等特征，然后对这些特征进一步组合以得到哪些位置是否包含人脸、上肢、下肢等特征，通过提取到的这些特征，神经网络就可以做出决策得到图片中是否包含人的结果。</p><p>通过了解卷积神经网络的工作原理，我们可以知道卷积神经网络的最大作用就是可以自动学习并提取局部特征。对于计算机视觉中的图片而言，最微小的组成单元是一个个的像素点，然后局部组合就得到了线条和颜色块等信息特征；而对于自然语言处理而言，最小的组成单元则是一个个的字符，如英文中的‘a’、汉字中的‘我’等。</p><p>许多计算机视觉的预训练模型都是通用的，对于具体任务，我们只需要finetune（精调）或者只学习后面的层就可以了。这其中的原理是学到的模型提取特征的能力是可复用的，不依赖于某一具体任务。同样的，如果我们可以从语料中学到词或者字的词义和语义特征就好了，之后可以直接作为词或者字的表示用于模型训练和预测，这就是词的预训练。两者有异曲同工之妙。</p><h2 id="3-Harris提出的分布式假说及Firth对此的阐述和论证"><a href="#3-Harris提出的分布式假说及Firth对此的阐述和论证" class="headerlink" title="3.Harris提出的分布式假说及Firth对此的阐述和论证"></a>3.Harris提出的分布式假说及Firth对此的阐述和论证</h2><p>Harris曾于1954年提出分布式假说：“上下文相似的词，其语义也相似”，后来又经过Firth对该假说进行阐述和论证，“词的语义由其上下文确定”。基于该思想，我们可以从该词在语料中的上下文学习得到该词的语义，同时也可以得到相同上下文下不同的词之间的联系。</p><p>结合上文提到的分布式表示的思想，我们可以想到：我们可以用某个词以及该词所指代的实体所具备的属性和特征来表示该词。</p><p>再举个不恰当例子：</p><p>如何表示“程序猿”和“单身狗”这两个词呢？假设我们有以下特征向量序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"><span class="string">"有头发"</span>,</span><br><span class="line"><span class="string">"人傻"</span>,</span><br><span class="line"><span class="string">"钱多"</span>,</span><br><span class="line"><span class="string">"死得快"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>我们可以设定:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">程序猿 = [<span class="number">0.3</span>, <span class="number">0.6</span>, <span class="number">0.6</span>, <span class="number">0.6</span>]</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">同样的，我们可以设定：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">单身狗 = [<span class="number">0.6</span>, <span class="number">0.7</span>, <span class="number">0.3</span>, <span class="number">0.5</span>]</span><br></pre></td></tr></table></figure><p>基于此，我们便得到了“程序猿”和“单身狗”的语义相似度为：</p><script type="math/tex; mode=display">\sqrt{( 1 - \left| 0.3 - 0.6 \right|)^2 +( 1 - \left| 0.6 - 0.7 \right|)^2 + ( 1 - \left| 0.6 - 0.3 \right|)^2 + ( 1 - \left| 0.6 - 0.5 \right|)^2} = 0.72</script><p>从中我们可以得到“程序猿”和“单身狗”这两个词还是挺接近的。</p><p>注意：以上具体数值和计算公式是自己瞎掰的。</p><p>具体到属性特征有哪些以及具体每个词的分量数值应该是多少，这个神经网络是可以自己去学的，只不过学到的可以被视为潜在语义信息，并不是直观的”有头发”, “人傻”, “钱多”, “死得快”等特征，通常都是不可解释的。</p><p>总之，通过类似以上的方式，单词的语义信息就被比较有效的编码和表示起来了。<br>这时我们再回顾一下之前的Word2Vec和最近非常火的BERT，则可以被视为以上思想的工程实践。只不过训练方式和优化目标愈加完善，使得词表示可以包含更多更好的语义表示罢了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>机器学习也好，深度学习也罢，其任务目标都是想要学习现实世界中某些量与某些量之间的映射变化关系。只不过有的关系是线性的，比较简单，而有的则极其复杂。对于这些复杂的问题，才是深度学习的用武之地。</p><p>许多任务都可以被看作是回归或分类问题，正如老子云：“天下皆知美之为美，斯恶已。”，美丑两端即定义一个维度。</p><p>对于神经网络的理解，也可以从还原论的哲学思想来入手。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://pytorch.org/tutorials/beginner/nlp/word_embeddings_tutorial.html#sphx-glr-beginner-nlp-word-embeddings-tutorial-py" target="_blank" rel="noopener">Word Embeddings: Encoding Lexical Semantics</a></li><li><a href="https://www.jianshu.com/p/fe428f0b32c1" target="_blank" rel="noopener">[透析]卷积神经网络CNN究竟是怎样一步一步工作的？</a></li><li><a href="https://www.jianshu.com/p/471d9bfbd72f" target="_blank" rel="noopener">通俗理解word2vec</a></li><li><a href="https://www.jianshu.com/p/7bdbc1395406" target="_blank" rel="noopener">自然语言处理—-文本表示</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前自己也是懵懵懂懂的不太理解，经过一段时间的学习和思考，感觉自己有了新的认识，所以在这里分享一下，也算自己的总结了。&lt;/p&gt;
&lt;p&gt;不谈数学原理，我认为理解Word Embedding可以从以下3个角度来理解。&lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://www.iamlightsmile.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="NLP" scheme="http://www.iamlightsmile.com/tags/NLP/"/>
    
      <category term="深度学习" scheme="http://www.iamlightsmile.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>大学数学与深度学习</title>
    <link href="http://www.iamlightsmile.com/articles/%E5%A4%A7%E5%AD%A6%E6%95%B0%E5%AD%A6%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.iamlightsmile.com/articles/大学数学与深度学习/</id>
    <published>2019-04-22T07:45:42.000Z</published>
    <updated>2019-04-22T08:31:34.082Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道，世间的万事万物都是彼此联系和不断发展的。而我们要生存发展进步，则要不断地去尝试探索理解彼此之间到底是如何联系和发展的，要得到那些定性和定量的规律，哲学和数学以及其他学问在此基础上产生不断进化繁衍。</p><p>而事物与事物之间的关联法则与映射关系即对应于数学中函数这一概念，函数即是定义和研究自变量和因变量之间的映射关系的。</p><a id="more"></a><p>事物之间的联系有简单线性的，也有复杂非线性的，对于简单线性的，古人们通过初等数学等知识即可求解，而复杂非线性的则常常无能为力。</p><p>而微积分，作为复杂函数计算的有力工具，使得我们可以解决原本无法使用初等数学知识无法解决的问题，进而极大地推动了科学的发展和技术的进步。</p><p>然而尽管如此，许多现实中的复杂问题即使是微积分也无能为力，因为我们甚至无法得到其可以用数学公式表达的形式，同时数学作为研究数与形的学问也并非能解决所有问题。</p><p>虽然不能直捣黄龙，理解许多世界中的本质规律，但是我们可以通过抽象近似和归纳统计等方式另觅它径，以达曲径通幽之妙。</p><ul><li>如通过“以直代曲”的核心思想，我们可以把许多非线性问题近似看作线性问题，从而使用线性代数来研究其规律。</li><li>同时我们也可以使用统计学和概率学知识不去细微探索直接探究其本质关联规律，而是在基于统计的基础上跳出局部站在比较宏观的角度建立起现象与现象之间的数学关系，从而得到表层的统计规律。</li><li>再如最近很火的神经网络、深度学习等，其本质则是用含有大量参数的神经网络模型不断地优化更新参数，来去尽可能地拟合变量之间的对应关系。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们都知道，世间的万事万物都是彼此联系和不断发展的。而我们要生存发展进步，则要不断地去尝试探索理解彼此之间到底是如何联系和发展的，要得到那些定性和定量的规律，哲学和数学以及其他学问在此基础上产生不断进化繁衍。&lt;/p&gt;
&lt;p&gt;而事物与事物之间的关联法则与映射关系即对应于数学中函数这一概念，函数即是定义和研究自变量和因变量之间的映射关系的。&lt;/p&gt;
    
    </summary>
    
      <category term="数学" scheme="http://www.iamlightsmile.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="数学" scheme="http://www.iamlightsmile.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>数理统计学</title>
    <link href="http://www.iamlightsmile.com/articles/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%AD%A6/"/>
    <id>http://www.iamlightsmile.com/articles/数理统计学/</id>
    <published>2019-04-22T07:28:33.000Z</published>
    <updated>2019-04-22T07:29:44.814Z</updated>
    
    <content type="html"><![CDATA[<ol><li>数理统计学只是从数量表现的层面上来分析问题，完全不触及问题的专业内涵。</li><li>数理统计方法是一个中立性的工具，这“中立”的含义是，它既不在任何问题上有何主张，也不维护任何利益或在任何学科中坚持任何学理。</li><li>由于数理统计方法只是从表面上的数量关系来分析问题，其结论不可混同于因果关系。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;数理统计学只是从数量表现的层面上来分析问题，完全不触及问题的专业内涵。&lt;/li&gt;
&lt;li&gt;数理统计方法是一个中立性的工具，这“中立”的含义是，它既不在任何问题上有何主张，也不维护任何利益或在任何学科中坚持任何学理。&lt;/li&gt;
&lt;li&gt;由于数理统计方法只是从表面上
      
    
    </summary>
    
      <category term="数学" scheme="http://www.iamlightsmile.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="数学" scheme="http://www.iamlightsmile.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>向量与矩阵</title>
    <link href="http://www.iamlightsmile.com/articles/%E5%90%91%E9%87%8F%E4%B8%8E%E7%9F%A9%E9%98%B5/"/>
    <id>http://www.iamlightsmile.com/articles/向量与矩阵/</id>
    <published>2019-04-22T07:10:37.000Z</published>
    <updated>2019-04-22T08:32:17.552Z</updated>
    
    <content type="html"><![CDATA[<ol><li>线性代数的基本研究单位是向量。</li><li>向量可以视为存储信息和结构的基本量。</li><li>矩阵既可以视为一组向量的集合，也可以视为一组向量的映射关系。</li></ol><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;线性代数的基本研究单位是向量。&lt;/li&gt;
&lt;li&gt;向量可以视为存储信息和结构的基本量。&lt;/li&gt;
&lt;li&gt;矩阵既可以视为一组向量的集合，也可以视为一组向量的映射关系。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="数学" scheme="http://www.iamlightsmile.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="数学" scheme="http://www.iamlightsmile.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>大学数学基础体系脉络</title>
    <link href="http://www.iamlightsmile.com/articles/%E5%A4%A7%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%BD%93%E7%B3%BB%E8%84%89%E7%BB%9C/"/>
    <id>http://www.iamlightsmile.com/articles/大学数学基础体系脉络/</id>
    <published>2019-04-22T06:50:35.000Z</published>
    <updated>2019-04-22T08:32:26.067Z</updated>
    
    <content type="html"><![CDATA[<p>一般来说，问题总是可以分成两类：连续问题和离散问题。相应的，大学数学中高等数学（也就是说微积分）是用来解决连续问题的，关心的函数的变量可以都非常小；而线性代数则是用来解决离散问题的，关心的是维度。</p><a id="more"></a><p>以下是来自万门大学童哲校长在<a href="https://www.wanmen.org/courses/586d23485f07127674135dcb/lectures/586d23535f0712767415a8e0" target="_blank" rel="noopener">线性代数两日特训班</a>中所画的简单说明图：</p><p><img src="https://raw.githubusercontent.com/smilelight/PicImage/master/img/大学数学基础体系脉络.png" alt="大学数学基础体系脉络"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般来说，问题总是可以分成两类：连续问题和离散问题。相应的，大学数学中高等数学（也就是说微积分）是用来解决连续问题的，关心的函数的变量可以都非常小；而线性代数则是用来解决离散问题的，关心的是维度。&lt;/p&gt;
    
    </summary>
    
      <category term="数学" scheme="http://www.iamlightsmile.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="数学" scheme="http://www.iamlightsmile.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>整体论与还原论</title>
    <link href="http://www.iamlightsmile.com/articles/%E6%95%B4%E4%BD%93%E8%AE%BA%E4%B8%8E%E8%BF%98%E5%8E%9F%E8%AE%BA/"/>
    <id>http://www.iamlightsmile.com/articles/整体论与还原论/</id>
    <published>2019-04-22T06:26:43.000Z</published>
    <updated>2019-04-22T06:41:30.764Z</updated>
    
    <content type="html"><![CDATA[<h2 id="还原论"><a href="#还原论" class="headerlink" title="还原论"></a>还原论</h2><p>所谓还原，是一种把复杂的系统（或者现象、过程）层层分解为其组成部分的过程。<strong>还原论</strong>认为，复杂系统可以通过它各个组成部分的行为及其相互作用来加以解释。还原论方法是迄今为止自然科学研究的最基本的方法，人们习惯于以“静止的、孤立的”观点考察组成系统诸要素的行为和性质，然后将这些性质“组装”起来形成对整个系统的描述。例如，为了考察生命，我们首先考察神经系统、消化系统、免疫系统等各个部分的功能和作用，在考察这些系统的时候我们又要了解组成它们的各个器官，要了解器官又必须考察组织，直到最后是对细胞、蛋白质、遗传物质、分子、原子等的考察。现代科学的高度发达表明，还原论是比较合理的研究方法，寻找并研究物质的最基本构件的做法当然是有价值的。</p><a id="more"></a><h2 id="整体论"><a href="#整体论" class="headerlink" title="整体论"></a>整体论</h2><p>与还原论相反的是<strong>整体论</strong>，这种哲学认为，将系统打碎成为它的组成部分的做法是受限制的，对于高度复杂的系统，这种做法就行不通，因此我们应该以整体的系统论观点来考察事物。比如考察一台复杂的机器，还原论者可能会立即拿起螺丝刀和扳手将机器拆散成几千、几万个零部件，并分别进行考察，这显然耗时费力，效果还不一定很理想。整体论者不这么干，他们采取比较简单一些的办法，不拆散机器，而是试图启动运行这台机器，输入一些指令性的操作，观察机器的反应，从而建立起输入──输出之间的联系，这样就能了解整台机器的功能。整体论基本上是功能主义者，他们试图了解的主要是系统的整体功能，但对系统如何实现这些功能并不过分操心。这样做可以将问题简化，但当然也有可能会丢失一些比较重要的信息。</p><h2 id="还原论与整体论的关系"><a href="#还原论与整体论的关系" class="headerlink" title="还原论与整体论的关系"></a>还原论与整体论的关系</h2><p>还原论与整体论之争由来已久，并且激发了脑研究和人工智能领域内的大争论。还原论方法将大脑还原为神经元，然后设法将神经元组装成大脑。人工智能的一个学派认为，通过创造元数字电路，我们能够建造越来越复杂的电路，直到我们创造人工智能。这个学派沿着现代电子计算机这条思路，对“智能”的模仿取得了初步的成功，但深入下去就比较令人失望，因为它甚至连模仿大脑的最简单功能，比如模糊记忆，都无法做到。面对人工智能研究的窘境，一些科学家从研究方法上进行反思，认为还原论方法在人工智能的研究方面没有前途，应设法采取一种更加整体的方法对待大脑，不必纠缠于人脑运作中的一些细小环节，应该建立起把大脑视为整体的模型，将大脑的一些基本功能从一开始就建造在这个模型系统里。神经网络理论基本上就是基于这样一种方法而建立起来的理论模型，这是一种功能主义的整体研究方式。这种方式现在看来也是困难重重，不过它才刚刚起步，其未来的前途如何尚未可知。</p><p>我的观点是，还原论与整体论作为两种不同的研究方法，它们本身无所谓优劣之分，我们具体选择哪种方法，这完全视乎具体情形，并取决于我们个人的喜好。在某种情形下我们采取还原的方法，在另外的情形下我们可能会采取整体论的方法，这都是可以的。但是，在大多数情况下，人们倾向于采用还原论方法，这比较可靠，也比较能够满足我们寻根究底的好奇心，所以只要有可能，人们总是乐于使用它。</p><p>事实上整体论总是只能进行一些初步的研究，一旦深入下去就必须使用还原论的方法。因此，对待自然界，我们总是首先了解其大致的、整体的规律，这是整体论的方法，接着一定要再对它层层进行还原分解，以此考察和研究它的深层次本质规律。例如为了研究人体的生物性状，我们首先了解各个系统，如消化系统、神经系统、免疫系统等的功能，这时候我们是将各个系统当作一个整体来予以研究的；而接着，我们要继续研究组成系统的各器官的功能，再接着是组织、细胞、分子、原子等层面，这便是一个逐层还原的过程。随着层层还原过程的深入，我们对人体的机制就能够得到越来越多的了解。</p><p>是的，对那些过于复杂的系统，比如人的大脑，还原论方法到达一定地步之后就会显得异常繁难，人类的心智看来根本就无法做到将其彻底还原，这时候我们不得不退而求其次，对系统的某些细节忽略不计，从而引进一种比较整体的功能主义研究方式。类似地，对于像“视窗”这样复杂的软件系统，整个系统的逻辑是非常复杂的，如果有人想要模拟而不是剽窃这个系统，最好的办法是：在了解它的功能后再另行编制一个具有几乎相同功能的系统。如果妄想将一台装有“视窗”系统的电脑拆散，从物理的角度了解整个系统的逻辑结构，然后再一一复制出来，这肯定极其艰难甚至劳而无功。所以，对人的大脑采取功能主义的整体论方式进行模拟将比还原论方法也许更为行之有效。</p><p>但是，即使对复杂系统的研究，人类的心智有时候会变得一筹莫展，这也并不意味着还原论就没有价值。因为我们需要知道：系统的表现为什么会是这样？如果我们将一部哪怕最简单的计算器拿到古代，古代的科学家也可能被迫采取整体论的方式对它进行研究，他们或许能了解其主要功能，知道它可以用于数字计算，但他们必然不清楚：它为什么会是这样的呢？这时候，他们将会多么的遗憾。对人体的研究，虽然我们很难用原子和分子的行为来计算和推导出人的行为，但我们至少希望通过原子和分子的行为来解释和理解人的行为。很显然，我们需要能够直接描述复杂系统的整体定律，所以我们有化学定律、有混沌定律、有经济学定律和社会学定律，但这些定律不会是最基本的定律，我们会问为什么？为什么这些定律是这个样子？这时候，这些定律需要用个体行为来进行解释，需要用 “部分”的行为来进行解释。</p><p>还原论的方法肯定是最基本的科学方法。但由于混沌学说的巨大成功，一些人对整体论产生了过分的自信，在今天的很大部分科学哲学家眼里，还原论变成了坏东西，他们为整体论欢呼雀跃，却想法设法要与还原论划清界限。他们走得太远了，他们将整体论的作用过于夸大了，我们有些哲学家甚至还将整体论当作哲学本体论概念来进行介绍，煞有介事地探讨起“世界是简单还是复杂的”这样一些哲学命题来。他们的道理是，整体不等于部分之和，因此自然界是不可彻底还原的，因此整体论才是最优等的哲学。</p><p>有这样一个关于还原论的笑话：老师带学生走进实验室，指着一排玻璃仪器，说那是一个人，因为玻璃瓶里装着人的所有组成物质，包括水、碳、脂肪、蛋白质……。这个笑话的实质是说，还原论者只会将“部分”简单地累加起来形成整体，却愚蠢地并不考虑“部分”之间的相互作用。</p><p>我以为，认为还原论忽视了部分之间的相互作用，这样的指责毫无根据。还原论并不忽视“部分”之间的相互作用，相反，还原的目的正是为了更好地考察这种相互作用。通过还原，“部分”之间的相互作用变成了每个“部分”的边界条件，变成了每个“部分”的输入和输出，这使得我们能更精确地考察这种作用，并建立起将这些相互作用联系起来的方程。整体确实不等于部分之和，但整体必定等于部分及其相互作用之和。</p><p>有些人认为整体论的定律才是最基本的定律，而个体的行为要通过整体的行为来解释，甚至对人类社会也必须采取整体论的方法，认为如果只考察个体，则可能忽略掉人类社会这个群体的一些性质。这种说法是相当奇怪的，人类社会的所有性质归根结底都可以从个体性质及其相互作用而得到解释，虽然我们为了方便起见，可能采取整体论的研究方式，但肯定只有这种整体论的方式才有可能丢失一些重要的信息，而还原论的方式不会。</p><p>我们经常听到这样的训诫：使用还原论要谨慎从事。使用整体论更需谨慎从事。如果只是弄出一个整体论的定律，而个体层次发生的事情都以这个整体的行为来进行解释，这样的理论体系是难以令人信服的。</p><p>不过，还原论方法虽为我们所偏爱，但还原的过程必然只能进行到一定的层次，这不仅仅因为我们的心智不够，还有更重要的原因：自然界是不可以彻底还原的。</p><p>我们知道，世界是普遍联系的，世界上每个事物都和其他每个事物联系着。但事物之间的联系是怎样实现的呢？传统观点认为：不同的东西通过大量的中介过程统一起来，这就是说，事物之间的联系是层层递进的，是定域性的，任何物体只和其邻近产生即时联系，事物的超距作用是不可能的。世界的可还原性就建立在这样的宇宙绘景中，在这样的宇宙中，我们原则上可以将任何系统从宇宙中孤立出来进行考察，这个系统的边界条件是稳定的、可知的，我们可以通过边界条件的变化掌握和了解这个系统的性质和运行规律。将系统孤立的过程就是一个还原的过程，我们可以将大系统分割成一个个的小系统，小系统再细分为更小的系统，这样层层细分下去，从而我们所处的世界至少在理论上是可以彻底还原的。</p><p>然而，量子理论表明，世界的联系并不是定域性的。宇宙中的一切物质都存在着即时的普遍联系。在量子理论中，一切事物的运动都应该用波函数来描述，而波函数是遍布整个宇宙的。我现在坐在椅子上，我的身体伴随着有一个波函数，可以肯定这个波函数的值主要集中在我身体占有的空间内，接近100%，但不可能等于100%，在宇宙的其他地方，比如在火星上也会分布有我的波函数，虽然它们的值很小，非常接近于零，但不可能等于零。如果我的身体有任何的运动或变化，比如我动一下手指头，那么伴随我身体的波函数必然也要发生变化，而这个变化产生的影响将会遍布整个宇宙！火星上的一块石头如果“足够”地灵敏，它将会“感受”到这种影响，这种影响虽然非常非常之小，非常非常接近于零，但毕竟不等于零。在这样的宇宙绘景中，宇宙是一个不可分割的整体，如果我们一定要将某个时空孤立起来进行考察，那么由于宇宙中任何的变化都对它有影响，从而它的边界条件将会是整个宇宙！这个边界条件显然是不可知的。而且，外界对系统的作用也并不局限在边界，而是“深入”到系统内的每一个“部分”，这样系统内部的作用“场”也是不可知的。因此，这样的分割还原就变得没有任何实质性的意义。</p><p>所以，当我们用还原论的方法对事物进行考察的时候，我们实际上忽略了事物之间联系的量子效应。这样的“忽略”在通常情况下不会有什么问题，毕竟我的波函数在离开我身体哪怕只有一微米的地方就将衰减到几乎为零，它太小了，完全可以忽略不计。但是在那些必须考虑量子效应的地方，比如亚原子领域、比如宇宙“创生”的过程，这样的忽略就不能允许，这时候我们不能再采用还原论的研究方法，我们必须将整个宇宙都作为一个整体来考察。</p><p>很显然，只有在局域性不能忽略的地方，还原论才原则上不可行；在不必考虑局域性的地方，还原论原则上可行！</p><p>那么，在还原论原则上不可行的亚原子领域，还原论就没有价值了吗？<br>我认为，还原论仍然有重大的价值。因为，即便是存在非局域性，导致还原论原则上不可行的领域，我们还是需要了解个体的性质，要通过个体的行为来理解（而不是推导）整体的行为。</p><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li><a href="https://baike.baidu.com/item/%E6%95%B4%E4%BD%93%E8%AE%BA" target="_blank" rel="noopener">整体论</a></li><li><a href="https://baike.baidu.com/item/%E8%BF%98%E5%8E%9F%E8%AE%BA" target="_blank" rel="noopener">还原论</a></li><li><a href="http://www.pstruc.org/Article/shi/423.html" target="_blank" rel="noopener">刘劲杨：论整体论与还原论之争</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;还原论&quot;&gt;&lt;a href=&quot;#还原论&quot; class=&quot;headerlink&quot; title=&quot;还原论&quot;&gt;&lt;/a&gt;还原论&lt;/h2&gt;&lt;p&gt;所谓还原，是一种把复杂的系统（或者现象、过程）层层分解为其组成部分的过程。&lt;strong&gt;还原论&lt;/strong&gt;认为，复杂系统可以通过它各个组成部分的行为及其相互作用来加以解释。还原论方法是迄今为止自然科学研究的最基本的方法，人们习惯于以“静止的、孤立的”观点考察组成系统诸要素的行为和性质，然后将这些性质“组装”起来形成对整个系统的描述。例如，为了考察生命，我们首先考察神经系统、消化系统、免疫系统等各个部分的功能和作用，在考察这些系统的时候我们又要了解组成它们的各个器官，要了解器官又必须考察组织，直到最后是对细胞、蛋白质、遗传物质、分子、原子等的考察。现代科学的高度发达表明，还原论是比较合理的研究方法，寻找并研究物质的最基本构件的做法当然是有价值的。&lt;/p&gt;
    
    </summary>
    
      <category term="哲学" scheme="http://www.iamlightsmile.com/categories/%E5%93%B2%E5%AD%A6/"/>
    
    
      <category term="哲学" scheme="http://www.iamlightsmile.com/tags/%E5%93%B2%E5%AD%A6/"/>
    
      <category term="抽象" scheme="http://www.iamlightsmile.com/tags/%E6%8A%BD%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>线性代数</title>
    <link href="http://www.iamlightsmile.com/articles/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <id>http://www.iamlightsmile.com/articles/线性代数/</id>
    <published>2019-04-22T06:26:05.000Z</published>
    <updated>2019-04-22T08:32:44.298Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>线性代数是研究线性空间及其线性映射的，或者说各种线性结构和态射。</p><h2 id="价值"><a href="#价值" class="headerlink" title="价值"></a>价值</h2><p>由于线性结构非常常见，所以线性代数的价值也相当大。</p><a id="more"></a><h2 id="意义和地位"><a href="#意义和地位" class="headerlink" title="意义和地位"></a>意义和地位</h2><p>线性代数在数学、物理学和技术学科中有各种重要应用，因而它在各种代数分支中占居首要地位。在计算机广泛应用的今天，计算机图形学、计算机辅助设计、密码学、虚拟现实等技术无不以线性代数为其理论和算法基础的一部分。线性代数所体现的几何观念与代数方法之间的联系，从具体概念抽象出来的公理化方法以及严谨的逻辑推证、巧妙的归纳综合等，对于强化人们的数学训练，增益科学智能是非常有用的。随着科学的发展，我们不仅要研究单个变量之间的关系，还要进一步研究多个变量之间的关系，各种实际问题在大多数情况下可以线性化，而由于计算机的发展，线性化了的问题又可以被计算出来，线性代数正是解决这些问题的有力工具。线性代数的计算方法也是计算数学里一个很重要的内容。<br>线性代数的含义随数学的发展而不断扩大。线性代数的理论和方法已经渗透到数学的许多分支，同时也是理论物理和理论化学所不可缺少的代数基础知识。</p><p>“以直代曲”是人们处理很多数学问题时一个很自然的思想。很多实际问题的处理，最后往往归结为线性问题，它比较容易处理。因此，线性代数在工程技术和国民经济的许多领域都有着广泛的应用，是一门基本的和重要的学科。</p><p>如果进入科研领域，你就会发现，只要不是线性的东西，我们基本都不会！线性是人类少数可以研究得非常透彻的数学基础性框架。学好线性代数，你就掌握了绝大多数可解问题的钥匙。有了这把钥匙，再加上相应的知识补充，你就可以求解相应的问题。可以说，不学线性代数，你就漏过了95%的人类智慧！非线性的问题极为困难，我们并没有足够多的通用的性质和定理用于求解具体问题。如果能够把非线性的问题化为线性的，这是我们一定要走的方向！</p><p>事实上，微积分“以直代曲”的思想就是将整体非线性化为局部线性的一个经典的例子，尽管高等数学在定义微分时并没有用到一点线性代数的内容。许多非线性问题的处理――譬如流形、微分几何等，最后往往转化为线性问题。包括科学研究中，非线性模型通常也可以被近似为线性模型。随着研究对象的复杂化与抽象化，对非线性问题线性化，以及对线性问题的求解，就难免涉及到线性代数的术语和方法了。从这个意义上，线性代数可以被认为是许多近、现代数学分支的共同基础。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/800" target="_blank" rel="noopener">线性代数</a></li><li><a href="https://www.wanmen.org/courses/586d23485f07127674135dcb/lectures/586d23535f0712767415a8e0" target="_blank" rel="noopener">把非线性转化成线性</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h2&gt;&lt;p&gt;线性代数是研究线性空间及其线性映射的，或者说各种线性结构和态射。&lt;/p&gt;
&lt;h2 id=&quot;价值&quot;&gt;&lt;a href=&quot;#价值&quot; class=&quot;headerlink&quot; title=&quot;价值&quot;&gt;&lt;/a&gt;价值&lt;/h2&gt;&lt;p&gt;由于线性结构非常常见，所以线性代数的价值也相当大。&lt;/p&gt;
    
    </summary>
    
      <category term="数学" scheme="http://www.iamlightsmile.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="数学" scheme="http://www.iamlightsmile.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>概率论与数理统计</title>
    <link href="http://www.iamlightsmile.com/articles/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"/>
    <id>http://www.iamlightsmile.com/articles/概率论与数理统计/</id>
    <published>2019-04-22T06:25:41.000Z</published>
    <updated>2019-04-22T08:32:38.823Z</updated>
    
    <content type="html"><![CDATA[<p>概率论与数理统计的核心是<strong>利用微积分工具研究随机现象背后的客观规律性</strong>。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;概率论与数理统计的核心是&lt;strong&gt;利用微积分工具研究随机现象背后的客观规律性&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="数学" scheme="http://www.iamlightsmile.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="数学" scheme="http://www.iamlightsmile.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
</feed>
