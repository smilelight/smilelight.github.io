<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lightsmile&#39;s Blog</title>
  
  <subtitle>lightsmile</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.iamlightsmile.com/"/>
  <updated>2020-10-26T05:08:45.481Z</updated>
  <id>https://www.iamlightsmile.com/</id>
  
  <author>
    <name>lightsmile</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>国内博客网站说明</title>
    <link href="https://www.iamlightsmile.com/articles/%E5%9B%BD%E5%86%85%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E8%AF%B4%E6%98%8E/"/>
    <id>https://www.iamlightsmile.com/articles/%E5%9B%BD%E5%86%85%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E8%AF%B4%E6%98%8E/</id>
    <published>2020-10-26T05:05:39.000Z</published>
    <updated>2020-10-26T05:08:45.481Z</updated>
    
    <content type="html"><![CDATA[<p>本博客国内网址链接为：<a href="https://www.lightsmile.cn/" target="_blank" rel="noopener">lightsmile’s Blog</a>。</p><p>另：国内网站采用腾讯云服务器，自己写了两篇关于翻墙的文章被人举报，无奈将两篇文章删除，并且不再同步更新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本博客国内网址链接为：&lt;a href=&quot;https://www.lightsmile.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;lightsmile’s Blog&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;另：国内网站采用腾讯云服务器，自己写了两篇关于翻墙的文章
      
    
    </summary>
    
    
      <category term="其他" scheme="https://www.iamlightsmile.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="翻墙" scheme="https://www.iamlightsmile.com/tags/%E7%BF%BB%E5%A2%99/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch分页搜索</title>
    <link href="https://www.iamlightsmile.com/articles/Elasticsearch%E5%88%86%E9%A1%B5%E6%90%9C%E7%B4%A2/"/>
    <id>https://www.iamlightsmile.com/articles/Elasticsearch%E5%88%86%E9%A1%B5%E6%90%9C%E7%B4%A2/</id>
    <published>2020-10-26T04:59:22.000Z</published>
    <updated>2020-10-26T05:00:53.770Z</updated>
    
    <content type="html"><![CDATA[<p>目前已经找到Elasticsearch分页搜索实现机制，目前仅考虑使用<code>from-size</code>机制，具体在通过Python的Elasticsearch库调用时有两种方式：</p><a id="more"></a><h3 id="方式一：restful风格"><a href="#方式一：restful风格" class="headerlink" title="方式一：restful风格"></a>方式一：restful风格</h3><p>使用示例：</p><pre><code class="lang-python">from elasticsearch import Elasticsearches = Elasticsearch()# es = Elasticsearch(hosts={&quot;host&quot;: &quot;localhost&quot;, &quot;port&quot;: 9200})index = &quot;index&quot;query_body = {    &quot;from&quot;: 5,    &quot;size&quot;: 10,    &quot;query&quot;: {        &quot;match&quot;: {            &quot;word&quot;: &quot;测试&quot;        }    }}res = es.search(index=index, body=query_body)</code></pre><p>其中<code>from</code>指定偏移量，<code>size</code>指定返回结果个数。</p><h3 id="方式二：Python风格"><a href="#方式二：Python风格" class="headerlink" title="方式二：Python风格"></a>方式二：Python风格</h3><p>使用示例：</p><pre><code class="lang-python">from elasticsearch import Elasticsearches = Elasticsearch()# es = Elasticsearch(hosts={&quot;host&quot;: &quot;localhost&quot;, &quot;port&quot;: 9200})index = &quot;index&quot;query_body = {    &quot;query&quot;: {        &quot;match&quot;: {            &quot;word&quot;: &quot;测试&quot;        }    }}res = es.search(index=index, body=query_body, from_=5, size=10)</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/171dcd33ab02" target="_blank" rel="noopener">elasticsearch 分页查询实现方案 - 简书</a></li><li><a href="https://wonderomg.github.io/2018/05/17/Elasticsearch%E5%AE%9E%E8%B7%B5api%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/" target="_blank" rel="noopener">Elasticsearch实践(3)-api分页查询 | WONDEROMG</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前已经找到Elasticsearch分页搜索实现机制，目前仅考虑使用&lt;code&gt;from-size&lt;/code&gt;机制，具体在通过Python的Elasticsearch库调用时有两种方式：&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="https://www.iamlightsmile.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="Elasticsearch" scheme="https://www.iamlightsmile.com/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>使用终端文件管理器ranger</title>
    <link href="https://www.iamlightsmile.com/articles/%E4%BD%BF%E7%94%A8%E7%BB%88%E7%AB%AF%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8ranger/"/>
    <id>https://www.iamlightsmile.com/articles/%E4%BD%BF%E7%94%A8%E7%BB%88%E7%AB%AF%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8ranger/</id>
    <published>2020-10-25T15:08:33.000Z</published>
    <updated>2020-10-25T15:21:09.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h2><p>之前早在18年就使用过Linux下终端文件管理器ranger，后来在Manjaro系统下也使用过，不过最近发现安装的ranger一直都不能预览文件，就很懵逼，一直不甘心，于是各种找解决方案。</p><a id="more"></a><h2 id="1-解决方案"><a href="#1-解决方案" class="headerlink" title="1.解决方案"></a>1.解决方案</h2><p>后来看到这篇教程：<a href="https://www.pythonf.cn/read/49398" target="_blank" rel="noopener">终端文件管理Ranger</a>才知道root账号是不能使用预览功能的，如果开启只能动Python源码。</p><p>具体为修改<code>site-packages/ranger/core/main.py</code>文件的大约141行，如下：</p><pre><code class="lang-python">        if fm.username == &#39;root&#39;:            fm.settings.preview_files = False            fm.settings.use_preview_script = False            LOG.info(&quot;Running as root, disabling the file previews.&quot;)</code></pre><p>把这几行注释掉就可以了。</p><p>然后重新打开ranger发现已经开启预览了嘻嘻。</p><p>关于如何定位<code>main.py</code>具体位置，主要是判断自己是在哪个Python环境下安装的ranger。如我是在miniconda下默认Python环境安装的ranger，并且miniconda的安装位置为<code>/opt/miniconda3</code>，所以我就在该路径下使用find命令即可找到ranger库文件，如下：</p><pre><code class="lang-bash">(base) ➜  miniconda3 find . -name &quot;*ranger*&quot;   ./lib/python3.8/site-packages/ranger_fm-1.9.3.dist-info./lib/python3.8/site-packages/ranger./bin/ranger./share/applications/ranger.desktop./share/doc/ranger./share/man/man1/ranger.1</code></pre><p>然后该<code>mian.py</code>的绝对路径则为<code>/opt/miniconda3/lib/python3.8/site-packages/ranger/core/main.py</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0.前言&quot;&gt;&lt;/a&gt;0.前言&lt;/h2&gt;&lt;p&gt;之前早在18年就使用过Linux下终端文件管理器ranger，后来在Manjaro系统下也使用过，不过最近发现安装的ranger一直都不能预览文件，就很懵逼，一直不甘心，于是各种找解决方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.iamlightsmile.com/categories/Linux/"/>
    
    
      <category term="ranger, Linux" scheme="https://www.iamlightsmile.com/tags/ranger-Linux/"/>
    
  </entry>
  
  <entry>
    <title>CentOS安装Hadoop</title>
    <link href="https://www.iamlightsmile.com/articles/CentOS%E5%AE%89%E8%A3%85Hadoop/"/>
    <id>https://www.iamlightsmile.com/articles/CentOS%E5%AE%89%E8%A3%85Hadoop/</id>
    <published>2020-10-23T09:02:13.000Z</published>
    <updated>2020-10-23T15:13:27.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近决定学一些大数据、分布式之类的技术。其中最基本的比如说安装Hadoop，没想到安装个这个也不太顺利，这里简单记录一下。</p><a id="more"></a><p>主要参考的两篇教程：</p><ul><li><a href="https://www.jianshu.com/p/78f9cc79a766" target="_blank" rel="noopener">hadoop 3.1.3单机版安装教程 - 简书</a></li><li><a href="https://www.jianshu.com/p/27cbd5bbdf61" target="_blank" rel="noopener">【Hadoop】Hadoop 3.2.1 真伪分布式搭建 - 简书</a></li></ul><blockquote><p><strong>注意</strong>：本文将介绍伪分布式安装过程，至于真分布式不做介绍。</p></blockquote><h2 id="搭建流程"><a href="#搭建流程" class="headerlink" title="搭建流程"></a>搭建流程</h2><h3 id="1-安装java"><a href="#1-安装java" class="headerlink" title="1 安装java"></a>1 安装java</h3><p>略</p><h3 id="2-下载Hadoop"><a href="#2-下载Hadoop" class="headerlink" title="2 下载Hadoop"></a>2 下载Hadoop</h3><p>下载页：<a href="https://www.apache.org/dyn/closer.cgi/hadoop/common/hadoop-3.3.0/hadoop-3.3.0.tar.gz" target="_blank" rel="noopener">Apache Download Mirrors</a></p><h3 id="3-找到Java安装路径"><a href="#3-找到Java安装路径" class="headerlink" title="3 找到Java安装路径"></a>3 找到Java安装路径</h3><p>which java定位到的是java程序的执行路径，而不是安装路径，经过两次-lrt最后的输出才是安装路径。</p><p>具体参考第2篇文档。</p><h3 id="4-安装Hadoop"><a href="#4-安装Hadoop" class="headerlink" title="4 安装Hadoop"></a>4 安装Hadoop</h3><p>上面两篇文档放置的Hadoop的位置路径不同，一个是在<code>/home/</code>路径下，一个是在<code>usr/local/hadoop</code>下，而我自己选择了<code>/opt</code>下面。</p><p>相关不同可以参考：<a href="https://blog.csdn.net/baidu_30000217/article/details/78936790" target="_blank" rel="noopener">Linux 软件安装到 /usr，/usr/local/ 还是 /opt 目录？_LSGOZJ的博客-CSDN博客</a></p><h3 id="5-设置Hadoop启动项"><a href="#5-设置Hadoop启动项" class="headerlink" title="5 设置Hadoop启动项"></a>5 设置Hadoop启动项</h3><p>同样的，上面两篇教程中配置方式也不相同，一篇直接修改<code>/etc/profile</code>，一篇修改<code>/etc/profile.d/hadoop.sh</code>，两者殊途同归，效果一致。</p><p>内容大致即：</p><pre><code class="lang-bash">export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-0.el7_7.x86_64  export HADOOP_HOME=/home/hadoop-3.2.1export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</code></pre><p>然后使配置生效刷新环境变量，即运行<code>source /etc/profile</code></p><h3 id="6-创建hadoop用户"><a href="#6-创建hadoop用户" class="headerlink" title="6 创建hadoop用户"></a>6 创建hadoop用户</h3><pre><code class="lang-bash">adduser hadoop # 新增用户passwd hadoop # 设置秘密groupadd hadoop # 新建用户组usermod -G hadoop hadoop # 将用户添加到用户组id hadoop # 查看用户情况</code></pre><h3 id="7-创建hadoop文件目录并授权"><a href="#7-创建hadoop文件目录并授权" class="headerlink" title="7 创建hadoop文件目录并授权"></a>7 创建hadoop文件目录并授权</h3><pre><code class="lang-bash">mkdir -p /home/hadoop/tmp # hadoop临时文件目录mkdir -p /home/hadoop/hdfs/name # hadoop主节点(namenode)文件目录mkdir -p /home/hadoop/hdfs/data # hadoop数据节点(datanode)文件目录mkdir -p /home/hadoop/log # hadoop日志文件目录chown -R hadoop:hadoop /home/hadoop # 设置hadoop文件目录所有者</code></pre><h3 id="8-修改hadoop配置文件"><a href="#8-修改hadoop配置文件" class="headerlink" title="8 修改hadoop配置文件"></a>8 修改hadoop配置文件</h3><p>hadoop的配置文件都在 etc/hadoop 目录下，配置文件有很多，最基本要修改3个文件：hadoop-env.sh ，core-site.xml，hdfs-site.xml。</p><h4 id="8-1-hadoop-env-sh"><a href="#8-1-hadoop-env-sh" class="headerlink" title="8.1 hadoop-env.sh"></a>8.1 hadoop-env.sh</h4><pre><code class="lang-bash">export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-0.el7_7.x86_64 # 需要指定Java路径export HADOOP_LOG_DIR=/home/hadoop/log # 需要指定hadoop_log_dir</code></pre><h4 id="8-2-core-site-xml"><a href="#8-2-core-site-xml" class="headerlink" title="8.2 core-site.xml"></a>8.2 core-site.xml</h4><pre><code class="lang-xml">&lt;configuration&gt;    &lt;property&gt;        &lt;name&gt;fs.defaultFS&lt;/name&gt;        &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;        &lt;description&gt;hdfs内部通讯访问地址&lt;/description&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;        &lt;value&gt;file:/home/hadoop/tmp&lt;/value&gt;        &lt;description&gt;hadoop数据存放&lt;/description&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre><h4 id="8-3-hdfs-site-xml"><a href="#8-3-hdfs-site-xml" class="headerlink" title="8.3 hdfs-site.xml"></a>8.3 hdfs-site.xml</h4><pre><code class="lang-xml">&lt;configuration&gt;    &lt;property&gt;        &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;        &lt;value&gt;file:/home/hadoop/hdfs/name&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;        &lt;value&gt;file:/home/hadoop/hdfs/data&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;dfs.replication&lt;/name&gt;        &lt;value&gt;1&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre><h3 id="9-设置ssh免密登录"><a href="#9-设置ssh免密登录" class="headerlink" title="9 设置ssh免密登录"></a>9 设置ssh免密登录</h3><blockquote><p><strong>注意</strong>：以下命令均是在hadoop用户下进行。</p></blockquote><p>需要用前面创建的hadoop用户通过ssh免密访问本地，先切换到hadoop用户目录下，执行以下命令：</p><pre><code class="lang-bash">ssh-keygen -t dsa -P &#39;&#39; -f ~/.ssh/id_dsacat ~/.ssh/id_dsa.pub &gt;&gt; ~/.ssh/authorized_keyschmod 0600 ~/.ssh/authorized_keys</code></pre><p>测试是否成功，执行下面命令，若不用输入密码则成功。</p><pre><code class="lang-bash">ssh localhost</code></pre><h3 id="10-启动hadoop"><a href="#10-启动hadoop" class="headerlink" title="10 启动hadoop"></a>10 启动hadoop</h3><blockquote><p><strong>注意</strong>：以下命令均是在hadoop用户下进行。</p></blockquote><h4 id="10-1-格式化hadoop文件系统"><a href="#10-1-格式化hadoop文件系统" class="headerlink" title="10.1 格式化hadoop文件系统"></a>10.1 格式化hadoop文件系统</h4><pre><code class="lang-bash">hdfs namenode -format</code></pre><h4 id="10-2-一键启动"><a href="#10-2-一键启动" class="headerlink" title="10.2 一键启动"></a>10.2 一键启动</h4><pre><code class="lang-bash">start-all.sh</code></pre><h4 id="10-3-检验"><a href="#10-3-检验" class="headerlink" title="10.3 检验"></a>10.3 检验</h4><p>输入命令 ，没有报错，则hadoop单机版安装成功。</p><pre><code class="lang-bash">hadoop fs -ls /</code></pre><h3 id="11-查看启动效果"><a href="#11-查看启动效果" class="headerlink" title="11 查看启动效果"></a>11 查看启动效果</h3><p>访问<code>http://localhost:9870</code>，可以得到如下图所示：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/hadoop_front.png" alt="hadoop效果"></p><h3 id="其他文章"><a href="#其他文章" class="headerlink" title="其他文章"></a>其他文章</h3><ul><li><a href="https://www.cnblogs.com/luo630/p/13271637.html" target="_blank" rel="noopener">Hadoop、HBase、Spark单机安装 - 工程师二号 - 博客园</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近决定学一些大数据、分布式之类的技术。其中最基本的比如说安装Hadoop，没想到安装个这个也不太顺利，这里简单记录一下。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Debian或Ubuntu安装Nodejs</title>
    <link href="https://www.iamlightsmile.com/articles/Debian%E6%88%96Ubuntu%E5%AE%89%E8%A3%85Nodejs/"/>
    <id>https://www.iamlightsmile.com/articles/Debian%E6%88%96Ubuntu%E5%AE%89%E8%A3%85Nodejs/</id>
    <published>2020-10-22T01:20:32.000Z</published>
    <updated>2020-10-22T01:31:31.760Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h2><p>安装最新Nodejs的命令如下：</p><a id="more"></a><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><pre><code class="lang-bash">curl -sL https://deb.nodesource.com/setup_15.x | sudo -E bash -sudo apt-get install -y nodejs</code></pre><h3 id="Debian"><a href="#Debian" class="headerlink" title="Debian"></a>Debian</h3><pre><code class="lang-bash">curl -sL https://deb.nodesource.com/setup_15.x | bash -apt-get install -y nodejs</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/nodesource/distributions" target="_blank" rel="noopener">nodesource/distributions: NodeSource Node.js Binary Distributions</a></li><li><a href="https://ywnz.com/linuxjc/5819.html" target="_blank" rel="noopener">在Debian 10系统上安装Node.js和npm的三种不同方法_Linux教程_云网牛站</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装命令&quot;&gt;&lt;a href=&quot;#安装命令&quot; class=&quot;headerlink&quot; title=&quot;安装命令&quot;&gt;&lt;/a&gt;安装命令&lt;/h2&gt;&lt;p&gt;安装最新Nodejs的命令如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.iamlightsmile.com/categories/Linux/"/>
    
    
      <category term="Debian" scheme="https://www.iamlightsmile.com/tags/Debian/"/>
    
      <category term="Nodejs" scheme="https://www.iamlightsmile.com/tags/Nodejs/"/>
    
      <category term="Ubuntu" scheme="https://www.iamlightsmile.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用工具</title>
    <link href="https://www.iamlightsmile.com/articles/Linux%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    <id>https://www.iamlightsmile.com/articles/Linux%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</id>
    <published>2020-10-18T04:37:21.000Z</published>
    <updated>2020-10-18T04:37:21.787Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>使用docker遇到的问题</title>
    <link href="https://www.iamlightsmile.com/articles/%E4%BD%BF%E7%94%A8docker%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://www.iamlightsmile.com/articles/%E4%BD%BF%E7%94%A8docker%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-10-17T11:14:13.000Z</published>
    <updated>2020-10-22T03:09:12.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-容器内文件无法删除"><a href="#1-容器内文件无法删除" class="headerlink" title="1.容器内文件无法删除"></a>1.容器内文件无法删除</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>最近使用docker部署项目，结果发现docker里的文件无法删除，于是开始Google寻求解决方案。</p><a id="more"></a><h3 id="探索过程"><a href="#探索过程" class="headerlink" title="探索过程"></a>探索过程</h3><p>刚开始搜到<a href="https://www.escapelife.site/posts/d9b10b4c.html" target="_blank" rel="noopener">Docker容器内文件无法删除 | Escape</a>，还以为是Centos7本身的bug，但是还是怀疑这种常见的问题应该早就被修复掉了，不应该像文档中那么麻烦。</p><p>之前的问题使用的是公司的内网服务器，Centos7系统；然而自己在自己的腾讯云Centos7系统上也测试了一下删除文件，发现就没有问题。同时自己在使用docker的neo4j容器时遇到了访问文件受限的问题，根据错误信息发现了该issue：<a href="https://github.com/neo4j/docker-neo4j/issues/266" target="_blank" rel="noopener">uid and gid change · Issue #266 · neo4j/docker-neo4j</a>，发现里面提到了docker版本的bug。发现自己服务器上的docker版本比较新，同时检查了下公司内网服务器中的docker版本还挺老旧的。于是网上搜索docker升级命令，找到了<a href="https://www.cnblogs.com/operationhome/p/11322150.html" target="_blank" rel="noopener">Docker 更新版本 - 自由早晚乱余生 - 博客园</a>。这篇文档写的很详细，在遇到的问题部分中提到了Linux内核版本的问题，自己又查看对比了下自己服务器和内网机内核版本，发现差别还真挺大的。内网机版本号才300多，而自己的都900多了。其中文档提到版本号514是个坎。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>升级系统内核版本+升级docker版本就可以解决该问题。</p><h2 id="2-debian操作系统离线安装docker以及docker-compose"><a href="#2-debian操作系统离线安装docker以及docker-compose" class="headerlink" title="2.debian操作系统离线安装docker以及docker-compose"></a>2.debian操作系统离线安装docker以及docker-compose</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>不知道怎么离线安装，网上找教程即可。</p><h3 id="探索过程-1"><a href="#探索过程-1" class="headerlink" title="探索过程"></a>探索过程</h3><p>找到的两篇文章：</p><ul><li><a href="https://blog.csdn.net/qq_23287943/article/details/96124441" target="_blank" rel="noopener">基于凝思磐石&amp;debian内网环境搭建docker集群_解忧小童子-CSDN博客</a></li><li><a href="https://www.cnblogs.com/nihaorz/p/12123803.html" target="_blank" rel="noopener">debian 10.x (buster) 离线安装docker及卸载 - Nihaorz - 博客园</a></li></ul><p>其中第一篇同时提到了安装docker和docker-compose，第二篇只提到了安装docker但是更加详细。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>参照上面第二篇文档安装docker，参照上面第一篇文档安装docker-compose。</p><p>类似的一键安装脚本可以写成：</p><pre><code class="lang-bash">#!/bin/bash# install dockerdpkg -i containerd.io_1.3.7-1_amd64.debdpkg -i docker-ce-cli_19.03.9~3-0~debian-buster_amd64.debdpkg -i docker-ce_19.03.9~3-0~debian-buster_amd64.deb# check docker versiondocker info# install docker-composecp docker-compose-Linux-x86_64 /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-composeln -snvf /usr/local/bin/docker-compose /usr/bin/docker-compose# check docker-compose versiondocker-compose -v</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-容器内文件无法删除&quot;&gt;&lt;a href=&quot;#1-容器内文件无法删除&quot; class=&quot;headerlink&quot; title=&quot;1.容器内文件无法删除&quot;&gt;&lt;/a&gt;1.容器内文件无法删除&lt;/h2&gt;&lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;最近使用docker部署项目，结果发现docker里的文件无法删除，于是开始Google寻求解决方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="https://www.iamlightsmile.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="docker" scheme="https://www.iamlightsmile.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker常用命令</title>
    <link href="https://www.iamlightsmile.com/articles/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://www.iamlightsmile.com/articles/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2020-10-14T07:06:18.000Z</published>
    <updated>2020-10-22T03:13:18.820Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-查看容器内系统版本"><a href="#1-查看容器内系统版本" class="headerlink" title="1.查看容器内系统版本"></a>1.查看容器内系统版本</h2><pre><code class="lang-bash">cat /etc/issue</code></pre><blockquote><p><strong>注意</strong>：不能使用<code>cat /proc/version</code> 或 <code>uname -a</code>，因为docker并不能隔离像/dev、/proc的目录，这些都是直接挂载的宿主机的。所以，很多命令像free top之类的命令，其实看到的都是宿主机的。因为这些命令都是基于/proc下的信息统计出来的</p></blockquote><p>参考：<a href="https://blog.csdn.net/c461522756/article/details/70822234" target="_blank" rel="noopener">docker容器中查看容器linux版本_貌似爽歪歪的博客-CSDN博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-查看容器内系统版本&quot;&gt;&lt;a href=&quot;#1-查看容器内系统版本&quot; class=&quot;headerlink&quot; title=&quot;1.查看容器内系统版本&quot;&gt;&lt;/a&gt;1.查看容器内系统版本&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;cat /etc
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.iamlightsmile.com/categories/Linux/"/>
    
    
      <category term="Docker" scheme="https://www.iamlightsmile.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>知识库学习心得随记</title>
    <link href="https://www.iamlightsmile.com/articles/%E7%9F%A5%E8%AF%86%E5%BA%93%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%E9%9A%8F%E8%AE%B0/"/>
    <id>https://www.iamlightsmile.com/articles/%E7%9F%A5%E8%AF%86%E5%BA%93%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%E9%9A%8F%E8%AE%B0/</id>
    <published>2020-10-10T08:13:47.000Z</published>
    <updated>2020-10-10T08:28:41.012Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看一些知识库的项目，自己小有体会，这里简单记录一下。</p><a id="more"></a><p>近几个月来，出于项目需要，自己简单学习了下Elasticsearch，并且重新学习了下Neo4j。我发现看的知识库的项目所使用的数据库不尽相同，有基于Neo4j的，有基于Elasticsearch的，有基于MongoDB的，这不禁令我反思。</p><p>这些数据库的相似之处在于都非关系型数据库，不同之处在于各自所更能适配的数据类型不同。Neo4j更适配的数据是那些数据类型简单但之间关系复杂多样化的，Elasticsearch更适配的数据或者说场景是待检索的数据尤其是需要定制复杂规则过滤排序的数据，而MongoDB则更加通用一些。</p><p>在实际项目中，对于数据量比较小或者业务场景比较简单的情况下，其实这三种数据库基本都能完成需求；而只有当数据的量级很大（比如在上百万条）以及业务场景比较复杂的情况下，三种各自的优劣才能比较明显的体现出来。数据库之间也没有通用的优劣高低之分，只有哪个更适配任务的数据类型和场景之分。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看一些知识库的项目，自己小有体会，这里简单记录一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="知识图谱" scheme="https://www.iamlightsmile.com/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
    
      <category term="知识库" scheme="https://www.iamlightsmile.com/tags/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Neo4j使用小记</title>
    <link href="https://www.iamlightsmile.com/articles/Neo4j%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0/"/>
    <id>https://www.iamlightsmile.com/articles/Neo4j%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0/</id>
    <published>2020-10-10T07:54:55.000Z</published>
    <updated>2020-10-10T08:28:41.012Z</updated>
    
    <content type="html"><![CDATA[<p>使用社区版Neo4j时有一些注意事项，这里简单小记一下。</p><a id="more"></a><h2 id="1-一台机器启动多个Neo4j数据库"><a href="#1-一台机器启动多个Neo4j数据库" class="headerlink" title="1.一台机器启动多个Neo4j数据库"></a>1.一台机器启动多个Neo4j数据库</h2><p>最好的方式，甚至是唯一的选择是使用Docker。</p><p>现在版本（4.0以上）的Neo4j貌似不能使用拷贝程序到不同目录设置不同端口执行了。</p><p>我们可以在Neo4j社区版中创建多个数据库，但是同时只能使用一个。</p><p>如图，只有默认数据库和系统数据库可以切换，其他的数据库的状态是未连接的。</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/neo4j_show_databases.png" alt=""></p><p>如果需要创建多个数据库，那么我们只需要在neo4j的配置文件即<code>neo4j.conf</code>中<code>dbms.default_database=baike</code>一行设置新的数据库名并重启neo4j即可，如前句中为<code>baike</code>。</p><p>相应的，如果需要切换数据库，则只能先修改neo4j.conf配置文件的default_database选项，然后重启neo4j。</p><h2 id="2-Neo4j使用的Apoc需要配套版本"><a href="#2-Neo4j使用的Apoc需要配套版本" class="headerlink" title="2.Neo4j使用的Apoc需要配套版本"></a>2.Neo4j使用的Apoc需要配套版本</h2><p>具体在<a href="https://github.com/neo4j-contrib/neo4j-apoc-procedures/releases" target="_blank" rel="noopener">Releases · neo4j-contrib/neo4j-apoc-procedures</a>页下载。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用社区版Neo4j时有一些注意事项，这里简单小记一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="https://www.iamlightsmile.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="Neo4j" scheme="https://www.iamlightsmile.com/tags/Neo4j/"/>
    
  </entry>
  
  <entry>
    <title>配置VSCode-Remote-Container</title>
    <link href="https://www.iamlightsmile.com/articles/%E9%85%8D%E7%BD%AEVSCode-Remote-Container/"/>
    <id>https://www.iamlightsmile.com/articles/%E9%85%8D%E7%BD%AEVSCode-Remote-Container/</id>
    <published>2020-09-15T14:37:28.000Z</published>
    <updated>2020-10-10T08:10:56.180Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h2><p>我服了，vscode确实太香了。</p><a id="more"></a><h2 id="1-远程主机配置"><a href="#1-远程主机配置" class="headerlink" title="1.远程主机配置"></a>1.远程主机配置</h2><blockquote><p><strong>注意</strong>：以下基于CentOS7环境。</p></blockquote><h3 id="1-1-安装docker"><a href="#1-1-安装docker" class="headerlink" title="1.1 安装docker"></a>1.1 安装docker</h3><p>一键安装脚本：</p><pre><code class="lang-bash">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</code></pre><p>可参考：<a href="https://www.runoob.com/docker/centos-docker-install.html" target="_blank" rel="noopener">CentOS Docker 安装 | 菜鸟教程</a></p><h3 id="1-2-配置docker"><a href="#1-2-配置docker" class="headerlink" title="1.2 配置docker"></a>1.2 配置docker</h3><p>在远程主机上：</p><ol><li>创建文件<code>daemon.json</code>到目录<code>/etc/docker</code>:</li></ol><pre><code class="lang-josn">{&quot;hosts&quot;: [&quot;tcp://0.0.0.0:2375&quot;, &quot;unix:///var/run/docker.sock&quot;]}</code></pre><ol><li>创建文件<code>/etc/systemd/system/docker.service.d/override.conf</code>:</li></ol><pre><code class="lang-conf">[Service]ExecStart=ExecStart=/usr/bin/dockerd</code></pre><ol><li>重启docker：</li></ol><pre><code class="lang-bash">systemctl daemon-reloadsystemctl restart docker.service</code></pre><h2 id="2-本地桌面配置"><a href="#2-本地桌面配置" class="headerlink" title="2.本地桌面配置"></a>2.本地桌面配置</h2><blockquote><p><strong>注意</strong>：以下基于Windows10桌面专业版环境。</p></blockquote><h3 id="2-1-安装OpenSSL"><a href="#2-1-安装OpenSSL" class="headerlink" title="2.1 安装OpenSSL"></a>2.1 安装OpenSSL</h3><p>略，自带了。</p><h3 id="2-2-生成ssh秘钥对"><a href="#2-2-生成ssh秘钥对" class="headerlink" title="2.2 生成ssh秘钥对"></a>2.2 生成ssh秘钥对</h3><p>略，参见：<a href="http://www.iamlightsmile.com/articles/%E9%85%8D%E7%BD%AEVSCode-Remote-SSH/">配置VSCode-Remote-SSH - lightsmile’s Blog</a></p><p>注意，如我的<code>~/.ssh/config</code>中部分内容为：</p><pre><code class="lang-config">Host tencent_cloud    HostName xx.xx.xx.xx    PreferredAuthentications publickey    User root    IdentitiesOnly yes    # Port 22    IdentityFile ~/.ssh/tencent_cloud_desktop</code></pre><p>使用ssh免密登录的时候命令应该为：</p><pre><code class="lang-bash">ssh tencent_cloud</code></pre><h3 id="2-3-安装docker"><a href="#2-3-安装docker" class="headerlink" title="2.3 安装docker"></a>2.3 安装docker</h3><p>下载<a href="https://github.com/StefanScherer/docker-cli-builder/releases/" target="_blank" rel="noopener">docker.exe</a> 并配置路径（其实配不配都可以，因为我把这个路径放到环境变量里进入shell还是没找到2333~。）</p><h3 id="2-4-配置docker服务"><a href="#2-4-配置docker服务" class="headerlink" title="2.4 配置docker服务"></a>2.4 配置docker服务</h3><p>创建一个context：</p><pre><code class="lang-bash">docker context create &lt;context name&gt; --docker &quot;host=ssh://&lt;user&gt;@&lt;host&gt;&quot;</code></pre><p>以我上面的ssh为例，上面的命令可以为：</p><pre><code class="lang-bash">docker context create tencent_cloud --docker &quot;host=ssh://tencent_cloud&quot;</code></pre><p>切换到上面的context：</p><pre><code class="lang-bash">docker context use &lt;context name&gt;</code></pre><p>以上面生成的context：tencent_cloud为例，上面的指令为：</p><pre><code class="lang-bash">docker context use tencent_cloud</code></pre><p>测试一下：</p><pre><code class="lang-bash">docker info</code></pre><p>这里会输出和在远程主机上运行 docker info 一样的结果， 实际上这里docker本地只是一个客户端，连接到远程主机上的docker服务。</p><h3 id="2-5-安装remote-container插件"><a href="#2-5-安装remote-container插件" class="headerlink" title="2.5 安装remote-container插件"></a>2.5 安装remote-container插件</h3><p>在拓展插件里搜索<code>remote container</code>并安装。</p><p>安装完成后，在vscode设置中搜索<code>remote docker path</code>，设置为之前下载的docker的路径（默认就是<code>docker</code>命令，我这里命令行里找不到，所以需要手动配置）</p><h2 id="3-开始项目"><a href="#3-开始项目" class="headerlink" title="3.开始项目"></a>3.开始项目</h2><h3 id="3-1-启动容器"><a href="#3-1-启动容器" class="headerlink" title="3.1 启动容器"></a>3.1 启动容器</h3><pre><code class="lang-bash">docker run -d --name &lt;container name&gt; -v ~/newproj:/workspaces/newproj &lt;image tag&gt; tail -f /dev/null</code></pre><blockquote><p><strong>注意：</strong> 这里要挂载项目目录到容器中方便保存文件。tail -f 这个命令是为了让容器保持运行。</p></blockquote><h3 id="3-2-vscode访问远程容器"><a href="#3-2-vscode访问远程容器" class="headerlink" title="3.2 vscode访问远程容器"></a>3.2 vscode访问远程容器</h3><ol><li>打开VSCode，按下<code>ctrl+shift+p</code>运行<code>docker contexts use</code>, 选择上面创建的docker context.</li><li>按下<code>ctrl+shift+p</code>运行<code>Remote-Containers:Attach to Running Container...</code>, 选择上面创建的容器名字。</li><li>在新打开的vscode窗口中环境即上面的容器内部，现在可以尽情搬砖了。</li></ol><blockquote><p><strong>注意：</strong> 可以连接的容器必须是正在持续运行着的的容器。（即使用类似<code>tail -f /dev/null</code>命令创建的容器）。</p></blockquote><h3 id="4-后记"><a href="#4-后记" class="headerlink" title="4.后记"></a>4.后记</h3><p>本文主要是拾人牙慧，原文为：<a href="https://segmentfault.com/a/1190000023095631#comment-area" target="_blank" rel="noopener">开发环境代码化: VSCode远程Docker容器作为开发环境 - 个人文章 - SegmentFault 思否</a>。但自己在实践过程中遇到了一些问题，比如ssh免密登陆，同时本着“输出是最好的学习”的原则，故记录之。</p><h3 id="5-参考"><a href="#5-参考" class="headerlink" title="5.参考"></a>5.参考</h3><ul><li><a href="https://segmentfault.com/a/1190000023095631#comment-area" target="_blank" rel="noopener">开发环境代码化: VSCode远程Docker容器作为开发环境 - 个人文章 - SegmentFault 思否</a></li><li><a href="https://blog.csdn.net/weiwosuoai/article/details/88430620" target="_blank" rel="noopener">Docker 查看镜像信息_犬小哈-CSDN博客</a></li><li><a href="https://www.runoob.com/docker/centos-docker-install.html" target="_blank" rel="noopener">CentOS Docker 安装 | 菜鸟教程</a></li><li><a href="https://deepzz.com/post/how-to-setup-ssh-config.html" target="_blank" rel="noopener">SSH Config 那些你所知道和不知道的事 | Deepzz’s Blog</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0.前言&quot;&gt;&lt;/a&gt;0.前言&lt;/h2&gt;&lt;p&gt;我服了，vscode确实太香了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="https://www.iamlightsmile.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="Docker" scheme="https://www.iamlightsmile.com/tags/Docker/"/>
    
      <category term="vscode" scheme="https://www.iamlightsmile.com/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>centos安装LibreOffice</title>
    <link href="https://www.iamlightsmile.com/articles/centos%E5%AE%89%E8%A3%85LibreOffice/"/>
    <id>https://www.iamlightsmile.com/articles/centos%E5%AE%89%E8%A3%85LibreOffice/</id>
    <published>2020-09-15T06:43:52.000Z</published>
    <updated>2020-09-15T08:03:05.529Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h2><p>最近的工作涉及到文档处理与转换，需要用到LibreOffice，所以这里简单记录下在centos环境下安装过程。</p><a id="more"></a><h2 id="1-下载并解压安装包"><a href="#1-下载并解压安装包" class="headerlink" title="1.下载并解压安装包"></a>1.下载并解压安装包</h2><h3 id="1-1-下载安装包"><a href="#1-1-下载安装包" class="headerlink" title="1.1 下载安装包"></a>1.1 下载安装包</h3><p>官网中文下载页：<a href="https://zh-cn.libreoffice.org/download/libreoffice/" target="_blank" rel="noopener">下载 LibreOffice | LibreOffice 简体中文官方网站 - 自由免费的办公套件</a></p><p>我们需要安装主安装程序以及中文语言安装包和中文离线帮助文件安装包，这里列出6.4.6版本的中文镜像源链接：</p><ul><li>主程序链接：<a href="https://mirrors.nju.edu.cn/tdf/libreoffice/stable/6.4.6/rpm/x86_64/LibreOffice_6.4.6_Linux_x86-64_rpm.tar.gz" target="_blank" rel="noopener">https://mirrors.nju.edu.cn/tdf/libreoffice/stable/6.4.6/rpm/x86_64/LibreOffice_6.4.6_Linux_x86-64_rpm.tar.gz</a></li><li>中文语言包链接：<a href="https://mirrors.nju.edu.cn/tdf/libreoffice/stable/6.4.6/rpm/x86_64/LibreOffice_6.4.6_Linux_x86-64_rpm_langpack_zh-CN.tar.gz" target="_blank" rel="noopener">https://mirrors.nju.edu.cn/tdf/libreoffice/stable/6.4.6/rpm/x86_64/LibreOffice_6.4.6_Linux_x86-64_rpm_langpack_zh-CN.tar.gz</a></li><li>中文离线帮助文件链接：<a href="https://mirrors.nju.edu.cn/tdf/libreoffice/stable/6.4.6/rpm/x86_64/LibreOffice_6.4.6_Linux_x86-64_rpm_helppack_zh-CN.tar.gz" target="_blank" rel="noopener">https://mirrors.nju.edu.cn/tdf/libreoffice/stable/6.4.6/rpm/x86_64/LibreOffice_6.4.6_Linux_x86-64_rpm_helppack_zh-CN.tar.gz</a></li></ul><h3 id="1-2-解压安装包"><a href="#1-2-解压安装包" class="headerlink" title="1.2 解压安装包"></a>1.2 解压安装包</h3><p>将安装包放置到合适的位置并且解压。</p><h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h2><pre><code class="lang-bash">$ sudo yum install ./LibreOffice_6.x.x_Linux_x86_rpm/RPMS/*.rpm  /* 安装主安装程序的所有rpm包 */$ sudo yum install ./LibreOffice_6.x.x_Linux_x86_rpm_langpack_zh-CN/RPMS/*.rpm  /* 安装中文语言包中的所有rpm包 */$ sudo yum install ./LibreOffice_6.x.x_Linux_x86_rpm_helppack_zh-CN/RPMS/*.rpm  /* 安装中文离线帮助文件中的所有rpm包 */</code></pre><h2 id="3-依赖"><a href="#3-依赖" class="headerlink" title="3.依赖"></a>3.依赖</h2><h3 id="3-1-查看安装位置"><a href="#3-1-查看安装位置" class="headerlink" title="3.1 查看安装位置"></a>3.1 查看安装位置</h3><pre><code class="lang-bash">whereis libreoffice</code></pre><p>得到如下输出：</p><pre><code class="lang-text">libreoffice: /usr/bin/libreoffice6.4 /usr/lib64/libreoffice</code></pre><h3 id="3-2-安装依赖"><a href="#3-2-安装依赖" class="headerlink" title="3.2 安装依赖"></a>3.2 安装依赖</h3><p>执行<code>libreoffice6.4</code>报库文件找不到的错误，需要安装一些库文件：</p><ul><li><code>yum install cairo -y</code></li><li><code>yum install cups-libs -y</code></li><li><code>yum install libSM -y</code></li></ul><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h2><h3 id="4-1-查看版本"><a href="#4-1-查看版本" class="headerlink" title="4.1 查看版本"></a>4.1 查看版本</h3><pre><code class="lang-bash">libreoffice6.4 --version</code></pre><p>得到如下结果：</p><pre><code class="lang-text">LibreOffice 6.4.6.2 0ce51a4fd21bff07a5c061082cc82c5ed232f115</code></pre><h3 id="4-2-创建软链接"><a href="#4-2-创建软链接" class="headerlink" title="4.2 创建软链接"></a>4.2 创建软链接</h3><p>由于联动的其他程序设置的libreoffice路径为<code>/usr/bin/soffice</code>，所以这里创建一个软链：</p><pre><code class="lang-bash">ln -s /opt/libreoffice6.4/program/soffice /usr/bin/soffice</code></pre><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5.参考"></a>5.参考</h2><ul><li><a href="http://qtdebug.com/mac-centos7-libreoffice/" target="_blank" rel="noopener">CentOS7 安装 LibreOffice | 公孙二狗</a></li><li><a href="https://zh-cn.libreoffice.org/get-help/install-howto/linux/" target="_blank" rel="noopener">Linux 下的安装方法 | LibreOffice 简体中文官方网站 - 自由免费的办公套件</a></li><li><a href="https://blog.csdn.net/m290345792/article/details/78518360" target="_blank" rel="noopener">linux软链接的创建、删除和更新_鲁不迅的专栏-CSDN博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0.前言&quot;&gt;&lt;/a&gt;0.前言&lt;/h2&gt;&lt;p&gt;最近的工作涉及到文档处理与转换，需要用到LibreOffice，所以这里简单记录下在centos环境下安装过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.iamlightsmile.com/categories/Linux/"/>
    
    
      <category term="centos" scheme="https://www.iamlightsmile.com/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://www.iamlightsmile.com/articles/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://www.iamlightsmile.com/articles/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2020-09-10T00:45:02.000Z</published>
    <updated>2020-10-22T03:05:00.519Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>注意</strong>：以下命令都是在CentOS上执行，在Ubuntu或其他发行版部分有所不同。</p></blockquote><a id="more"></a><h2 id="1-系统相关命令"><a href="#1-系统相关命令" class="headerlink" title="1.系统相关命令"></a>1.系统相关命令</h2><h3 id="1-1-查看系统版本"><a href="#1-1-查看系统版本" class="headerlink" title="1.1 查看系统版本"></a>1.1 查看系统版本</h3><pre><code class="lang-bash">(base) ➜  ~ cat /etc/redhat-releaseCentOS Linux release 7.7.1908 (Core)(base) ➜  ~ cat /proc/versionLinux version 3.10.0-957.21.3.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-36) (GCC) ) #1 SMP Tue Jun 18 16:35:19 UTC 2019(base) ➜  data uname -aLinux VM-32-15-centos 3.10.0-1127.19.1.el7.x86_64 #1 SMP Tue Aug 25 17:23:54 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</code></pre><h2 id="2-文件查看命令"><a href="#2-文件查看命令" class="headerlink" title="2.文件查看命令"></a>2.文件查看命令</h2><h3 id="2-1-查看目录结构"><a href="#2-1-查看目录结构" class="headerlink" title="2.1 查看目录结构"></a>2.1 查看目录结构</h3><pre><code class="lang-bash">➜  ~ tree -d -L 2 # tree命令可以查看目录文件结构信息，其中-d指示只显示目录，-L 2指示只显示下面两层.├── Data│   ├── Application│   ├── DockerImages│   ├── NLP│   └── Pylibs├── Downloads│   ├── neo4j-community-4.1.3│   ├── pylibs│   └── zip├── Projects│   ├── GithubProjects│   ├── kdProjects│   └── myProjects├── Resources├── Software│   ├── Docker│   ├── elasticsearch-7.7.1│   ├── miniconda3│   ├── neo4j-community-4.1.3│   └── Nodejs└── tmp</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：以下命令都是在CentOS上执行，在Ubuntu或其他发行版部分有所不同。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.iamlightsmile.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.iamlightsmile.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>创建带有ik分词器的Elasticsearch容器</title>
    <link href="https://www.iamlightsmile.com/articles/%E5%88%9B%E5%BB%BA%E5%B8%A6%E6%9C%89ik%E5%88%86%E8%AF%8D%E5%99%A8%E7%9A%84Elasticsearch%E5%AE%B9%E5%99%A8/"/>
    <id>https://www.iamlightsmile.com/articles/%E5%88%9B%E5%BB%BA%E5%B8%A6%E6%9C%89ik%E5%88%86%E8%AF%8D%E5%99%A8%E7%9A%84Elasticsearch%E5%AE%B9%E5%99%A8/</id>
    <published>2020-09-09T09:08:02.000Z</published>
    <updated>2020-09-09T09:52:04.317Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h2><p>自己目前在学习探索Docker技术，这里简单实践一下创建带有ik分词器的Elasticsearch容器，涉及Dockerfile和docker-compose的使用。</p><a id="more"></a><h2 id="1-创建容器"><a href="#1-创建容器" class="headerlink" title="1.创建容器"></a>1.创建容器</h2><h3 id="1-1-编写Dockerfile"><a href="#1-1-编写Dockerfile" class="headerlink" title="1.1 编写Dockerfile"></a>1.1 编写<code>Dockerfile</code></h3><p>新建<code>elasticsearch</code>目录并在其内创建Dockerfile文件</p><pre><code class="lang-bash">mkdir elasticsearch &amp;&amp; elasticsearchtouch Dockerfile</code></pre><p><code>Dockerfile</code>中内容如下：</p><pre><code class="lang-Dockerfile">FROM elasticsearch:7.7.1RUN yes | ./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.7.1/elasticsearch-analysis-ik-7.7.1.zip</code></pre><h3 id="1-2-编写docker-compose-yml"><a href="#1-2-编写docker-compose-yml" class="headerlink" title="1.2 编写docker-compose.yml"></a>1.2 编写<code>docker-compose.yml</code></h3><p>在<code>elasticsearch</code>文件夹同级目录下创建<code>docker-compose.yml</code>文件，内容为：</p><pre><code class="lang-yml">version: &#39;3&#39;services:    es-ik:        build: ./elasticsearch        image: elasticsearch-ik:7.7.1        container_name: es_ik        environment:             - discovery.type=single-node        ports:            - 9201:9200            - 9301:9300</code></pre><p>上面的端口映射到Host主机的9201和9301是因为系统上已经有Elasticsearch在运行了并且使用了默认的端口，这里需要再换一下端口。</p><h3 id="1-3-打包镜像"><a href="#1-3-打包镜像" class="headerlink" title="1.3 打包镜像"></a>1.3 打包镜像</h3><p>上面的目录结构如下：</p><pre><code class="lang-txt">.├── docker-compose.yml└── elasticsearch    ├── Dockerfile    ├── elasticsearch-analysis-ik-7.7.1.zip    └── test.es</code></pre><p>执行如下命令以构建镜像：</p><pre><code class="lang-bash">docker-compose build</code></pre><p>执行<code>docker images</code>可以看到镜像已经成功创建：</p><pre><code class="lang-bash">[root@localhost ~]# docker imagesREPOSITORY                                      TAG                 IMAGE ID            CREATED             SIZEelasticsearch-ik                                7.7.1               1812e4f405c5        3 hours ago         814 MB</code></pre><h2 id="2-测试容器"><a href="#2-测试容器" class="headerlink" title="2.测试容器"></a>2.测试容器</h2><h3 id="2-1-启动容器"><a href="#2-1-启动容器" class="headerlink" title="2.1 启动容器"></a>2.1 启动容器</h3><p>执行如下命令以启动容器：</p><pre><code class="lang-bash">docker-compose up</code></pre><h3 id="2-2-查看容器启动状态"><a href="#2-2-查看容器启动状态" class="headerlink" title="2.2 查看容器启动状态"></a>2.2 查看容器启动状态</h3><pre><code class="lang-bash">[root@localhost Docker]# lsdocker-compose.yml  elasticsearch[root@localhost Docker]# docker-compose psName               Command               State                       Ports                     -----------------------------------------------------------------------------------------------es_ik   /tini -- /usr/local/bin/do ...   Up      0.0.0.0:9201-&gt;9200/tcp, 0.0.0.0:9301-&gt;9300/tcp</code></pre><h3 id="2-3-测试elasticsearch服务"><a href="#2-3-测试elasticsearch服务" class="headerlink" title="2.3 测试elasticsearch服务"></a>2.3 测试elasticsearch服务</h3><p>这里我是用的是VSCode的<code>Elasticsearch for VSCode</code>插件，该插件允许我们编写<code>.es</code>文件向es执行查询请求。</p><p>如<code>test.es</code>内容如下：</p><pre><code class="lang-es">POST _analyze{    &quot;analyzer&quot;: &quot;ik_smart&quot;,    &quot;text&quot;: &quot;中华人民共和国&quot;}POST _analyze{    &quot;analyzer&quot;: &quot;ik_max_word&quot;,    &quot;text&quot;: &quot;中华人民共和国&quot;}</code></pre><p>如图：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/elasticsearch-ik.png" alt=""></p><p>请求结果如下：</p><pre><code class="lang-json">{    &quot;tokens&quot;: [        {            &quot;token&quot;: &quot;中华人民共和国&quot;,            &quot;start_offset&quot;: 0,            &quot;end_offset&quot;: 7,            &quot;type&quot;: &quot;CN_WORD&quot;,            &quot;position&quot;: 0        },        {            &quot;token&quot;: &quot;中华人民&quot;,            &quot;start_offset&quot;: 0,            &quot;end_offset&quot;: 4,            &quot;type&quot;: &quot;CN_WORD&quot;,            &quot;position&quot;: 1        },        {            &quot;token&quot;: &quot;中华&quot;,            &quot;start_offset&quot;: 0,            &quot;end_offset&quot;: 2,            &quot;type&quot;: &quot;CN_WORD&quot;,            &quot;position&quot;: 2        },        {            &quot;token&quot;: &quot;华人&quot;,            &quot;start_offset&quot;: 1,            &quot;end_offset&quot;: 3,            &quot;type&quot;: &quot;CN_WORD&quot;,            &quot;position&quot;: 3        },        {            &quot;token&quot;: &quot;人民共和国&quot;,            &quot;start_offset&quot;: 2,            &quot;end_offset&quot;: 7,            &quot;type&quot;: &quot;CN_WORD&quot;,            &quot;position&quot;: 4        },        {            &quot;token&quot;: &quot;人民&quot;,            &quot;start_offset&quot;: 2,            &quot;end_offset&quot;: 4,            &quot;type&quot;: &quot;CN_WORD&quot;,            &quot;position&quot;: 5        },        {            &quot;token&quot;: &quot;共和国&quot;,            &quot;start_offset&quot;: 4,            &quot;end_offset&quot;: 7,            &quot;type&quot;: &quot;CN_WORD&quot;,            &quot;position&quot;: 6        },        {            &quot;token&quot;: &quot;共和&quot;,            &quot;start_offset&quot;: 4,            &quot;end_offset&quot;: 6,            &quot;type&quot;: &quot;CN_WORD&quot;,            &quot;position&quot;: 7        },        {            &quot;token&quot;: &quot;国&quot;,            &quot;start_offset&quot;: 6,            &quot;end_offset&quot;: 7,            &quot;type&quot;: &quot;CN_CHAR&quot;,            &quot;position&quot;: 8        }    ]}</code></pre><h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3.参考"></a>3.参考</h2><ul><li><a href="https://www.runoob.com/docker/docker-compose.html" target="_blank" rel="noopener">Docker Compose | 菜鸟教程</a></li><li><a href="https://www.jianshu.com/p/2217cfed29d7" target="_blank" rel="noopener">Docker Compose 配置文件详解 - 简书</a></li><li><a href="https://www.jianshu.com/p/ea0a1b00334d" target="_blank" rel="noopener">基于docker的elasticsearch中文分词及同义词配置 - 简书</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0.前言&quot;&gt;&lt;/a&gt;0.前言&lt;/h2&gt;&lt;p&gt;自己目前在学习探索Docker技术，这里简单实践一下创建带有ik分词器的Elasticsearch容器，涉及Dockerfile和docker-compose的使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="https://www.iamlightsmile.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="Docker" scheme="https://www.iamlightsmile.com/tags/Docker/"/>
    
      <category term="Elasticsearch" scheme="https://www.iamlightsmile.com/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>深度学习代码常见流程</title>
    <link href="https://www.iamlightsmile.com/articles/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E5%B8%B8%E8%A7%81%E6%B5%81%E7%A8%8B/"/>
    <id>https://www.iamlightsmile.com/articles/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E5%B8%B8%E8%A7%81%E6%B5%81%E7%A8%8B/</id>
    <published>2020-09-08T01:18:47.000Z</published>
    <updated>2020-09-08T02:39:09.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-概览"><a href="#0-概览" class="headerlink" title="0.概览"></a>0.概览</h2><p>目前自己在深度学习这方面有一定的积累，一些代码流程都有一定的套路和相应的标准，这里自己简单梳理一下。</p><p>我们这里假设输入为已标注数据，输出为训练的模型，不考虑标注前数据处理部分已经代码上线部署环节。</p><p>大致的流程包括：</p><ul><li><strong>数据预处理</strong></li><li><strong>编写神经网络模型</strong></li><li><strong>编写数据加载部分代码</strong></li><li><strong>编写模型训练预测代码</strong></li></ul><a id="more"></a><h2 id="1-数据预处理"><a href="#1-数据预处理" class="headerlink" title="1.数据预处理"></a>1.数据预处理</h2><p>对标注数据进行处理，包括特征预处理、数据清洗等，将数据（可能是txt格式、Excel文件等）转化为程序可直接读取的常见的数据集类型（如csv）。如在csv文件中，每行是一个样本（sample），每列为该样本特征（feature）或标签（label）。</p><p>如<code>tes.csv</code>：</p><pre><code class="lang-csv">fuck,shit,label&quot;a&quot;,1.2,&quot;a&quot;&quot;b&quot;,2,&quot;b&quot;&quot;a&quot;,1.2,&quot;a&quot;&quot;b&quot;,2,&quot;b&quot;&quot;a&quot;,1.2,&quot;a&quot;&quot;b&quot;,2,&quot;b&quot;&quot;a&quot;,1.2,&quot;a&quot;&quot;b&quot;,2,&quot;b&quot;&quot;a&quot;,1.2,&quot;a&quot;&quot;b&quot;,2,&quot;b&quot;</code></pre><h2 id="2-编写神经网络模型"><a href="#2-编写神经网络模型" class="headerlink" title="2.编写神经网络模型"></a>2.编写神经网络模型</h2><p>对于特定的任务，我们可以选择既有的框架，这样就不需要重写模型。然而当既有的框架模型不满足我们的需求时，我们就需要去自定义去编写神经网络模型。</p><p>以Pytorch为例，模型需要继承自<code>torch.nn.Module</code>类并实现<code>forward</code>方法。</p><h2 id="3-编写数据加载部分代码"><a href="#3-编写数据加载部分代码" class="headerlink" title="3.编写数据加载部分代码"></a>3.编写数据加载部分代码</h2><p>数据预处理的结果为数据集文件，我们需要对其进行读取、分割并转化为向量格式。</p><p>以Pytorch为例，我们需要编写一个继承自<code>torch.utils.data.Dataset</code>类的类并实现其<code>__getitem__</code>方法和<code>__len__</code>方法。该类作为数据集抽象的接口向外部提供数据。</p><p><code>Dataset</code>类的输出一般不作为模型的输入，中间还需要一个<code>torch.utis.data.DataLoader</code>。</p><p><code>DataLoader</code>接收<code>dataset</code>、<code>batch_size</code>、<code>collate_fn</code>、<code>drop_last</code>、<code>shuffle</code>、<code>sampler</code>等参数，各参数含义为dataset:待加载数据集（类型为<code>torch.utils.data.Dataset</code>）、batch_size:批处理数量大小、collate_fn:数据收集函数（用于将一系列sample转化为Tensor）、drop_last:是否丢弃最后不满一个batch_size的batch、shuffle:是否对数据再进行一次shuffle、sampler:数据采样器（类型为<code>torch.utils.data.Sampler</code>），其中各参数之间可能相互冲突不能一起用，具体使用请参见Pytorch官网教程。</p><p><code>Dataloader</code>的输出应该被作为可以直接传递给模型的Tensor类型，以mini-batch，具体在Python代码中为<code>for-in</code>的形式被调用。</p><h2 id="4-编写模型训练预测代码"><a href="#4-编写模型训练预测代码" class="headerlink" title="4.编写模型训练预测代码"></a>4.编写模型训练预测代码</h2><p>在生成<code>Module</code>和<code>DataLoader</code>之后，我们还需要指定损失函数（如<code>torch.nn.functional.cross_entropy</code>（交叉熵损失函数））和优化器（如<code>torch.optim.Adam</code>）。</p><p>更高级的，我们还可以去设置学习率调度器(如<code>torch.optim.lr_scheduler.StepLR</code>)，设置EarlyStopping和断点重训等功能。</p><p>在模型训练完之后我们还需要将其持久化到硬盘中，可以选择保存整个模型对象或者只包含其参数信息。</p><p>上面的训练部分由于比较通用，各框架也可能会将其抽象为<code>Trainer</code>对象。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-概览&quot;&gt;&lt;a href=&quot;#0-概览&quot; class=&quot;headerlink&quot; title=&quot;0.概览&quot;&gt;&lt;/a&gt;0.概览&lt;/h2&gt;&lt;p&gt;目前自己在深度学习这方面有一定的积累，一些代码流程都有一定的套路和相应的标准，这里自己简单梳理一下。&lt;/p&gt;
&lt;p&gt;我们这里假设输入为已标注数据，输出为训练的模型，不考虑标注前数据处理部分已经代码上线部署环节。&lt;/p&gt;
&lt;p&gt;大致的流程包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据预处理&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;编写神经网络模型&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;编写数据加载部分代码&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;编写模型训练预测代码&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="深度学习" scheme="https://www.iamlightsmile.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="https://www.iamlightsmile.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>完整机器学习项目的工作流程（转）</title>
    <link href="https://www.iamlightsmile.com/articles/%E5%AE%8C%E6%95%B4%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%88%E8%BD%AC%EF%BC%89/"/>
    <id>https://www.iamlightsmile.com/articles/%E5%AE%8C%E6%95%B4%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%88%E8%BD%AC%EF%BC%89/</id>
    <published>2020-09-08T00:52:14.000Z</published>
    <updated>2020-09-08T02:41:07.127Z</updated>
    
    <content type="html"><![CDATA[<p>本文章转自<a href="https://zhuanlan.zhihu.com/p/28288050" target="_blank" rel="noopener">完整机器学习项目的工作流程 - 知乎</a>。</p><h2 id="1-抽象成数学问题"><a href="#1-抽象成数学问题" class="headerlink" title="1.抽象成数学问题"></a>1.抽象成数学问题</h2><p>明确问题是进行机器学习的第一步。机器学习的训练过程通常都是一件非常耗时的事情，胡乱尝试时间成本是非常高的。</p><p>这里的抽象成数学问题，指的我们明确我们可以获得什么样的数据，目标是一个分类还是回归或者是聚类的问题。即明确输入和输出以及任务类型。</p><a id="more"></a><h2 id="2-获取数据"><a href="#2-获取数据" class="headerlink" title="2.获取数据"></a>2.获取数据</h2><p>数据决定了机器学习结果的上限，而算法只是尽可能逼近这个上限。</p><p>数据要有代表性，否则必然会过拟合。</p><p>而且对于分类问题，数据偏斜不能过于严重，不同类别的数据数量不要有数个数量级的差距。</p><p>而且还要对数据的量级有一个评估，多少个样本，多少个特征，可以估算出其对内存的消耗程度，判断训练过程中内存是否能够放得下。如果放不下就得考虑改进算法或者使用一些降维的技巧了。如果数据量实在太大，那就要考虑分布式了。</p><h2 id="3-特征预处理与特征选择"><a href="#3-特征预处理与特征选择" class="headerlink" title="3.特征预处理与特征选择"></a>3.特征预处理与特征选择</h2><p>良好的数据要能够提取出良好的特征才能真正发挥效力。</p><p>特征预处理、数据清洗是很关键的步骤，往往能够使得算法的效果和性能得到显著提高。归一化、离散化、因子化、缺失值处理、去除共线性等，数据挖掘过程中很多时间就花在它们上面。这些工作简单可复制，收益稳定可预期，是机器学习的基础必备步骤。</p><p>筛选出显著特征、摒弃非显著特征，需要机器学习工程师反复理解业务。这对很多结果有决定性的影响。特征选择好了，非常简单的算法也能得出良好、稳定的结果。这需要运用特征有效性分析的相关技术，如相关系数、卡方检验、平均互信息、条件熵、后验概率、逻辑回归权重等方法。</p><h2 id="4-训练模型与调优"><a href="#4-训练模型与调优" class="headerlink" title="4.训练模型与调优"></a>4.训练模型与调优</h2><p>直到这一步才用到我们上面说的算法进行训练。现在很多算法都能够封装成黑盒供人使用。但是真正考验水平的是调整这些算法的（超）参数，使得结果变得更加优良。这需要我们对算法的原理有深入的理解。理解越深入，就越能发现问题的症结，提出良好的调优方案。</p><h2 id="5-模型诊断"><a href="#5-模型诊断" class="headerlink" title="5.模型诊断"></a>5.模型诊断</h2><p>如何确定模型调优的方向与思路呢？这就需要对模型进行诊断的技术。</p><p>过拟合、欠拟合 判断是模型诊断中至关重要的一步。常见的方法如交叉验证，绘制学习曲线等。过拟合的基本调优思路是增加数据量，降低模型复杂度。欠拟合的基本调优思路是提高特征数量和质量，增加模型复杂度。</p><p>误差分析 也是机器学习至关重要的步骤。通过观察误差样本，全面分析误差产生误差的原因:是参数的问题还是算法选择的问题，是特征的问题还是数据本身的问题……</p><p>诊断后的模型需要进行调优，调优后的新模型需要重新进行诊断，这是一个反复迭代不断逼近的过程，需要不断地尝试， 进而达到最优状态。</p><h2 id="6-模型融合"><a href="#6-模型融合" class="headerlink" title="6.模型融合"></a>6.模型融合</h2><p>一般来说，模型融合后都能使得效果有一定提升。而且效果很好。</p><p>工程上，主要提升算法准确度的方法是分别在模型的前端（特征清洗和预处理，不同的采样模式）与后端（模型融合）上下功夫。因为他们比较标准可复制，效果比较稳定。而直接调参的工作不会很多，毕竟大量数据训练起来太慢了，而且效果难以保证。</p><h2 id="7-上线运行"><a href="#7-上线运行" class="headerlink" title="7.上线运行"></a>7.上线运行</h2><p>这一部分内容主要跟工程实现的相关性比较大。工程上是结果导向，模型在线上运行的效果直接决定模型的成败。 不单纯包括其准确程度、误差等情况，还包括其运行的速度(时间复杂度)、资源消耗程度（空间复杂度）、稳定性是否可接受。</p><h2 id="8-最后"><a href="#8-最后" class="headerlink" title="8.最后"></a>8.最后</h2><p>这些工作流程主要是工程实践上总结出的一些经验。并不是每个项目都包含完整的一个流程。这里的部分只是一个指导性的说明，只有大家自己多实践，多积累项目经验，才会有自己更深刻的认识。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文章转自&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28288050&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;完整机器学习项目的工作流程 - 知乎&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;1-抽象成数学问题&quot;&gt;&lt;a href=&quot;#1-抽象成数学问题&quot; class=&quot;headerlink&quot; title=&quot;1.抽象成数学问题&quot;&gt;&lt;/a&gt;1.抽象成数学问题&lt;/h2&gt;&lt;p&gt;明确问题是进行机器学习的第一步。机器学习的训练过程通常都是一件非常耗时的事情，胡乱尝试时间成本是非常高的。&lt;/p&gt;
&lt;p&gt;这里的抽象成数学问题，指的我们明确我们可以获得什么样的数据，目标是一个分类还是回归或者是聚类的问题。即明确输入和输出以及任务类型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="深度学习" scheme="https://www.iamlightsmile.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://www.iamlightsmile.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>centos安装mongodb</title>
    <link href="https://www.iamlightsmile.com/articles/centos%E5%AE%89%E8%A3%85mongodb/"/>
    <id>https://www.iamlightsmile.com/articles/centos%E5%AE%89%E8%A3%85mongodb/</id>
    <published>2020-09-06T07:54:30.000Z</published>
    <updated>2020-09-15T06:45:17.271Z</updated>
    
    <content type="html"><![CDATA[<p>安装方式详情参见<a href="https://cloud.tencent.com/developer/article/1329170" target="_blank" rel="noopener">在CentOS 7上安装MongoDB - 云+社区 - 腾讯云</a>，只是貌似最新的版本是4.4，即需要将添加MongoDB源部分的3.2都换成4.4。</p><p>另外更精简的文档：<a href="https://www.jb51.net/article/194001.htm" target="_blank" rel="noopener">Centos7 yum安装mongodb实现步骤详解_MongoDB_脚本之家</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;安装方式详情参见&lt;a href=&quot;https://cloud.tencent.com/developer/article/1329170&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在CentOS 7上安装MongoDB - 云+社区 - 腾讯云&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.iamlightsmile.com/categories/Linux/"/>
    
    
      <category term="centos" scheme="https://www.iamlightsmile.com/tags/centos/"/>
    
      <category term="mongodb" scheme="https://www.iamlightsmile.com/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>配置VSCode-Remote-SSH</title>
    <link href="https://www.iamlightsmile.com/articles/%E9%85%8D%E7%BD%AEVSCode-Remote-SSH/"/>
    <id>https://www.iamlightsmile.com/articles/%E9%85%8D%E7%BD%AEVSCode-Remote-SSH/</id>
    <published>2020-09-05T08:15:15.000Z</published>
    <updated>2020-10-10T08:10:56.193Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h2><p>在写前一篇文档调研使用brat的时候，由于涉及到操作服务器中文件，然而直接通过命令行操作实在是有些不太方便，毕竟vim不咋熟练，自己突然想到使用vscode可以配置remote开发。于是趁此机会也尝试着配置一下，这里简单记录一下。</p><a id="more"></a><h2 id="1-配置VSCode-Remote-SSH"><a href="#1-配置VSCode-Remote-SSH" class="headerlink" title="1.配置VSCode Remote-SSH"></a>1.配置VSCode Remote-SSH</h2><h3 id="1-1-安装Remote-SSH插件"><a href="#1-1-安装Remote-SSH插件" class="headerlink" title="1.1 安装Remote-SSH插件"></a>1.1 安装Remote-SSH插件</h3><p>在拓展里搜索”remote”，然后安装”Remote-SSH”插件。</p><p>在安装完成之后，侧边栏会多出一个选项，如图：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/vscode_remote.png" alt=""></p><p>点击之后，其会从一些默认位置自动读取系统已有的一些ssh配置信息，如图：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/vscode_remote_2.png" alt=""></p><h2 id="2-配置远程服务器"><a href="#2-配置远程服务器" class="headerlink" title="2.配置远程服务器"></a>2.配置远程服务器</h2><h3 id="2-1-添加远程服务器配置信息"><a href="#2-1-添加远程服务器配置信息" class="headerlink" title="2.1 添加远程服务器配置信息"></a>2.1 添加远程服务器配置信息</h3><p>我们可以在<code>config</code>文件中继续添加配置，格式如图：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/vscode_remote_3.png" alt=""></p><h3 id="2-2-配置ssh连接"><a href="#2-2-配置ssh连接" class="headerlink" title="2.2 配置ssh连接"></a>2.2 配置ssh连接</h3><p><strong>注意</strong>：以下命令均是在Git Bash下执行的。</p><h4 id="2-2-1-切换目录至ssh目录"><a href="#2-2-1-切换目录至ssh目录" class="headerlink" title="2.2.1 切换目录至ssh目录"></a>2.2.1 切换目录至ssh目录</h4><pre><code class="lang-bash">cd ~/.ssh</code></pre><h4 id="2-2-2-生成ssh公钥"><a href="#2-2-2-生成ssh公钥" class="headerlink" title="2.2.2 生成ssh公钥"></a>2.2.2 生成ssh公钥</h4><pre><code class="lang-bash">ssh-keygen</code></pre><h4 id="2-2-3-将公钥存储至远程主机"><a href="#2-2-3-将公钥存储至远程主机" class="headerlink" title="2.2.3 将公钥存储至远程主机"></a>2.2.3 将公钥存储至远程主机</h4><p>假如1.3.2步生成的公钥名称为<code>id_rsa.pub</code>，假设远程主机ip地址为<code>12.34.56.78</code>，用户名为<code>root</code></p><pre><code class="lang-bash">ssh-copy-id -i id_rsa.pub root@12.34.56.78</code></pre><h2 id="3-连接至远程服务器"><a href="#3-连接至远程服务器" class="headerlink" title="3.连接至远程服务器"></a>3.连接至远程服务器</h2><p>在上述过程配置完成之后，便可以连接至远程服务器了。如图点击红圈内的图标：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/vscode_remote_5.png" alt=""></p><p>连接成功后如图所示：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/vscode_remote_6.png" alt=""></p><p>如果还不明白的可以继续看下面的参考文章。</p><h2 id="1-参考"><a href="#1-参考" class="headerlink" title="-1.参考"></a>-1.参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/64849549" target="_blank" rel="noopener">VSCode Remote 体验 | 远程Linux环境开发真香 - 知乎</a></li><li><a href="https://www.jianshu.com/p/6761199bedba" target="_blank" rel="noopener">服务器免密登录:ssh公钥配置 - 简书</a></li><li><a href="https://www.jianshu.com/p/1e793e386beb" target="_blank" rel="noopener">ssh配置文件详解 - 简书</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0.前言&quot;&gt;&lt;/a&gt;0.前言&lt;/h2&gt;&lt;p&gt;在写前一篇文档调研使用brat的时候，由于涉及到操作服务器中文件，然而直接通过命令行操作实在是有些不太方便，毕竟vim不咋熟练，自己突然想到使用vscode可以配置remote开发。于是趁此机会也尝试着配置一下，这里简单记录一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="https://www.iamlightsmile.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="vscode" scheme="https://www.iamlightsmile.com/tags/vscode/"/>
    
      <category term="ssh" scheme="https://www.iamlightsmile.com/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>centos下brat安装使用</title>
    <link href="https://www.iamlightsmile.com/articles/centos%E4%B8%8Bbrat%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.iamlightsmile.com/articles/centos%E4%B8%8Bbrat%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</id>
    <published>2020-09-05T02:09:50.000Z</published>
    <updated>2020-09-07T00:40:01.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-更新"><a href="#1-更新" class="headerlink" title="-1.更新"></a>-1.更新</h2><p>发现现在brat直接Python3就可以使用，只是brat官网上和Github上最新release版本还停留在2012年，然而brat近几年有所更新，所以我们可以直接clone Github上的brat的最新源码进行使用hhh。</p><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h2><h3 id="0-1-背景"><a href="#0-1-背景" class="headerlink" title="0.1 背景"></a>0.1 背景</h3><p>近日简单调研一下NLP标注工具brat的使用，其<a href="http://brat.nlplab.org/examples.html" target="_blank" rel="noopener">官网示例</a>中可以标注的任务包括命名实体识别、事件抽取、指代消解、依存句法、成分句法等等。</p><a id="more"></a><h3 id="0-2-brat介绍"><a href="#0-2-brat介绍" class="headerlink" title="0.2 brat介绍"></a>0.2 brat介绍</h3><p>brat是使用Python2开发的文本标注工具，只支持在Unix-like环境下使用，同时最新版v1.3提供两种使用方式，即：using CGI和standalone server，第一种方式官方推荐使用Apache2服务器，并提供了简单的配置教程；第二种模式更新，但可能有更多潜在的问题。另外其实也可以通过Docker使用，这种方法相对而言更加方便。</p><h3 id="0-3-个人使用方式"><a href="#0-3-个人使用方式" class="headerlink" title="0.3 个人使用方式"></a>0.3 个人使用方式</h3><p>我个人使用的是第一种方式，关键是我自己试了试第二种，没有成功，所以只能拿第一种搞了。网上的教程既有将brat当server端用的，也有简单的在localhost环境下使用的。由于自己的笔记本系统是Win10，所以选择在腾讯云服务器Cnetos7上搭建brat。</p><h2 id="1-brat相关信息"><a href="#1-brat相关信息" class="headerlink" title="1.brat相关信息"></a>1.brat相关信息</h2><h3 id="1-1-brat相关网址"><a href="#1-1-brat相关网址" class="headerlink" title="1.1 brat相关网址"></a>1.1 brat相关网址</h3><ul><li>brat官网：<a href="http://brat.nlplab.org/" target="_blank" rel="noopener">brat rapid annotation tool</a></li><li>brat安装说明：<a href="http://brat.nlplab.org/installation.html" target="_blank" rel="noopener">Installation - brat rapid annotation tool</a></li><li>brat手册网址：<a href="http://brat.nlplab.org/manual.html" target="_blank" rel="noopener">Manual - brat rapid annotation tool</a></li><li>brat github地址：<a href="https://github.com/nlplab/brat" target="_blank" rel="noopener">nlplab/brat: brat rapid annotation tool (brat) - for all your textual annotation needs</a></li></ul><h2 id="2-brat安装"><a href="#2-brat安装" class="headerlink" title="2.brat安装"></a>2.brat安装</h2><p><strong>说明</strong>：以下命令在root用户下运行，如普通用户请自行在部分命令前面加<code>sudo</code>。</p><h3 id="2-1-安装Apache"><a href="#2-1-安装Apache" class="headerlink" title="2.1 安装Apache"></a>2.1 安装Apache</h3><p>由于brat需要借助Apache提供cgi访问，所以我们首先需要安装apache。</p><p>安装命令如下：</p><pre><code class="lang-bash">yum install httpd</code></pre><p>启动Apache</p><pre><code class="lang-bash">systemctl start httpd.service</code></pre><p>Apache的默认配置：</p><ul><li>Apache默认将网站的根目录指向/<code>var/www/html</code></li><li>默认的主配置文件<code>/etc/httpd/conf/httpd.conf</code></li><li>配置存储在的<code>/etc/httpd/conf.d/</code>目录</li></ul><p>更多关于CentOS下安装Apache请参考<a href="https://www.jianshu.com/p/5b8903709e66" target="_blank" rel="noopener">CentOS 7下Apache的安装 - 简书</a></p><h3 id="2-2-初步配置Apache（视情况可略过）"><a href="#2-2-初步配置Apache（视情况可略过）" class="headerlink" title="2.2 初步配置Apache（视情况可略过）"></a>2.2 初步配置Apache（视情况可略过）</h3><p>由于自己的服务器上已经安装了Nginx，而Apache和Nginx都默认关联80端口，所以这里需要做一些调整，例如将Apache的监听端口设置为8080。而由于自己的frp程序已经关联了8080端口，所以自己这里将Apache的监听端口设置为8088。</p><p>具体配置请参考：<a href="https://blog.csdn.net/weixin_42912498/article/details/106626219" target="_blank" rel="noopener">CentOS下nginx与apache如何共存_weixin_42912498的博客-CSDN博客</a></p><h3 id="2-3-下载brat"><a href="#2-3-下载brat" class="headerlink" title="2.3 下载brat"></a>2.3 下载brat</h3><p>我们可以通过<a href="http://brat.nlplab.org/index.html" target="_blank" rel="noopener">官网</a>下载brat，也可以通过<a href="https://github.com/nlplab/brat/releases" target="_blank" rel="noopener">Github</a>下载brat。</p><p>在下载完成后，我们需要将brat移动至<code>var/www/html</code>目录，并解压重命名目录为<code>brat</code>。</p><p>由于brat目录内的所有内容要被外网用户通过Apache访问到，所以我们需要配置brat目录的权限，具体命令为：</p><pre><code class="lang-bash">chmod 777 -R /var/www/html/brat</code></pre><h3 id="2-4-配置Apache"><a href="#2-4-配置Apache" class="headerlink" title="2.4 配置Apache"></a>2.4 配置Apache</h3><p>编辑<code>/etc/httpd/conf/httpd.conf</code>文件。</p><h4 id="2-4-1-添加brat配置"><a href="#2-4-1-添加brat配置" class="headerlink" title="2.4.1 添加brat配置"></a>2.4.1 添加brat配置</h4><p>在<code>&lt;Directory &quot;/var/www/html&quot;&gt;...&lt;/Directory&gt;</code>配置后添加如下内容：</p><pre><code class="lang-conf"># add brat&lt;Directory &quot;/var/www/html/brat&quot;&gt;    AllowOverride Options Indexes FileInfo Limit    Require all granted    AddType application/xhtml+xml .xhtml    AddType font/ttf .ttf    Options +ExecCGI    AddHandler cgi-script .cgi&lt;/Directory&gt;</code></pre><p>如图：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/apache_brat_1.png" alt=""></p><h4 id="2-4-2-添加cgi配置"><a href="#2-4-2-添加cgi配置" class="headerlink" title="2.4.2 添加cgi配置"></a>2.4.2 添加cgi配置</h4><p>在第55行内容大约为<code># Example:# LoadModule foo_module modules/mod_foo.so</code>后面补充：</p><pre><code class="lang-conf">LoadModule cgi_module modules/mod_cgi.soLoadModule cgid_module modules/mod_cgid.so</code></pre><p>如图：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/apache_brat_2.png" alt=""></p><h4 id="2-4-3-重启Apache"><a href="#2-4-3-重启Apache" class="headerlink" title="2.4.3 重启Apache"></a>2.4.3 重启Apache</h4><pre><code class="lang-bash">systemctl restart httpd.service</code></pre><h3 id="2-5-查看配置结果"><a href="#2-5-查看配置结果" class="headerlink" title="2.5 查看配置结果"></a>2.5 查看配置结果</h3><p>在浏览器输入相应网址如图（以我个人网址为例）：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/apache_test.png" alt=""></p><p>便说明Apache服务配置成功了。</p><p>在浏览器输入<code>http://lightsmile.cn:8088/brat</code>（以我个人网址为例）得到如下结果，便说明brat已经配置成功：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/apache_brat_3.png" alt=""></p><h2 id="3-brat使用"><a href="#3-brat使用" class="headerlink" title="3.brat使用"></a>3.brat使用</h2><h3 id="3-1-一些相关文章"><a href="#3-1-一些相关文章" class="headerlink" title="3.1 一些相关文章"></a>3.1 一些相关文章</h3><ul><li><a href="https://wetest.qq.com/lab/view/31.html" target="_blank" rel="noopener">你爱我吗？企鹅风讯利用BRAT进行中文情感分析语料标注掌握玩家心 - 腾讯WeTest</a></li><li><a href="https://www.cnblogs.com/xiaoqi/p/brat-config.html" target="_blank" rel="noopener">NLP标注工具brat 配置文件说明 - JadePeng - 博客园</a></li><li><a href="https://blog.csdn.net/anyedianxia/article/details/96832229" target="_blank" rel="noopener">Zhong__CentOS7安装配置Brat(初级)_Zhong的博客-CSDN博客</a></li><li><a href="https://www.codenong.com/cs106623370/" target="_blank" rel="noopener">BRAT的安装、配置、标注操作 | 码农家园</a></li></ul><h3 id="3-2-配置brat中文环境"><a href="#3-2-配置brat中文环境" class="headerlink" title="3.2 配置brat中文环境"></a>3.2 配置brat中文环境</h3><p>如前所述，brat目录为<code>/var/www/html/brat</code>，我们需要更改<code>/var/www/html/brat/server/src/projectconfig.py</code>中的第162行，具体为：</p><pre><code class="lang-python">n  = re.sub(r&#39;[^a-zA-Z\u4e00-\u9fa5&lt;&gt;,0-9_-]&#39;, &#39;_&#39;, n)</code></pre><p>如图：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/brat_project_config.png" alt=""></p><h3 id="3-3-待标记语料配置"><a href="#3-3-待标记语料配置" class="headerlink" title="3.3 待标记语料配置"></a>3.3 待标记语料配置</h3><h4 id="3-3-1-放置带标记语料"><a href="#3-3-1-放置带标记语料" class="headerlink" title="3.3.1 放置带标记语料"></a>3.3.1 放置带标记语料</h4><p>将待标注的语料（txt）格式放入到brat的<code>data</code>目录中。</p><p>如：</p><pre><code class="lang-bash">(base) ➜  brat cd data(base) ➜  data lsexamples  tests  tutorials(base) ➜  data ls testsannotation.conf  fuck.ann  fuck.txt  tools.conf</code></pre><p>其中的<code>fuck.txt</code>就是待标记的纯文本语料，内容为：</p><pre><code class="lang-txt">曾经沧海难为水，除却巫山不是云。何当共剪西窗烛，却话巴山夜雨时。毛泽东出生于湖南。</code></pre><h4 id="3-3-2-创建ann文件"><a href="#3-3-2-创建ann文件" class="headerlink" title="3.3.2 创建ann文件"></a>3.3.2 创建ann文件</h4><p>对于所有的待标记语料，brat要求必须有同名的ann文件（brat会将标注结果存放在该文件中，而brat不会自动创建，需要用户手动创建）。</p><p>我们可以在brat目录下执行如下命令来批量创建ann文件。</p><pre><code class="lang-shell">find data -name &#39;*.txt&#39; | sed -e &#39;s|\.txt|.ann|g&#39; | xargs touch</code></pre><h4 id="3-3-3-配置标注信息"><a href="#3-3-3-配置标注信息" class="headerlink" title="3.3.3 配置标注信息"></a>3.3.3 配置标注信息</h4><p>我们可以在txt和ann同级目录中增加conf文件来对标注项目进行配置，具体详情参考上面提到的brat配置文件说明。</p><p>比如说上面的和<code>fuck.txt</code>同级的<code>annotation.conf</code>文件中的内容为：</p><pre><code class="lang-conf">[spans]PlacePerson[relations]Place-in Arg1:Person, Arg2:Place[events][attributes]</code></pre><p>同时也可以在<code>tools.conf</code>文件中设置记录标注过程日志，如：</p><pre><code class="lang-conf">[options]Annotation-log logfile:./log_history.log</code></pre><h3 id="3-4-对语料进行标注"><a href="#3-4-对语料进行标注" class="headerlink" title="3.4 对语料进行标注"></a>3.4 对语料进行标注</h3><p>具体标注过程略，标注界面如图：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/brat_chrome.png" alt=""></p><h3 id="3-5-查看并导出标注结果"><a href="#3-5-查看并导出标注结果" class="headerlink" title="3.5 查看并导出标注结果"></a>3.5 查看并导出标注结果</h3><p>我们可以点击data菜单项来查看标注结果，如图：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/brat_result_1.png" alt=""></p><p>点击<code>ann</code>即可打开新的页面，查看当前ann格式的标注结果，如图：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/brat_result_2.png" alt=""></p><p>此内容和与<code>fuck.txt</code>同目录的<code>fuck.ann</code>内容一致。</p><p>点击<code>Download tar.gz</code>按钮则可以将当前标注结果下载下来。</p><h2 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4.注意事项"></a>4.注意事项</h2><h3 id="4-1-无法加载标注文件"><a href="#4-1-无法加载标注文件" class="headerlink" title="4.1 无法加载标注文件"></a>4.1 无法加载标注文件</h3><p>可能是由于文件权限原因，当放置新的标注文件到data目录中时，仍然需要改变文件的访问权限。具体来说，我们可以通过如下命令来执行：</p><pre><code class="lang-bash">chmod 777 -R /var/www/html/brat</code></pre><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5.参考"></a>5.参考</h2><ul><li><a href="https://www.jianshu.com/p/5b8903709e66" target="_blank" rel="noopener">CentOS 7下Apache的安装 - 简书</a></li><li><a href="https://blog.csdn.net/weixin_42912498/article/details/106626219" target="_blank" rel="noopener">CentOS下nginx与apache如何共存_weixin_42912498的博客-CSDN博客</a></li><li><a href="https://www.jianshu.com/p/c36dd3946e74" target="_blank" rel="noopener">Apache配置文件httpd.conf详解 - 简书</a></li><li><a href="https://cloud.tencent.com/developer/article/1499644" target="_blank" rel="noopener">文本标注工具brat简介 - 云+社区 - 腾讯云</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-更新&quot;&gt;&lt;a href=&quot;#1-更新&quot; class=&quot;headerlink&quot; title=&quot;-1.更新&quot;&gt;&lt;/a&gt;-1.更新&lt;/h2&gt;&lt;p&gt;发现现在brat直接Python3就可以使用，只是brat官网上和Github上最新release版本还停留在2012年，然而brat近几年有所更新，所以我们可以直接clone Github上的brat的最新源码进行使用hhh。&lt;/p&gt;
&lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0.前言&quot;&gt;&lt;/a&gt;0.前言&lt;/h2&gt;&lt;h3 id=&quot;0-1-背景&quot;&gt;&lt;a href=&quot;#0-1-背景&quot; class=&quot;headerlink&quot; title=&quot;0.1 背景&quot;&gt;&lt;/a&gt;0.1 背景&lt;/h3&gt;&lt;p&gt;近日简单调研一下NLP标注工具brat的使用，其&lt;a href=&quot;http://brat.nlplab.org/examples.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网示例&lt;/a&gt;中可以标注的任务包括命名实体识别、事件抽取、指代消解、依存句法、成分句法等等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="NLP" scheme="https://www.iamlightsmile.com/categories/NLP/"/>
    
    
      <category term="NLP" scheme="https://www.iamlightsmile.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>damedane视频制作教程</title>
    <link href="https://www.iamlightsmile.com/articles/damedane%E8%A7%86%E9%A2%91%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B/"/>
    <id>https://www.iamlightsmile.com/articles/damedane%E8%A7%86%E9%A2%91%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B/</id>
    <published>2020-08-30T02:43:21.000Z</published>
    <updated>2020-09-06T07:57:52.108Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h2><p>近日在B站上接触到了一些换脸演唱的视频，觉得还有点意思，发现不少视频都是没几个粉的用户上传的，这让我意识到或许制作这个的门槛并不高，后来偶然间看到了相关教程，于是乎自己也尝试着搞了搞。</p><a id="more"></a><h2 id="1-参考视频"><a href="#1-参考视频" class="headerlink" title="1.参考视频"></a>1.参考视频</h2><ol><li><a href="https://www.bilibili.com/video/BV1HV411U7zm" target="_blank" rel="noopener">最详细简洁的方法教你如何轻松做damedane梗！_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></li><li><a href="https://www.bilibili.com/video/BV1ni4y1g7xs?p=2&amp;t=14" target="_blank" rel="noopener">教你轻松做出damedane梗图，会不会翻墙都可以！_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></li></ol><h2 id="2-使用方案"><a href="#2-使用方案" class="headerlink" title="2.使用方案"></a>2.使用方案</h2><p>如下图：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/img/demedane视频制作方案.png" alt=""></p><p>对于程序猿来说，自然是选择方法一了。</p><h2 id="3-使用教程"><a href="#3-使用教程" class="headerlink" title="3.使用教程"></a>3.使用教程</h2><h3 id="3-1-拷贝脚本到colab中"><a href="#3-1-拷贝脚本到colab中" class="headerlink" title="3.1 拷贝脚本到colab中"></a>3.1 拷贝脚本到colab中</h3><p>脚本链接为：<a href="https://colab.research.google.com/github/AliaksandrSiarohin/first-order-model/blob/master/demo.ipynb" target="_blank" rel="noopener">first-order-model-demo.ipynb - Colaboratory</a>。</p><p>该脚本中包含代码运行逻辑所有流程。</p><p>我们可以选择直接编辑拷贝的ipynb文件，或者自己再新建一个ipynb文件，这里我选择的是新创建文件<code>train_image.ipynb</code>。</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/img/new_ipynb.png" alt=""></p><h3 id="3-2-上传资源文件"><a href="#3-2-上传资源文件" class="headerlink" title="3.2 上传资源文件"></a>3.2 上传资源文件</h3><p>将想要制作的源图片和源视频上传到Google Drive中，这里需要注意的是上传的最好是256*256的png格式的图片（如果不是的话，可以先使用图片编辑工具将图片转换成相应的格式）</p><p>如图我这里将图片放到了Images目录：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/img/drive_my_images.png" alt=""></p><p>将视频放到了Videos目录：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/img/drive_my_videos.png" alt=""></p><h3 id="3-3-拷贝模型文件"><a href="#3-3-拷贝模型文件" class="headerlink" title="3.3 拷贝模型文件"></a>3.3 拷贝模型文件</h3><p>我们还需要将<a href="https://drive.google.com/drive/folders/1kZ1gCnpfU0BnpdU47pLM_TQ6RypDDqgw?usp=sharing" target="_blank" rel="noopener">模型文件</a>拷贝到Google Drive中。只需要拷贝两个<code>tar</code>文件就好，如图，放到相应的目录（自己随意，后续代码中对应上即可）：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/img/20200830114204.png" alt=""></p><h3 id="3-4-启动环境并执行脚本"><a href="#3-4-启动环境并执行脚本" class="headerlink" title="3.4 启动环境并执行脚本"></a>3.4 启动环境并执行脚本</h3><p>打开之前创建的<code>train_image.ipynb</code>文件，然后系统便会分配RAM和磁盘供程序运行，由于Colab默认不会为环境配置GPU或者TPU，所以我们这里需要手动设置一下。</p><p>如下图：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/img/20200830111953.png" alt=""></p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/img/20200830112037.png" alt=""></p><h4 id="step1：-克隆仓库到colab"><a href="#step1：-克隆仓库到colab" class="headerlink" title="step1： 克隆仓库到colab"></a>step1： 克隆仓库到colab</h4><p>依次输入并执行以下指令</p><pre><code class="lang-bash">!git clone https://github.com/AliaksandrSiarohin/first-order-model</code></pre><pre><code class="lang-bash">cd first-order-model</code></pre><p>如图：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/img/20200830115609.png" alt=""></p><h4 id="step2-查看GPU信息"><a href="#step2-查看GPU信息" class="headerlink" title="step2: 查看GPU信息"></a>step2: 查看GPU信息</h4><pre><code class="lang-bash">!nvidia-smi</code></pre><p>如图：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/img/20200830112835.png" alt=""></p><h4 id="step3-挂载Google-drive到Colab"><a href="#step3-挂载Google-drive到Colab" class="headerlink" title="step3: 挂载Google drive到Colab"></a>step3: 挂载Google drive到Colab</h4><pre><code class="lang-python">from google.colab import drivedrive.mount(&#39;/content/gdrive&#39;)</code></pre><p>如图：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/img/20200830115734.png" alt=""></p><p>其中会涉及到使用Google账户授权，只要点击确认并复制相应的验证码到指定位置处运行即可。</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/img/20200830115305.png" alt=""></p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/img/20200830115646.png" alt=""></p><h4 id="step4-加载驱动视频和源图像"><a href="#step4-加载驱动视频和源图像" class="headerlink" title="step4: 加载驱动视频和源图像"></a>step4: 加载驱动视频和源图像</h4><pre><code class="lang-python">import imageioimport numpy as npimport matplotlib.pyplot as pltimport matplotlib.animation as animationfrom skimage.transform import resizefrom IPython.display import HTMLimport warningswarnings.filterwarnings(&quot;ignore&quot;)source_image = imageio.imread(&#39;/content/gdrive/My Drive/Images/xiao_ke.png&#39;)driving_video = imageio.mimread(&#39;/content/gdrive/My Drive/Videos/bakamitai_template.mp4&#39;)#Resize image and video to 256x256source_image = resize(source_image, (256, 256))[..., :3]driving_video = [resize(frame, (256, 256))[..., :3] for frame in driving_video]def display(source, driving, generated=None):    fig = plt.figure(figsize=(8 + 4 * (generated is not None), 6))    ims = []    for i in range(len(driving)):        cols = [source]        cols.append(driving[i])        if generated is not None:            cols.append(generated[i])        im = plt.imshow(np.concatenate(cols, axis=1), animated=True)        plt.axis(&#39;off&#39;)        ims.append([im])    ani = animation.ArtistAnimation(fig, ims, interval=50, repeat_delay=1000)    plt.close()    return ani# HTML(display(source_image, driving_video).to_html5_video())</code></pre><p>上面的<code>source_image</code>和<code>driving_video</code>的路径根据自己的情况进行设置。</p><p>另外我们可以看到上面脚本是有一个将图像和视频都变为256*256的操作，这里我们为了更好的效果可以提前将图片剪辑为相应的格式。</p><p>之后的<code>display</code>方法是定义了通过matplotlib库将图片和视频展示的方法，这里的效果大致如：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/img/20200830113436.png" alt=""></p><h4 id="step5-创建并加载模型"><a href="#step5-创建并加载模型" class="headerlink" title="step5: 创建并加载模型"></a>step5: 创建并加载模型</h4><pre><code class="lang-python">from demo import load_checkpointsgenerator, kp_detector = load_checkpoints(config_path=&#39;config/vox-256.yaml&#39;,                             checkpoint_path=&#39;/content/gdrive/My Drive/first-order-motion-model/vox-cpk.pth.tar&#39;)</code></pre><p>最开始切换路径的目的就在于能够直接引用到<code>demo</code>的<code>load_checkpoints</code>函数并且对应到配置文件<code>config/vox-256.yaml</code>。</p><h4 id="step6-执行动画生成"><a href="#step6-执行动画生成" class="headerlink" title="step6: 执行动画生成"></a>step6: 执行动画生成</h4><p>到这里终于到了我们最想看到的环节。</p><pre><code class="lang-python">from demo import make_animationfrom skimage import img_as_ubytepredictions = make_animation(source_image, driving_video, generator, kp_detector, relative=True)#save resulting videoimageio.mimsave(&#39;../generated.mp4&#39;, [img_as_ubyte(frame) for frame in predictions])#video can be downloaded from /content folderHTML(display(source_image, driving_video, predictions).to_html5_video())</code></pre><p>如图：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/img/20200830115112.png" alt=""></p><p>根据相对路径关系<code>../generated.mp4</code>我们也可以发现生成的视频文件就在当前环境下,即：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/img/20200830120220.png" alt=""></p><p>将生成的mp4下载到本地即可。</p><h2 id="4-视频后期处理"><a href="#4-视频后期处理" class="headerlink" title="4.视频后期处理"></a>4.视频后期处理</h2><p>我们下载得到的<code>generated.mp4</code>并不能直接使用，时长不仅增加了3倍，并且也没有了声音。所以只能通过后期视频编辑再将视频调整为正常倍速并添加源视频音轨，实现正常的转换效果。</p><p>关于从mp4中提取音频，我这里用了arctime软件，该软件主要是配字幕的，自己之前使用过（本来以为有视频添加音频的功能，结果没有，这里只提了声音）由于自己的电脑比较渣，所以这里使用了B站提供的云剪辑功能，对视频进行了加工处理。</p><p>如图：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/img/20200830121208.png" alt=""></p><p>最终效果：<a href="https://www.bilibili.com/video/BV17t4y1S7CQ" target="_blank" rel="noopener">女装maybe激情献唱_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0.前言&quot;&gt;&lt;/a&gt;0.前言&lt;/h2&gt;&lt;p&gt;近日在B站上接触到了一些换脸演唱的视频，觉得还有点意思，发现不少视频都是没几个粉的用户上传的，这让我意识到或许制作这个的门槛并不高，后来偶然间看到了相关教程，于是乎自己也尝试着搞了搞。&lt;/p&gt;
    
    </summary>
    
    
      <category term="其他" scheme="https://www.iamlightsmile.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="damedane" scheme="https://www.iamlightsmile.com/tags/damedane/"/>
    
  </entry>
  
</feed>
