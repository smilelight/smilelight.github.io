<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lightsmile&#39;s Blog</title>
  
  <subtitle>lightsmile</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.iamlightsmile.com/"/>
  <updated>2020-11-13T04:29:31.243Z</updated>
  <id>https://www.iamlightsmile.com/</id>
  
  <author>
    <name>lightsmile</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>标准答案</title>
    <link href="https://www.iamlightsmile.com/articles/%E6%A0%87%E5%87%86%E7%AD%94%E6%A1%88/"/>
    <id>https://www.iamlightsmile.com/articles/%E6%A0%87%E5%87%86%E7%AD%94%E6%A1%88/</id>
    <published>2020-11-13T03:23:31.000Z</published>
    <updated>2020-11-13T04:29:31.243Z</updated>
    
    <content type="html"><![CDATA[<p>自始至终，一直都觉得现在许多教程都有些问题。看个教材或者文章，一般的思路总是先讲基础历史，然后引出基本概念，然后介绍相关内容，以及高级用法等。这样做很标准规范，但是正如上学时期的参考答案或者标准答案，正确但不够有趣。</p><a id="more"></a><p>我的初中数学老师讲课方式很独特：不让学生们提前预习教材。别的科目或者别的数学老师都要求学生们提前预习课程，等老师讲的时候就比较顺畅，哪里搞不清楚就问哪里，老师也轻松。</p><p>但是我的数学老师则非常反对这样的形式，她认为这种方式下学生们的认识就会先入为主，只能做到“只知其然，而不知其所以然”，即仿佛这种东西或概念原本就存在，这个事物应该就是这个样子也必然就是这个样子，而它的发明者只是海边捡贝壳的小男孩，碰巧发现而已。</p><p>我的数学老师就喜欢在课堂上一点一点把这个概念引出来，即没有它是什么样、我们可能去尝试哪些思路，中间如何探索，然后最终在循循善诱下老师要讲的新概念、新方法也就呼之欲出了。换句话说，老师会用一种通俗易懂的方式带领我们再走一遍前人探索的道路，这是一条打破常规、创造新事物的道路。</p><p>她极力认为应该让学生们学到如何学习、探索新知的能力和方法，要有不迷信权威、勇于探索另辟蹊径的理念，即授之于渔而非授之于鱼。比如说，她有时会在一节课堂上只讲一道题，但是她会讲多种方法，但更多的情况是她希望这些不同的方法都是同学们自己想出来的，即老师抛出问题，然后不同的同学举手回答，最开始的同学的解题思路可能是最基础常规的，然后老师便欢迎其他的人有不同的思路，直到没有更多不同的方法为止，在这个过程中我们不断地练习着从多个角度看待问题、解决问题。</p><p>举个例子：当时学概率的时候，老师问两枚硬币独立投掷的正反面情况，当时一个同学认为两正：两反：一正一反的比例为1:1:2，而我则想当然的认为就三种情况（脑子里也没有多少等概率啥的概念）是1:1:1，于是我们就在讲台上做起了实验，一直抛到比例挺接近1:1:2而我则不得不懵逼的服气为止。而这个过程，如果是预习了课本教材是不会有那种深刻的体会的。</p><p>我一直都非常感激我的这位数学老师，在初高中阶段也很喜欢数学，也非常享受用新的方法解出题目的成就感，甚至于会偏科到其他课上想数学题，没事了就总结些等式规律，一上数学课就兴奋激动跟打了鸡血似的，一上理综课就无聊难受地要死。由于那个时候并没有搞奥赛的班子或者氛围，自己也没有走上相关的道路。</p><p>这种老师我是真心觉得可遇不可求。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自始至终，一直都觉得现在许多教程都有些问题。看个教材或者文章，一般的思路总是先讲基础历史，然后引出基本概念，然后介绍相关内容，以及高级用法等。这样做很标准规范，但是正如上学时期的参考答案或者标准答案，正确但不够有趣。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>给docker-neo4j增加healthcheck</title>
    <link href="https://www.iamlightsmile.com/articles/%E7%BB%99docker-neo4j%E5%A2%9E%E5%8A%A0healthcheck/"/>
    <id>https://www.iamlightsmile.com/articles/%E7%BB%99docker-neo4j%E5%A2%9E%E5%8A%A0healthcheck/</id>
    <published>2020-11-13T01:29:28.000Z</published>
    <updated>2020-11-13T01:52:52.811Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-正确的打开方式"><a href="#1-正确的打开方式" class="headerlink" title="1.正确的打开方式"></a>1.正确的打开方式</h2><p>由于healthcheck执行的指令是在容器内部执行的，而docker-neo4j内部并没有curl指令，所以我们不能通过<code>curl -f localhost:7474 || exit 1</code>这样的指令来去判断neo4j容器是否运行正常，这样得到的结果总是unhealthy。</p><a id="more"></a><p>正确的打开方式应该是：</p><pre><code class="lang-yml">healthcheck:    test: [&quot;CMD-SHELL&quot;, &quot;echo &#39;match (n) return count(n);&#39; | bin/cypher-shell -a bolt://localhost:7687 -u neo4j -p xxx || exit 1&quot;]</code></pre><p>对于选择授权的neo4j容器而言，需要指定上面的用户名和密码。</p><h2 id="2-参考"><a href="#2-参考" class="headerlink" title="2.参考"></a>2.参考</h2><ul><li><a href="https://medium.com/better-programming/docker-healthchecks-eb744bfe3f3b" target="_blank" rel="noopener">How to Implement Docker Health Checks | by Nassos Michas | Better Programming | Medium</a></li><li><a href="https://neo4j.com/docs/operations-manual/current/tools/cypher-shell/" target="_blank" rel="noopener">Cypher Shell - Operations Manual</a></li><li><a href="https://neo4j.com/developer/kb/how-do-i-authenticate-with-cypher-shell-without-specifying-the-username-and-password-on-the-command-line/" target="_blank" rel="noopener">Neo4j : How do I authenticate with cypher-shell without specifying the username and password on the command line - Neo4j Graph Database Platform</a></li><li><a href="https://github.com/neo4j/docker-neo4j/issues/114" target="_blank" rel="noopener">Unable to probe health when composing · Issue #114 · neo4j/docker-neo4j</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-正确的打开方式&quot;&gt;&lt;a href=&quot;#1-正确的打开方式&quot; class=&quot;headerlink&quot; title=&quot;1.正确的打开方式&quot;&gt;&lt;/a&gt;1.正确的打开方式&lt;/h2&gt;&lt;p&gt;由于healthcheck执行的指令是在容器内部执行的，而docker-neo4j内部并没有curl指令，所以我们不能通过&lt;code&gt;curl -f localhost:7474 || exit 1&lt;/code&gt;这样的指令来去判断neo4j容器是否运行正常，这样得到的结果总是unhealthy。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.iamlightsmile.com/categories/Linux/"/>
    
    
      <category term="docker" scheme="https://www.iamlightsmile.com/tags/docker/"/>
    
      <category term="neo4j" scheme="https://www.iamlightsmile.com/tags/neo4j/"/>
    
  </entry>
  
  <entry>
    <title>记录macos下配置hexo博客经历</title>
    <link href="https://www.iamlightsmile.com/articles/%E8%AE%B0%E5%BD%95macos%E4%B8%8B%E9%85%8D%E7%BD%AEhexo%E5%8D%9A%E5%AE%A2%E7%BB%8F%E5%8E%86/"/>
    <id>https://www.iamlightsmile.com/articles/%E8%AE%B0%E5%BD%95macos%E4%B8%8B%E9%85%8D%E7%BD%AEhexo%E5%8D%9A%E5%AE%A2%E7%BB%8F%E5%8E%86/</id>
    <published>2020-11-12T13:02:57.000Z</published>
    <updated>2020-11-12T13:58:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>自己整了台新Mac，这里简单记录一下同步hexo博客的经历过程，还是有些繁琐的。</p><a id="more"></a><h2 id="1-拷贝项目文件"><a href="#1-拷贝项目文件" class="headerlink" title="1.拷贝项目文件"></a>1.拷贝项目文件</h2><p>自己的项目文件其实也通过git管理了，但是不知为何在mac下使用<code>npm install</code>命令老是无法完成安装node_modules。同时自己现在还在用2.6.5版本的volantis主题，而官方都已经更新到v4了，但是自己目前也没有必要迁移到新版本的需求和精力，于是就继续沿用Windows上的旧主题了，于是乎通过选择将整个项目打包压缩然后通过U盘拷到Mac上（如果不压缩打包实在是有些太慢了，因为这些node包的js的细碎文件实在是太多了）</p><h2 id="2-配置hexo路径"><a href="#2-配置hexo路径" class="headerlink" title="2.配置hexo路径"></a>2.配置hexo路径</h2><p>hexo可执行文件在node_modules下的.bin文件下，如果直接执行<code>hexo new xx</code>之类的命令，需要先将该路径添加到PATH变量中，于是乎可以在<code>~/.bash_profile</code>或者<code>~/.zshrc</code>中添加：</p><pre><code class="lang-bash"># hexoexport PATH=&quot;$PATH:/Users/lightsmile/Projects/myProjects/MyBlog//node_modules/.bin&quot;</code></pre><p>上面具体的路径要根据具体情况做出变动。</p><h2 id="3-配置node"><a href="#3-配置node" class="headerlink" title="3.配置node"></a>3.配置node</h2><p>hexo配置完成后，可以正常执行<code>hexo new</code>命令，但是无法执行<code>hexo generate -d</code>命令，google后发现是node版本太新的问题，需要安装旧版本的node，参考文章2中提到v12.14没有问题，于是接下来打算装一下这个版本。</p><h2 id="4-安装nvm"><a href="#4-安装nvm" class="headerlink" title="4.安装nvm"></a>4.安装nvm</h2><p>如果conda可以管理多个版本的Python环境一样，nvm也是用于管理node环境的工具，于是乎直接<code>brew install nvm</code>安装，没想到安装失败，只能去GitHub官方网页上找安装方式，需要执行如下命令：</p><pre><code class="lang-bash">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.0/install.sh | bash</code></pre><p>或者</p><pre><code class="lang-bash">wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.0/install.sh | bash</code></pre><p>于是乎便执行curl命令，没想到报443的错误，想到可能是代理的问题，于是继续Google寻找解决方案。</p><h2 id="5-安装proxychains-ng"><a href="#5-安装proxychains-ng" class="headerlink" title="5.安装proxychains-ng"></a>5.安装proxychains-ng</h2><p>Google后找到了参考3，然后参考3提到了参考4，于是乎安装<code>proxychains-ng</code>。</p><pre><code class="lang-bash">brew install proxychains-ng</code></pre><p>安装人家的教程修改了<code>/usr/local/etc/proxychains.conf</code>后发现还是不行，然后又发现了参考5，按照参考5增加了变动之后发现还是下载失败，后来看参考3的评论中发现了可行的方案：<strong>其实设置DNS为114.114.114.114或者8.8.8.8就好了。</strong>。</p><h2 id="6-配置DNS"><a href="#6-配置DNS" class="headerlink" title="6.配置DNS"></a>6.配置DNS</h2><p>详情参见参考6，dns内容我设置的为8.8.8.8，经测试有效。</p><h2 id="7-继续下载nvm并配置node"><a href="#7-继续下载nvm并配置node" class="headerlink" title="7.继续下载nvm并配置node"></a>7.继续下载nvm并配置node</h2><p>nvm下载完成之后还是找不到，然后自己执行了下<code>source ~/.bash_profile</code>，然后出于保险又把相关命令复制到了<code>~/.zshrc</code>中一份，相关命令如下：</p><pre><code class="lang-bash">export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot;  # This loads nvm[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \. &quot;$NVM_DIR/bash_completion&quot;  # This loads nvm bash_completion</code></pre><h2 id="8-配置nvm镜像源"><a href="#8-配置nvm镜像源" class="headerlink" title="8.配置nvm镜像源"></a>8.配置nvm镜像源</h2><p>使用nvm安装node命令如下：</p><pre><code class="lang-bash">nvm install 12.14</code></pre><p>然后发现nvm会直接从node的官网去下载，于是乎又失败了，只能配置镜像源，配置方式为将如下命令添加到<code>~/.zshrc</code>中：</p><pre><code class="lang-bash">export NVM_NODEJS_ORG_MIRROR=http://npm.taobao.org/mirrors/node</code></pre><p>配置完成之后更新一下zshrc（即执行命令<code>source ~/.zshrc</code>）然后继续执行install命令便可成功下载。</p><p>然后切换成12.14版本的node，切换命令如下：</p><pre><code class="lang-bash">nvm use 12.14</code></pre><p>然后程序便提示已经成功切换。</p><h2 id="9-参考"><a href="#9-参考" class="headerlink" title="9.参考"></a>9.参考</h2><ol><li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">文档 | Hexo</a></li><li><a href="https://zhuanlan.zhihu.com/p/136552969" target="_blank" rel="noopener">部署Hexo踩过的坑—node14.0配置hexo - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/115450863" target="_blank" rel="noopener">Failed to connect to raw.githubusercontent.com:443 - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/124199138" target="_blank" rel="noopener">使用 proxychains-ng 代理命令行 - 知乎</a></li><li><a href="https://guangchuangyu.github.io/cn/2018/09/proxychains/" target="_blank" rel="noopener">一次解决所有代理问题</a></li><li><a href="https://www.jianshu.com/p/a150b13a2031" target="_blank" rel="noopener">Mac ：修改 DNS 及清除 DNS 缓存 - 简书</a></li><li><a href="https://www.jianshu.com/p/bc56e70303f7" target="_blank" rel="noopener">NVM配置国内镜像 - 简书</a></li><li><a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener">nvm-sh/nvm: Node Version Manager - POSIX-compliant bash script to manage multiple active node.js versions</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己整了台新Mac，这里简单记录一下同步hexo博客的经历过程，还是有些繁琐的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="https://www.iamlightsmile.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="hexo" scheme="https://www.iamlightsmile.com/tags/hexo/"/>
    
      <category term="macos" scheme="https://www.iamlightsmile.com/tags/macos/"/>
    
  </entry>
  
  <entry>
    <title>设置docker容器内时间</title>
    <link href="https://www.iamlightsmile.com/articles/%E8%AE%BE%E7%BD%AEdocker%E5%AE%B9%E5%99%A8%E5%86%85%E6%97%B6%E9%97%B4/"/>
    <id>https://www.iamlightsmile.com/articles/%E8%AE%BE%E7%BD%AEdocker%E5%AE%B9%E5%99%A8%E5%86%85%E6%97%B6%E9%97%B4/</id>
    <published>2020-11-12T08:56:35.000Z</published>
    <updated>2020-11-12T09:00:14.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-通过文件挂载形式设置与宿主机时间一致"><a href="#1-通过文件挂载形式设置与宿主机时间一致" class="headerlink" title="1. 通过文件挂载形式设置与宿主机时间一致"></a>1. 通过文件挂载形式设置与宿主机时间一致</h2><p>可以在<code>docker-compose</code>文件中设置如下：</p><pre><code class="lang-yml">volumes:    - &quot;/etc/localtime:/etc/localtime:ro&quot;  # 容器只能从主机的/etc/localtime中读取</code></pre><h2 id="2-设置timezone"><a href="#2-设置timezone" class="headerlink" title="2. 设置timezone"></a>2. 设置timezone</h2><p>如设置时区为上海，可在docker容器内部执行：</p><pre><code class="lang-bash">echo &#39;Asia/Shanghai&#39; &gt; /etc/timezone</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-通过文件挂载形式设置与宿主机时间一致&quot;&gt;&lt;a href=&quot;#1-通过文件挂载形式设置与宿主机时间一致&quot; class=&quot;headerlink&quot; title=&quot;1. 通过文件挂载形式设置与宿主机时间一致&quot;&gt;&lt;/a&gt;1. 通过文件挂载形式设置与宿主机时间一致&lt;/h2
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.iamlightsmile.com/categories/Linux/"/>
    
    
      <category term="docker" scheme="https://www.iamlightsmile.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>缓存机制与产品经理</title>
    <link href="https://www.iamlightsmile.com/articles/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"/>
    <id>https://www.iamlightsmile.com/articles/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/</id>
    <published>2020-11-12T07:19:44.000Z</published>
    <updated>2020-11-12T07:54:10.939Z</updated>
    
    <content type="html"><![CDATA[<p>今天研读同事的代码，发现代码里新增了缓存机制，这里算是自己不太懂的领域，需要学习一下。</p><p>同事用到的Python的缓存库为<a href="https://github.com/pallets/cachelib" target="_blank" rel="noopener">pallets/cachelib</a>，发现这个库用的人还挺少的（至少star数是如此），并且作者也有段时间没更新了，网上搜的话也找不到相关教程。</p><a id="more"></a><p>于是乎只能瞜一眼同事大概是咋用的，然后再读一下这个库的源码，发现还挺简洁的。</p><p>在大致读完代码之后，心里不禁感慨，这个缓存机制真的不错。犹记得，上大学时的计算机系统结构的老师问道：在计算机的发展历史中，引入的哪个功能或组件解决了痛点而又没有引入其他副作用？老师说唯一的答案就是缓存机制。但是当时还不能理解其真正含义。</p><p>打算再看看关于缓存机制介绍的更多的文章，google一下，发现都是讲浏览器缓存的，而我想看些关于机制介绍的更广的东西。</p><p>后来发现了这两篇文章：<a href="http://www.woshipm.com/pmd/856507.html" target="_blank" rel="noopener">浅析互联网中的缓存机制 | 人人都是产品经理</a>以及<a href="https://wizardforcel.gitbooks.io/django-book-20-zh-cn/content/15.html" target="_blank" rel="noopener">第十五章： 缓存机制| Django Book 2.0 中文版</a>，两个也都讲的挺详细的。</p><p>令我没想到的是，有人作为一个产品经理能够将关于缓存机制的东西总结的这么好。于是我不禁反思，一个合格的产品经理应该懂些技术，而一个合格的程序员似乎也应该懂些产品相关的东西，而不应该仅仅着眼于技术实现的层面，更应该以产品经理为师，学习借鉴他们看待问题的视角和方法，提升自己看待问题的层面。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天研读同事的代码，发现代码里新增了缓存机制，这里算是自己不太懂的领域，需要学习一下。&lt;/p&gt;
&lt;p&gt;同事用到的Python的缓存库为&lt;a href=&quot;https://github.com/pallets/cachelib&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pallets/cachelib&lt;/a&gt;，发现这个库用的人还挺少的（至少star数是如此），并且作者也有段时间没更新了，网上搜的话也找不到相关教程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="https://www.iamlightsmile.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="产品经理" scheme="https://www.iamlightsmile.com/tags/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"/>
    
      <category term="缓存机制" scheme="https://www.iamlightsmile.com/tags/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>vim更新及安装插件教程</title>
    <link href="https://www.iamlightsmile.com/articles/vim%E6%9B%B4%E6%96%B0%E5%8F%8A%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%E6%95%99%E7%A8%8B/"/>
    <id>https://www.iamlightsmile.com/articles/vim%E6%9B%B4%E6%96%B0%E5%8F%8A%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%E6%95%99%E7%A8%8B/</id>
    <published>2020-11-12T03:13:06.000Z</published>
    <updated>2020-11-12T04:26:05.509Z</updated>
    
    <content type="html"><![CDATA[<p>这里简单记录一下自己安装vim以及安装插件的过程。</p><blockquote><p><strong>注意</strong>：以下安装过程适用于Linux以及Macos系统。</p></blockquote><a id="more"></a><h2 id="1-安装vim-plug"><a href="#1-安装vim-plug" class="headerlink" title="1.安装vim-plug"></a>1.安装vim-plug</h2><pre><code class="lang-bash">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</code></pre><h2 id="2-配置vim配置文件"><a href="#2-配置vim配置文件" class="headerlink" title="2.配置vim配置文件"></a>2.配置vim配置文件</h2><p>编辑<code>~/.vimrc</code>文件，如我的<code>~/.vimrc</code>文件下内容目前如下：</p><pre><code class="lang-txt">set encoding=UTF-8set numberset autoindentcall plug#begin(&#39;~/.vim/plugged&#39;)Plug &#39;ryanoasis/vim-devicons&#39;Plug &#39;scrooloose/nerdtree&#39;Plug &#39;frazrepo/vim-rainbow&#39;Plug &#39;itchyny/lightline.vim&#39;Plug &#39;junegunn/fzf&#39;Plug &#39;airblade/vim-gitgutter&#39;call plug#end()map &lt;F3&gt; :NERDTreeMirror&lt;CR&gt;map &lt;F3&gt; :NERDTreeToggle&lt;CR&gt;</code></pre><h2 id="3-安装vim插件"><a href="#3-安装vim插件" class="headerlink" title="3.安装vim插件"></a>3.安装vim插件</h2><pre><code class="lang-bash"># 进入vim中vim</code></pre><p>以下命令均是在vim下执行</p><pre><code class="lang-bash"># 查看vim相关信息:version# 更新vimrc文件（可选）:source ~/.vimrc# 查看插件状态:PlugStatus# 安装插件:PlugInstall</code></pre><h2 id="4-配置终端字体"><a href="#4-配置终端字体" class="headerlink" title="4.配置终端字体"></a>4.配置终端字体</h2><p>使用<code>nerdtree</code>插件以及<code>vim-devicons</code>插件便可以实现vim下目录或文件的图标效果，但前提是启用了支持终端图标效果的字体，这里我们需要去<a href="https://github.com/ryanoasis/nerd-fonts" target="_blank" rel="noopener">ryanoasis/nerd-fonts</a>下载。</p><p>关于字体安装，如果是windows系统或者macos系统可以直接双击文件进行安装，如果是Linux的话，可以参考<a href="https://www.jianshu.com/p/8517e94a29ae" target="_blank" rel="noopener">[转]Linux CentOS 7 安装字体库和中文字体 - 简书</a>进行配置安装。</p><p>然后设置终端字体为支持Nerd的字体，如下图：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/centos-vim1.png" alt="pic1"></p><p>然后打开vim可以看到如下效果：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/centos-vim2.png" alt="pic2"></p><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5.参考"></a>5.参考</h2><ul><li><a href="https://github.com/junegunn/vim-plug" target="_blank" rel="noopener">junegunn/vim-plug: Minimalist Vim Plugin Manager</a></li><li><a href="https://www.jianshu.com/p/8517e94a29ae" target="_blank" rel="noopener">[转]Linux CentOS 7 安装字体库和中文字体 - 简书</a></li><li><a href="https://www.jianshu.com/p/0c83e6aed270" target="_blank" rel="noopener">Vim-plug：极简 Vim 插件管理器 - 简书</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里简单记录一下自己安装vim以及安装插件的过程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：以下安装过程适用于Linux以及Macos系统。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.iamlightsmile.com/categories/Linux/"/>
    
    
      <category term="vim" scheme="https://www.iamlightsmile.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>centos更新vim</title>
    <link href="https://www.iamlightsmile.com/articles/centos%E6%9B%B4%E6%96%B0vim/"/>
    <id>https://www.iamlightsmile.com/articles/centos%E6%9B%B4%E6%96%B0vim/</id>
    <published>2020-11-12T03:11:37.000Z</published>
    <updated>2020-11-12T04:25:02.656Z</updated>
    
    <content type="html"><![CDATA[<p>centos默认vim版本为7.4，用起来其实并不舒服，所以这里选择通过源码安装方式（主要是尝试了通过yum安装都没有成功）安装最新版vim（写这篇文档的时候是8.2）</p><a id="more"></a><blockquote><p><strong>注意</strong>：以下命令我都是在root账户下执行的，如果是在普通用户下执行可以选择su切换到root或者前面增加sudo命令。</p></blockquote><h2 id="1-安装依赖库"><a href="#1-安装依赖库" class="headerlink" title="1.安装依赖库"></a>1.安装依赖库</h2><p>源码编译需要安装make、git等工具，但是一般而言服务器上都有，同时教程提到了安装python36，然而现在最新的python都已经到了3.9了，我通过conda安装的python版本环境是3.8，所以并没有严格安装教程来执行相关命令。</p><pre><code class="lang-bash">yum install ncurses-devel</code></pre><h2 id="2-克隆Github的vim项目"><a href="#2-克隆Github的vim项目" class="headerlink" title="2.克隆Github的vim项目"></a>2.克隆Github的vim项目</h2><p>首先切换到一个惯常放置Github项目的目录，如我的在<code>/root/Projects/GithubProjects</code>，然后再执行以下命令，当然位置在哪不大要紧。</p><pre><code class="lang-bash">git clone https://github.com/vim/vim.git</code></pre><h2 id="3-配置并编译vim"><a href="#3-配置并编译vim" class="headerlink" title="3.配置并编译vim"></a>3.配置并编译vim</h2><pre><code class="lang-bash">// 进入项目cd vim// 配置参数./configure --prefix=/usr/local/vim  --enable-pythoninterp=yes --enable-python3interp=yes --with-python-command=python --with-python3-command=python// 编译文件，可能需要使用sudo权限makemake install</code></pre><h2 id="4-复制Vim到系统配置，并修改Profile"><a href="#4-复制Vim到系统配置，并修改Profile" class="headerlink" title="4.复制Vim到系统配置，并修改Profile"></a>4.复制Vim到系统配置，并修改Profile</h2><pre><code class="lang-bash">// 复制前可以备份一下cp /usr/bin/vim /usr/bin/vim.backup// 复制前面编译的vim到系统配置cd /root/Projects/GithubProjects/vim/srccp vim /usr/bin// 修改系统的Profileecho &quot;PATH=\$PATH:/usr/local/vim/bin&quot; &gt;&gt; /etc/profile// 运行刚修改的配置。source /etc/profile// 最后，check versionvim --version// 同时，也能看到它支持Python3了。(7.4是不支持的。)</code></pre><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5.参考"></a>5.参考</h2><ul><li><a href="https://www.jianshu.com/p/b44d568aef9f" target="_blank" rel="noopener">CentOS, Vim7.4升级到8.1 (服务器) — 亲试可行 - 简书</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;centos默认vim版本为7.4，用起来其实并不舒服，所以这里选择通过源码安装方式（主要是尝试了通过yum安装都没有成功）安装最新版vim（写这篇文档的时候是8.2）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.iamlightsmile.com/categories/Linux/"/>
    
    
      <category term="centos" scheme="https://www.iamlightsmile.com/tags/centos/"/>
    
      <category term="vim" scheme="https://www.iamlightsmile.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>开放式信息抽取探索（1）</title>
    <link href="https://www.iamlightsmile.com/articles/%E5%BC%80%E6%94%BE%E5%BC%8F%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%96%E6%8E%A2%E7%B4%A2%EF%BC%881%EF%BC%89/"/>
    <id>https://www.iamlightsmile.com/articles/%E5%BC%80%E6%94%BE%E5%BC%8F%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%96%E6%8E%A2%E7%B4%A2%EF%BC%881%EF%BC%89/</id>
    <published>2020-11-05T07:41:56.000Z</published>
    <updated>2020-11-12T03:22:21.977Z</updated>
    
    <content type="html"><![CDATA[<p>一直对自然语言处理和知识图谱感兴趣，然而其细分领域中最感兴趣的领域或问题是开放式信息抽取。</p><p>这里简单记录下自己的探索历程和内心感受。</p><a id="more"></a><h2 id="任务划分"><a href="#任务划分" class="headerlink" title="任务划分"></a>任务划分</h2><p>信息抽取主要包含实体抽取、关系抽取和事件抽取，这里主要关注事件抽取。</p><h2 id="可以用监督学习模型吗"><a href="#可以用监督学习模型吗" class="headerlink" title="可以用监督学习模型吗"></a>可以用监督学习模型吗</h2><p>因为是开放式信息抽取，没有标记语料和训练带标签数据的过程，甚至说事件的种类都不是固定已知的，所以不能用监督学习模型。</p><h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><p>打算借助基础nlp工具LTP，调研依存句法、语义角色标注、语义依存分析等功能。</p><h2 id="简单对比"><a href="#简单对比" class="headerlink" title="简单对比"></a>简单对比</h2><p>经过简单对比，觉得语义角色标注有遗漏的情况，而依存句法和语义依存效果相对较好，同时语义依存结果相对复杂，同时还存在一定的Bug。所以选择使用依存句法去入手。</p><h2 id="调研相关文章和开源项目"><a href="#调研相关文章和开源项目" class="headerlink" title="调研相关文章和开源项目"></a>调研相关文章和开源项目</h2><p>在调研网上其他的基于句法的开放式信息抽取的文章和项目时，发现了<a href="https://github.com/lemonhu/open-entity-relation-extraction" target="_blank" rel="noopener">lemonhu/open-entity-relation-extraction: Knowledge triples extraction and knowledge base construction based on dependency syntax for open domain text.</a>。觉得该项目和我要做的相近，于是调研了其代码实现，发现里面的规则是硬编码的，写的比较死，拓展性比较差，于是便思索是否有别的更好的方案。</p><h2 id="新的想法"><a href="#新的想法" class="headerlink" title="新的想法"></a>新的想法</h2><p>苦思冥想着觉得这些规则不应该硬编码，而是别的可拓展或易于修改的方式。后来突然想到树也算图的一种特殊结构，所以树的遍历、树的路径匹配也可以看做图的遍历、图的子图的路径匹配，而最近刚搞了Neo4j，Neo4j自然可以视作一个高效的图计算引擎，因此将句法分析和Neo4j结合在一起搞的想法便初步形成了。相应的，实体可以看做图的节点，实体在事件中所扮演的角色可以看做是到中心词（动词）的边，依存树中的定语（和实体构成定中修饰关系）可以视作实体节点的属性，而状语作为对中心词（动词）的修饰可以视作事件中心词的属性。所以由依存树到知识图谱便对应起来了。于是乎我们可以去构建Cypher查询语句来实现实体和事件的抽取。</p><p>如下图：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/openoie-neo4j.png" alt="pic1"></p><h2 id="深入Neo4j"><a href="#深入Neo4j" class="headerlink" title="深入Neo4j"></a>深入Neo4j</h2><p>由于涉及到一些图遍历相关的东西，所以自己便想着通过使用Neo4j的apoc拓展库来实现，之前使用了<code>apoc.path.expand</code>，不过后来发现自己用错了，更应该用的是<code>apoc.path.subgraphNodes</code>，然后写了几个语法发现在一些Case上的提取结果还算不错。</p><h2 id="就难受住"><a href="#就难受住" class="headerlink" title="就难受住"></a>就难受住</h2><p>不过当Case变得复杂的时候，发现依存句法解析的有些问题，自然也就导致部分提取不到，于是自己内心就变得沮丧了起来。这是自己想解决的问题呀，可是好难，自己也不知如何去实现，就难受住。</p><h2 id="柳暗花明"><a href="#柳暗花明" class="headerlink" title="柳暗花明"></a>柳暗花明</h2><p>后来想着要不试试别的工具的效果，包括语义角色标注和语义依存分析，结果竟然发现语义角色标注的解析结果还真的挺好的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直对自然语言处理和知识图谱感兴趣，然而其细分领域中最感兴趣的领域或问题是开放式信息抽取。&lt;/p&gt;
&lt;p&gt;这里简单记录下自己的探索历程和内心感受。&lt;/p&gt;
    
    </summary>
    
    
      <category term="知识图谱" scheme="https://www.iamlightsmile.com/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
    
      <category term="信息抽取" scheme="https://www.iamlightsmile.com/tags/%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%96/"/>
    
  </entry>
  
  <entry>
    <title>求职随记</title>
    <link href="https://www.iamlightsmile.com/articles/%E6%B1%82%E8%81%8C%E9%9A%8F%E8%AE%B0/"/>
    <id>https://www.iamlightsmile.com/articles/%E6%B1%82%E8%81%8C%E9%9A%8F%E8%AE%B0/</id>
    <published>2020-10-27T14:17:20.000Z</published>
    <updated>2020-10-27T14:25:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近想换工作，于是Boss直聘设置状态为“在职-考虑机会”，同时更新了简历内容，于是乎最近有简历投递邀请，并且今天还收到了好几份面试邀请。</p><a id="more"></a><p>不过今晚最终想了想还是先拒绝掉了，虽然这种做法可能确实有点败人缘、坏人品，但是另一方面，我们小组目前处于比较缺人的状态，并且现在我还主要负责一个电网相关的知识库项目，离开了只会让同事更难做。一方面自己想换个环境继续学习新的知识和技能，另一方面则是一份责任，是自己应该做且做好的事情。只能等把项目推进到年末之后再考虑更换工作吧，现在换工作确实对公司而言有些不厚道了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近想换工作，于是Boss直聘设置状态为“在职-考虑机会”，同时更新了简历内容，于是乎最近有简历投递邀请，并且今天还收到了好几份面试邀请。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随念" scheme="https://www.iamlightsmile.com/categories/%E9%9A%8F%E5%BF%B5/"/>
    
    
      <category term="求职" scheme="https://www.iamlightsmile.com/tags/%E6%B1%82%E8%81%8C/"/>
    
  </entry>
  
  <entry>
    <title>国内博客网站说明</title>
    <link href="https://www.iamlightsmile.com/articles/%E5%9B%BD%E5%86%85%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E8%AF%B4%E6%98%8E/"/>
    <id>https://www.iamlightsmile.com/articles/%E5%9B%BD%E5%86%85%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E8%AF%B4%E6%98%8E/</id>
    <published>2020-10-26T05:05:39.000Z</published>
    <updated>2020-10-26T05:08:45.481Z</updated>
    
    <content type="html"><![CDATA[<p>本博客国内网址链接为：<a href="https://www.lightsmile.cn/" target="_blank" rel="noopener">lightsmile’s Blog</a>。</p><p>另：国内网站采用腾讯云服务器，自己写了两篇关于翻墙的文章被人举报，无奈将两篇文章删除，并且不再同步更新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本博客国内网址链接为：&lt;a href=&quot;https://www.lightsmile.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;lightsmile’s Blog&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;另：国内网站采用腾讯云服务器，自己写了两篇关于翻墙的文章
      
    
    </summary>
    
    
      <category term="其他" scheme="https://www.iamlightsmile.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="翻墙" scheme="https://www.iamlightsmile.com/tags/%E7%BF%BB%E5%A2%99/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch分页搜索</title>
    <link href="https://www.iamlightsmile.com/articles/Elasticsearch%E5%88%86%E9%A1%B5%E6%90%9C%E7%B4%A2/"/>
    <id>https://www.iamlightsmile.com/articles/Elasticsearch%E5%88%86%E9%A1%B5%E6%90%9C%E7%B4%A2/</id>
    <published>2020-10-26T04:59:22.000Z</published>
    <updated>2020-10-26T05:00:53.770Z</updated>
    
    <content type="html"><![CDATA[<p>目前已经找到Elasticsearch分页搜索实现机制，目前仅考虑使用<code>from-size</code>机制，具体在通过Python的Elasticsearch库调用时有两种方式：</p><a id="more"></a><h3 id="方式一：restful风格"><a href="#方式一：restful风格" class="headerlink" title="方式一：restful风格"></a>方式一：restful风格</h3><p>使用示例：</p><pre><code class="lang-python">from elasticsearch import Elasticsearches = Elasticsearch()# es = Elasticsearch(hosts={&quot;host&quot;: &quot;localhost&quot;, &quot;port&quot;: 9200})index = &quot;index&quot;query_body = {    &quot;from&quot;: 5,    &quot;size&quot;: 10,    &quot;query&quot;: {        &quot;match&quot;: {            &quot;word&quot;: &quot;测试&quot;        }    }}res = es.search(index=index, body=query_body)</code></pre><p>其中<code>from</code>指定偏移量，<code>size</code>指定返回结果个数。</p><h3 id="方式二：Python风格"><a href="#方式二：Python风格" class="headerlink" title="方式二：Python风格"></a>方式二：Python风格</h3><p>使用示例：</p><pre><code class="lang-python">from elasticsearch import Elasticsearches = Elasticsearch()# es = Elasticsearch(hosts={&quot;host&quot;: &quot;localhost&quot;, &quot;port&quot;: 9200})index = &quot;index&quot;query_body = {    &quot;query&quot;: {        &quot;match&quot;: {            &quot;word&quot;: &quot;测试&quot;        }    }}res = es.search(index=index, body=query_body, from_=5, size=10)</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/171dcd33ab02" target="_blank" rel="noopener">elasticsearch 分页查询实现方案 - 简书</a></li><li><a href="https://wonderomg.github.io/2018/05/17/Elasticsearch%E5%AE%9E%E8%B7%B5api%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/" target="_blank" rel="noopener">Elasticsearch实践(3)-api分页查询 | WONDEROMG</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前已经找到Elasticsearch分页搜索实现机制，目前仅考虑使用&lt;code&gt;from-size&lt;/code&gt;机制，具体在通过Python的Elasticsearch库调用时有两种方式：&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="https://www.iamlightsmile.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="Elasticsearch" scheme="https://www.iamlightsmile.com/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>使用终端文件管理器ranger</title>
    <link href="https://www.iamlightsmile.com/articles/%E4%BD%BF%E7%94%A8%E7%BB%88%E7%AB%AF%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8ranger/"/>
    <id>https://www.iamlightsmile.com/articles/%E4%BD%BF%E7%94%A8%E7%BB%88%E7%AB%AF%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8ranger/</id>
    <published>2020-10-25T15:08:33.000Z</published>
    <updated>2020-10-25T15:21:09.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h2><p>之前早在18年就使用过Linux下终端文件管理器ranger，后来在Manjaro系统下也使用过，不过最近发现安装的ranger一直都不能预览文件，就很懵逼，一直不甘心，于是各种找解决方案。</p><a id="more"></a><h2 id="1-解决方案"><a href="#1-解决方案" class="headerlink" title="1.解决方案"></a>1.解决方案</h2><p>后来看到这篇教程：<a href="https://www.pythonf.cn/read/49398" target="_blank" rel="noopener">终端文件管理Ranger</a>才知道root账号是不能使用预览功能的，如果开启只能动Python源码。</p><p>具体为修改<code>site-packages/ranger/core/main.py</code>文件的大约141行，如下：</p><pre><code class="lang-python">        if fm.username == &#39;root&#39;:            fm.settings.preview_files = False            fm.settings.use_preview_script = False            LOG.info(&quot;Running as root, disabling the file previews.&quot;)</code></pre><p>把这几行注释掉就可以了。</p><p>然后重新打开ranger发现已经开启预览了嘻嘻。</p><p>关于如何定位<code>main.py</code>具体位置，主要是判断自己是在哪个Python环境下安装的ranger。如我是在miniconda下默认Python环境安装的ranger，并且miniconda的安装位置为<code>/opt/miniconda3</code>，所以我就在该路径下使用find命令即可找到ranger库文件，如下：</p><pre><code class="lang-bash">(base) ➜  miniconda3 find . -name &quot;*ranger*&quot;   ./lib/python3.8/site-packages/ranger_fm-1.9.3.dist-info./lib/python3.8/site-packages/ranger./bin/ranger./share/applications/ranger.desktop./share/doc/ranger./share/man/man1/ranger.1</code></pre><p>然后该<code>mian.py</code>的绝对路径则为<code>/opt/miniconda3/lib/python3.8/site-packages/ranger/core/main.py</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0.前言&quot;&gt;&lt;/a&gt;0.前言&lt;/h2&gt;&lt;p&gt;之前早在18年就使用过Linux下终端文件管理器ranger，后来在Manjaro系统下也使用过，不过最近发现安装的ranger一直都不能预览文件，就很懵逼，一直不甘心，于是各种找解决方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.iamlightsmile.com/categories/Linux/"/>
    
    
      <category term="ranger, Linux" scheme="https://www.iamlightsmile.com/tags/ranger-Linux/"/>
    
  </entry>
  
  <entry>
    <title>CentOS安装Hadoop</title>
    <link href="https://www.iamlightsmile.com/articles/CentOS%E5%AE%89%E8%A3%85Hadoop/"/>
    <id>https://www.iamlightsmile.com/articles/CentOS%E5%AE%89%E8%A3%85Hadoop/</id>
    <published>2020-10-23T09:02:13.000Z</published>
    <updated>2020-10-23T15:13:27.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近决定学一些大数据、分布式之类的技术。其中最基本的比如说安装Hadoop，没想到安装个这个也不太顺利，这里简单记录一下。</p><a id="more"></a><p>主要参考的两篇教程：</p><ul><li><a href="https://www.jianshu.com/p/78f9cc79a766" target="_blank" rel="noopener">hadoop 3.1.3单机版安装教程 - 简书</a></li><li><a href="https://www.jianshu.com/p/27cbd5bbdf61" target="_blank" rel="noopener">【Hadoop】Hadoop 3.2.1 真伪分布式搭建 - 简书</a></li></ul><blockquote><p><strong>注意</strong>：本文将介绍伪分布式安装过程，至于真分布式不做介绍。</p></blockquote><h2 id="搭建流程"><a href="#搭建流程" class="headerlink" title="搭建流程"></a>搭建流程</h2><h3 id="1-安装java"><a href="#1-安装java" class="headerlink" title="1 安装java"></a>1 安装java</h3><p>略</p><h3 id="2-下载Hadoop"><a href="#2-下载Hadoop" class="headerlink" title="2 下载Hadoop"></a>2 下载Hadoop</h3><p>下载页：<a href="https://www.apache.org/dyn/closer.cgi/hadoop/common/hadoop-3.3.0/hadoop-3.3.0.tar.gz" target="_blank" rel="noopener">Apache Download Mirrors</a></p><h3 id="3-找到Java安装路径"><a href="#3-找到Java安装路径" class="headerlink" title="3 找到Java安装路径"></a>3 找到Java安装路径</h3><p>which java定位到的是java程序的执行路径，而不是安装路径，经过两次-lrt最后的输出才是安装路径。</p><p>具体参考第2篇文档。</p><h3 id="4-安装Hadoop"><a href="#4-安装Hadoop" class="headerlink" title="4 安装Hadoop"></a>4 安装Hadoop</h3><p>上面两篇文档放置的Hadoop的位置路径不同，一个是在<code>/home/</code>路径下，一个是在<code>usr/local/hadoop</code>下，而我自己选择了<code>/opt</code>下面。</p><p>相关不同可以参考：<a href="https://blog.csdn.net/baidu_30000217/article/details/78936790" target="_blank" rel="noopener">Linux 软件安装到 /usr，/usr/local/ 还是 /opt 目录？_LSGOZJ的博客-CSDN博客</a></p><h3 id="5-设置Hadoop启动项"><a href="#5-设置Hadoop启动项" class="headerlink" title="5 设置Hadoop启动项"></a>5 设置Hadoop启动项</h3><p>同样的，上面两篇教程中配置方式也不相同，一篇直接修改<code>/etc/profile</code>，一篇修改<code>/etc/profile.d/hadoop.sh</code>，两者殊途同归，效果一致。</p><p>内容大致即：</p><pre><code class="lang-bash">export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-0.el7_7.x86_64  export HADOOP_HOME=/home/hadoop-3.2.1export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</code></pre><p>然后使配置生效刷新环境变量，即运行<code>source /etc/profile</code></p><h3 id="6-创建hadoop用户"><a href="#6-创建hadoop用户" class="headerlink" title="6 创建hadoop用户"></a>6 创建hadoop用户</h3><pre><code class="lang-bash">adduser hadoop # 新增用户passwd hadoop # 设置秘密groupadd hadoop # 新建用户组usermod -G hadoop hadoop # 将用户添加到用户组id hadoop # 查看用户情况</code></pre><h3 id="7-创建hadoop文件目录并授权"><a href="#7-创建hadoop文件目录并授权" class="headerlink" title="7 创建hadoop文件目录并授权"></a>7 创建hadoop文件目录并授权</h3><pre><code class="lang-bash">mkdir -p /home/hadoop/tmp # hadoop临时文件目录mkdir -p /home/hadoop/hdfs/name # hadoop主节点(namenode)文件目录mkdir -p /home/hadoop/hdfs/data # hadoop数据节点(datanode)文件目录mkdir -p /home/hadoop/log # hadoop日志文件目录chown -R hadoop:hadoop /home/hadoop # 设置hadoop文件目录所有者</code></pre><h3 id="8-修改hadoop配置文件"><a href="#8-修改hadoop配置文件" class="headerlink" title="8 修改hadoop配置文件"></a>8 修改hadoop配置文件</h3><p>hadoop的配置文件都在 etc/hadoop 目录下，配置文件有很多，最基本要修改3个文件：hadoop-env.sh ，core-site.xml，hdfs-site.xml。</p><h4 id="8-1-hadoop-env-sh"><a href="#8-1-hadoop-env-sh" class="headerlink" title="8.1 hadoop-env.sh"></a>8.1 hadoop-env.sh</h4><pre><code class="lang-bash">export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-0.el7_7.x86_64 # 需要指定Java路径export HADOOP_LOG_DIR=/home/hadoop/log # 需要指定hadoop_log_dir</code></pre><h4 id="8-2-core-site-xml"><a href="#8-2-core-site-xml" class="headerlink" title="8.2 core-site.xml"></a>8.2 core-site.xml</h4><pre><code class="lang-xml">&lt;configuration&gt;    &lt;property&gt;        &lt;name&gt;fs.defaultFS&lt;/name&gt;        &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;        &lt;description&gt;hdfs内部通讯访问地址&lt;/description&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;        &lt;value&gt;file:/home/hadoop/tmp&lt;/value&gt;        &lt;description&gt;hadoop数据存放&lt;/description&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre><h4 id="8-3-hdfs-site-xml"><a href="#8-3-hdfs-site-xml" class="headerlink" title="8.3 hdfs-site.xml"></a>8.3 hdfs-site.xml</h4><pre><code class="lang-xml">&lt;configuration&gt;    &lt;property&gt;        &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;        &lt;value&gt;file:/home/hadoop/hdfs/name&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;        &lt;value&gt;file:/home/hadoop/hdfs/data&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;dfs.replication&lt;/name&gt;        &lt;value&gt;1&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre><h3 id="9-设置ssh免密登录"><a href="#9-设置ssh免密登录" class="headerlink" title="9 设置ssh免密登录"></a>9 设置ssh免密登录</h3><blockquote><p><strong>注意</strong>：以下命令均是在hadoop用户下进行。</p></blockquote><p>需要用前面创建的hadoop用户通过ssh免密访问本地，先切换到hadoop用户目录下，执行以下命令：</p><pre><code class="lang-bash">ssh-keygen -t dsa -P &#39;&#39; -f ~/.ssh/id_dsacat ~/.ssh/id_dsa.pub &gt;&gt; ~/.ssh/authorized_keyschmod 0600 ~/.ssh/authorized_keys</code></pre><p>测试是否成功，执行下面命令，若不用输入密码则成功。</p><pre><code class="lang-bash">ssh localhost</code></pre><h3 id="10-启动hadoop"><a href="#10-启动hadoop" class="headerlink" title="10 启动hadoop"></a>10 启动hadoop</h3><blockquote><p><strong>注意</strong>：以下命令均是在hadoop用户下进行。</p></blockquote><h4 id="10-1-格式化hadoop文件系统"><a href="#10-1-格式化hadoop文件系统" class="headerlink" title="10.1 格式化hadoop文件系统"></a>10.1 格式化hadoop文件系统</h4><pre><code class="lang-bash">hdfs namenode -format</code></pre><h4 id="10-2-一键启动"><a href="#10-2-一键启动" class="headerlink" title="10.2 一键启动"></a>10.2 一键启动</h4><pre><code class="lang-bash">start-all.sh</code></pre><h4 id="10-3-检验"><a href="#10-3-检验" class="headerlink" title="10.3 检验"></a>10.3 检验</h4><p>输入命令 ，没有报错，则hadoop单机版安装成功。</p><pre><code class="lang-bash">hadoop fs -ls /</code></pre><h3 id="11-查看启动效果"><a href="#11-查看启动效果" class="headerlink" title="11 查看启动效果"></a>11 查看启动效果</h3><p>访问<code>http://localhost:9870</code>，可以得到如下图所示：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/hadoop_front.png" alt="hadoop效果"></p><h3 id="其他文章"><a href="#其他文章" class="headerlink" title="其他文章"></a>其他文章</h3><ul><li><a href="https://www.cnblogs.com/luo630/p/13271637.html" target="_blank" rel="noopener">Hadoop、HBase、Spark单机安装 - 工程师二号 - 博客园</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近决定学一些大数据、分布式之类的技术。其中最基本的比如说安装Hadoop，没想到安装个这个也不太顺利，这里简单记录一下。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Debian或Ubuntu安装Nodejs</title>
    <link href="https://www.iamlightsmile.com/articles/Debian%E6%88%96Ubuntu%E5%AE%89%E8%A3%85Nodejs/"/>
    <id>https://www.iamlightsmile.com/articles/Debian%E6%88%96Ubuntu%E5%AE%89%E8%A3%85Nodejs/</id>
    <published>2020-10-22T01:20:32.000Z</published>
    <updated>2020-10-22T01:31:31.760Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h2><p>安装最新Nodejs的命令如下：</p><a id="more"></a><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><pre><code class="lang-bash">curl -sL https://deb.nodesource.com/setup_15.x | sudo -E bash -sudo apt-get install -y nodejs</code></pre><h3 id="Debian"><a href="#Debian" class="headerlink" title="Debian"></a>Debian</h3><pre><code class="lang-bash">curl -sL https://deb.nodesource.com/setup_15.x | bash -apt-get install -y nodejs</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/nodesource/distributions" target="_blank" rel="noopener">nodesource/distributions: NodeSource Node.js Binary Distributions</a></li><li><a href="https://ywnz.com/linuxjc/5819.html" target="_blank" rel="noopener">在Debian 10系统上安装Node.js和npm的三种不同方法_Linux教程_云网牛站</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装命令&quot;&gt;&lt;a href=&quot;#安装命令&quot; class=&quot;headerlink&quot; title=&quot;安装命令&quot;&gt;&lt;/a&gt;安装命令&lt;/h2&gt;&lt;p&gt;安装最新Nodejs的命令如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.iamlightsmile.com/categories/Linux/"/>
    
    
      <category term="Debian" scheme="https://www.iamlightsmile.com/tags/Debian/"/>
    
      <category term="Nodejs" scheme="https://www.iamlightsmile.com/tags/Nodejs/"/>
    
      <category term="Ubuntu" scheme="https://www.iamlightsmile.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用工具</title>
    <link href="https://www.iamlightsmile.com/articles/Linux%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    <id>https://www.iamlightsmile.com/articles/Linux%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</id>
    <published>2020-10-18T04:37:21.000Z</published>
    <updated>2020-10-18T04:37:21.787Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>使用docker遇到的问题</title>
    <link href="https://www.iamlightsmile.com/articles/%E4%BD%BF%E7%94%A8docker%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://www.iamlightsmile.com/articles/%E4%BD%BF%E7%94%A8docker%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-10-17T11:14:13.000Z</published>
    <updated>2020-10-22T03:09:12.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-容器内文件无法删除"><a href="#1-容器内文件无法删除" class="headerlink" title="1.容器内文件无法删除"></a>1.容器内文件无法删除</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>最近使用docker部署项目，结果发现docker里的文件无法删除，于是开始Google寻求解决方案。</p><a id="more"></a><h3 id="探索过程"><a href="#探索过程" class="headerlink" title="探索过程"></a>探索过程</h3><p>刚开始搜到<a href="https://www.escapelife.site/posts/d9b10b4c.html" target="_blank" rel="noopener">Docker容器内文件无法删除 | Escape</a>，还以为是Centos7本身的bug，但是还是怀疑这种常见的问题应该早就被修复掉了，不应该像文档中那么麻烦。</p><p>之前的问题使用的是公司的内网服务器，Centos7系统；然而自己在自己的腾讯云Centos7系统上也测试了一下删除文件，发现就没有问题。同时自己在使用docker的neo4j容器时遇到了访问文件受限的问题，根据错误信息发现了该issue：<a href="https://github.com/neo4j/docker-neo4j/issues/266" target="_blank" rel="noopener">uid and gid change · Issue #266 · neo4j/docker-neo4j</a>，发现里面提到了docker版本的bug。发现自己服务器上的docker版本比较新，同时检查了下公司内网服务器中的docker版本还挺老旧的。于是网上搜索docker升级命令，找到了<a href="https://www.cnblogs.com/operationhome/p/11322150.html" target="_blank" rel="noopener">Docker 更新版本 - 自由早晚乱余生 - 博客园</a>。这篇文档写的很详细，在遇到的问题部分中提到了Linux内核版本的问题，自己又查看对比了下自己服务器和内网机内核版本，发现差别还真挺大的。内网机版本号才300多，而自己的都900多了。其中文档提到版本号514是个坎。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>升级系统内核版本+升级docker版本就可以解决该问题。</p><h2 id="2-debian操作系统离线安装docker以及docker-compose"><a href="#2-debian操作系统离线安装docker以及docker-compose" class="headerlink" title="2.debian操作系统离线安装docker以及docker-compose"></a>2.debian操作系统离线安装docker以及docker-compose</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>不知道怎么离线安装，网上找教程即可。</p><h3 id="探索过程-1"><a href="#探索过程-1" class="headerlink" title="探索过程"></a>探索过程</h3><p>找到的两篇文章：</p><ul><li><a href="https://blog.csdn.net/qq_23287943/article/details/96124441" target="_blank" rel="noopener">基于凝思磐石&amp;debian内网环境搭建docker集群_解忧小童子-CSDN博客</a></li><li><a href="https://www.cnblogs.com/nihaorz/p/12123803.html" target="_blank" rel="noopener">debian 10.x (buster) 离线安装docker及卸载 - Nihaorz - 博客园</a></li></ul><p>其中第一篇同时提到了安装docker和docker-compose，第二篇只提到了安装docker但是更加详细。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>参照上面第二篇文档安装docker，参照上面第一篇文档安装docker-compose。</p><p>类似的一键安装脚本可以写成：</p><pre><code class="lang-bash">#!/bin/bash# install dockerdpkg -i containerd.io_1.3.7-1_amd64.debdpkg -i docker-ce-cli_19.03.9~3-0~debian-buster_amd64.debdpkg -i docker-ce_19.03.9~3-0~debian-buster_amd64.deb# check docker versiondocker info# install docker-composecp docker-compose-Linux-x86_64 /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-composeln -snvf /usr/local/bin/docker-compose /usr/bin/docker-compose# check docker-compose versiondocker-compose -v</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-容器内文件无法删除&quot;&gt;&lt;a href=&quot;#1-容器内文件无法删除&quot; class=&quot;headerlink&quot; title=&quot;1.容器内文件无法删除&quot;&gt;&lt;/a&gt;1.容器内文件无法删除&lt;/h2&gt;&lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;最近使用docker部署项目，结果发现docker里的文件无法删除，于是开始Google寻求解决方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="https://www.iamlightsmile.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="docker" scheme="https://www.iamlightsmile.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker常用命令</title>
    <link href="https://www.iamlightsmile.com/articles/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://www.iamlightsmile.com/articles/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2020-10-14T07:06:18.000Z</published>
    <updated>2020-10-22T03:13:18.820Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-查看容器内系统版本"><a href="#1-查看容器内系统版本" class="headerlink" title="1.查看容器内系统版本"></a>1.查看容器内系统版本</h2><pre><code class="lang-bash">cat /etc/issue</code></pre><blockquote><p><strong>注意</strong>：不能使用<code>cat /proc/version</code> 或 <code>uname -a</code>，因为docker并不能隔离像/dev、/proc的目录，这些都是直接挂载的宿主机的。所以，很多命令像free top之类的命令，其实看到的都是宿主机的。因为这些命令都是基于/proc下的信息统计出来的</p></blockquote><p>参考：<a href="https://blog.csdn.net/c461522756/article/details/70822234" target="_blank" rel="noopener">docker容器中查看容器linux版本_貌似爽歪歪的博客-CSDN博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-查看容器内系统版本&quot;&gt;&lt;a href=&quot;#1-查看容器内系统版本&quot; class=&quot;headerlink&quot; title=&quot;1.查看容器内系统版本&quot;&gt;&lt;/a&gt;1.查看容器内系统版本&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;cat /etc
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.iamlightsmile.com/categories/Linux/"/>
    
    
      <category term="Docker" scheme="https://www.iamlightsmile.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>知识库学习心得随记</title>
    <link href="https://www.iamlightsmile.com/articles/%E7%9F%A5%E8%AF%86%E5%BA%93%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%E9%9A%8F%E8%AE%B0/"/>
    <id>https://www.iamlightsmile.com/articles/%E7%9F%A5%E8%AF%86%E5%BA%93%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%E9%9A%8F%E8%AE%B0/</id>
    <published>2020-10-10T08:13:47.000Z</published>
    <updated>2020-10-10T08:28:41.012Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看一些知识库的项目，自己小有体会，这里简单记录一下。</p><a id="more"></a><p>近几个月来，出于项目需要，自己简单学习了下Elasticsearch，并且重新学习了下Neo4j。我发现看的知识库的项目所使用的数据库不尽相同，有基于Neo4j的，有基于Elasticsearch的，有基于MongoDB的，这不禁令我反思。</p><p>这些数据库的相似之处在于都非关系型数据库，不同之处在于各自所更能适配的数据类型不同。Neo4j更适配的数据是那些数据类型简单但之间关系复杂多样化的，Elasticsearch更适配的数据或者说场景是待检索的数据尤其是需要定制复杂规则过滤排序的数据，而MongoDB则更加通用一些。</p><p>在实际项目中，对于数据量比较小或者业务场景比较简单的情况下，其实这三种数据库基本都能完成需求；而只有当数据的量级很大（比如在上百万条）以及业务场景比较复杂的情况下，三种各自的优劣才能比较明显的体现出来。数据库之间也没有通用的优劣高低之分，只有哪个更适配任务的数据类型和场景之分。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看一些知识库的项目，自己小有体会，这里简单记录一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="知识图谱" scheme="https://www.iamlightsmile.com/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
    
      <category term="知识库" scheme="https://www.iamlightsmile.com/tags/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Neo4j使用小记</title>
    <link href="https://www.iamlightsmile.com/articles/Neo4j%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0/"/>
    <id>https://www.iamlightsmile.com/articles/Neo4j%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0/</id>
    <published>2020-10-10T07:54:55.000Z</published>
    <updated>2020-10-10T08:28:41.012Z</updated>
    
    <content type="html"><![CDATA[<p>使用社区版Neo4j时有一些注意事项，这里简单小记一下。</p><a id="more"></a><h2 id="1-一台机器启动多个Neo4j数据库"><a href="#1-一台机器启动多个Neo4j数据库" class="headerlink" title="1.一台机器启动多个Neo4j数据库"></a>1.一台机器启动多个Neo4j数据库</h2><p>最好的方式，甚至是唯一的选择是使用Docker。</p><p>现在版本（4.0以上）的Neo4j貌似不能使用拷贝程序到不同目录设置不同端口执行了。</p><p>我们可以在Neo4j社区版中创建多个数据库，但是同时只能使用一个。</p><p>如图，只有默认数据库和系统数据库可以切换，其他的数据库的状态是未连接的。</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/neo4j_show_databases.png" alt=""></p><p>如果需要创建多个数据库，那么我们只需要在neo4j的配置文件即<code>neo4j.conf</code>中<code>dbms.default_database=baike</code>一行设置新的数据库名并重启neo4j即可，如前句中为<code>baike</code>。</p><p>相应的，如果需要切换数据库，则只能先修改neo4j.conf配置文件的default_database选项，然后重启neo4j。</p><h2 id="2-Neo4j使用的Apoc需要配套版本"><a href="#2-Neo4j使用的Apoc需要配套版本" class="headerlink" title="2.Neo4j使用的Apoc需要配套版本"></a>2.Neo4j使用的Apoc需要配套版本</h2><p>具体在<a href="https://github.com/neo4j-contrib/neo4j-apoc-procedures/releases" target="_blank" rel="noopener">Releases · neo4j-contrib/neo4j-apoc-procedures</a>页下载。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用社区版Neo4j时有一些注意事项，这里简单小记一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="https://www.iamlightsmile.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="Neo4j" scheme="https://www.iamlightsmile.com/tags/Neo4j/"/>
    
  </entry>
  
  <entry>
    <title>flask+vue实现文件上传下载</title>
    <link href="https://www.iamlightsmile.com/articles/flask-vue%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"/>
    <id>https://www.iamlightsmile.com/articles/flask-vue%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/</id>
    <published>2020-09-17T15:38:11.000Z</published>
    <updated>2020-09-17T15:55:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h2><p>自己尝试着用Vue+Flask实现了下文件上传下载的功能，初步试验成功可行~</p><a id="more"></a><h2 id="1-后端代码"><a href="#1-后端代码" class="headerlink" title="1.后端代码"></a>1.后端代码</h2><pre><code class="lang-python">import osfrom flask import Flask, render_template, request, jsonify, send_from_directoryfrom werkzeug.utils import secure_filenamefrom flask_cors import CORSapp = Flask(__name__)CORS(app, supports_credentials=True)app.config[&#39;UPLOAD_FOLDER&#39;] = &#39;upload&#39;for file in os.listdir(app.config[&#39;UPLOAD_FOLDER&#39;]):    print(file)@app.route(&#39;/file_list&#39;, methods = [&#39;GET&#39;, &#39;POST&#39;])def file_list():    return jsonify({        &#39;file_list&#39;: [{&#39;name&#39;: name} for name in os.listdir(app.config[&#39;UPLOAD_FOLDER&#39;])]    })@app.route(&#39;/download/&lt;string:file_name&gt;&#39;, methods = [&#39;POST&#39;])def download(file_name: str):    print(file_name)    print(os.path.join(app.config[&#39;UPLOAD_FOLDER&#39;], file_name))    return send_from_directory(app.config[&#39;UPLOAD_FOLDER&#39;], file_name, as_attachment=True)@app.route(&#39;/upload&#39;, methods = [&#39;GET&#39;, &#39;POST&#39;])def uploader():   if request.method == &#39;POST&#39;:        print(request.files)        f = request.files[&#39;file&#39;]        print(f.filename)        print(secure_filename(f.filename))        # f.save(os.path.join(app.config[&#39;UPLOAD_FOLDER&#39;],secure_filename(f.filename)))        f.save(os.path.join(app.config[&#39;UPLOAD_FOLDER&#39;],f.filename))        return &#39;file uploaded successfully&#39;if __name__ == &#39;__main__&#39;:   app.run()</code></pre><h2 id="2-前端代码"><a href="#2-前端代码" class="headerlink" title="2.前端代码"></a>2.前端代码</h2><pre><code class="lang-vue">&lt;template&gt;  &lt;div&gt;    &lt;h3&gt;文件上传&lt;/h3&gt;    &lt;el-upload class=&quot;upload-demo&quot; drag action=&quot;http://localhost:5000/upload&quot; multiple&gt;      &lt;i class=&quot;el-icon-upload&quot;&gt;&lt;/i&gt;      &lt;div class=&quot;el-upload__text&quot;&gt;        将文件拖到此处，或        &lt;em&gt;点击上传&lt;/em&gt;      &lt;/div&gt;      &lt;div class=&quot;el-upload__tip&quot; slot=&quot;tip&quot;&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt;    &lt;/el-upload&gt;    &lt;el-divider&gt;&lt;/el-divider&gt;    &lt;h3&gt;文件下载&lt;/h3&gt;    &lt;p&gt;{{file_list}}&lt;/p&gt;    &lt;el-table      :data=&quot;file_list.filter(data =&gt; !search || data.name.toLowerCase().includes(search.toLowerCase()))&quot;      style=&quot;width: 100%&quot;    &gt;      &lt;el-table-column label=&quot;Name&quot; prop=&quot;name&quot;&gt;&lt;/el-table-column&gt;      &lt;el-table-column align=&quot;right&quot;&gt;        &lt;template slot=&quot;header&quot; slot-scope=&quot;{}&quot;&gt;          &lt;el-input v-model=&quot;search&quot; size=&quot;mini&quot; placeholder=&quot;输入关键字搜索&quot; /&gt;        &lt;/template&gt;        &lt;template slot-scope=&quot;scope&quot;&gt;          &lt;el-button size=&quot;mini&quot; @click=&quot;handleDownload(scope.$index, scope.row)&quot;&gt;下载&lt;/el-button&gt;          &lt;el-button size=&quot;mini&quot; type=&quot;danger&quot; @click=&quot;handleDelete(scope.$index, scope.row)&quot;&gt;删除&lt;/el-button&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;    &lt;/el-table&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from &quot;axios&quot;;import fileDownload from &#39;js-file-download&#39;;export default {  data() {    return {      tableData: [        {          date: &quot;2016-05-02&quot;,          name: &quot;王小虎&quot;,          address: &quot;上海市普陀区金沙江路 1518 弄&quot;,        },        {          date: &quot;2016-05-04&quot;,          name: &quot;王小虎&quot;,          address: &quot;上海市普陀区金沙江路 1517 弄&quot;,        },        {          date: &quot;2016-05-01&quot;,          name: &quot;王小虎&quot;,          address: &quot;上海市普陀区金沙江路 1519 弄&quot;,        },        {          date: &quot;2016-05-03&quot;,          name: &quot;王小虎&quot;,          address: &quot;上海市普陀区金沙江路 1516 弄&quot;,        },      ],      search: &quot;&quot;,      file_list: &quot;&quot;,    };  },  methods: {    handleDownload(index, row) {      console.log(index, row);      const url = &quot;http://localhost:5000/download&quot;      var path = url + &#39;/&#39; + row[&#39;name&#39;]    axios.post(path, {}, {responseType: &#39;arraybuffer&#39;}).then((res) =&gt; {          fileDownload(res.data, row[&#39;name&#39;]);      })    },    handleDelete(index, row) {      console.log(index, row);    },    get_file_list(){        const url = &quot;http://localhost:5000/file_list&quot;;        axios.get(url).then((res) =&gt; {            console.log(res)            this.file_list = res.data[&quot;file_list&quot;];        }).catch((err) =&gt; {          console.error(err);        });    }  },  created() {      this.get_file_list();  }};&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><p>其中使用了axios、element-ui和js-file-download库。</p><h2 id="5-效果"><a href="#5-效果" class="headerlink" title="5.效果"></a>5.效果</h2><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/img/flask_vue_frontend.png" alt=""></p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/img/flask_vue_backend.png" alt=""></p><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6.参考"></a>6.参考</h2><ul><li><a href="https://blog.csdn.net/qq_25730711/article/details/53643758" target="_blank" rel="noopener">flask-文件上传/下载_More and Better-CSDN博客</a></li><li><a href="https://www.jianshu.com/p/cb02c30f6f84" target="_blank" rel="noopener">Flask 文件上传 - 简书</a></li><li><a href="https://www.jianshu.com/p/53deecb09077" target="_blank" rel="noopener">Axios 各种请求方式传递参数格式 - 简书</a></li><li><a href="https://segmentfault.com/a/1190000020540788" target="_blank" rel="noopener">前端js/vue下载后台传过来的流文件（如excel）并设置下载文件名 - 漫漫前端路 - SegmentFault 思否</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0.前言&quot;&gt;&lt;/a&gt;0.前言&lt;/h2&gt;&lt;p&gt;自己尝试着用Vue+Flask实现了下文件上传下载的功能，初步试验成功可行~&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="https://www.iamlightsmile.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="flask" scheme="https://www.iamlightsmile.com/tags/flask/"/>
    
      <category term="vue" scheme="https://www.iamlightsmile.com/tags/vue/"/>
    
  </entry>
  
</feed>
