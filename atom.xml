<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lightsmile&#39;s Blog</title>
  
  <subtitle>lightsmile</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.iamlightsmile.com/"/>
  <updated>2021-03-22T06:45:23.781Z</updated>
  <id>https://www.iamlightsmile.com/</id>
  
  <author>
    <name>lightsmile</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用Cython小记</title>
    <link href="https://www.iamlightsmile.com/articles/%E4%BD%BF%E7%94%A8Cython%E5%B0%8F%E8%AE%B0/"/>
    <id>https://www.iamlightsmile.com/articles/%E4%BD%BF%E7%94%A8Cython%E5%B0%8F%E8%AE%B0/</id>
    <published>2021-03-22T06:14:32.000Z</published>
    <updated>2021-03-22T06:45:23.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-安装Cython"><a href="#1-安装Cython" class="headerlink" title="1.安装Cython"></a>1.安装Cython</h2><pre><code class="lang-bash">pip install cython</code></pre><a id="more"></a><h2 id="2-编写pyx代码"><a href="#2-编写pyx代码" class="headerlink" title="2.编写pyx代码"></a>2.编写pyx代码</h2><p>新建<code>hello_world.pyx</code>文件，内容如下：</p><pre><code class="lang-python">print(&quot;Hello World&quot;)from libc.math cimport sincpdef double f(double x):    return sin(x*x)cdef int c_add(int a, int b):    return a + bdef add(a: int, b: int):    return c_add(a, b)def sub(a: int, b: int):    return a - b</code></pre><p>以上有三种定义函数的方式：</p><ul><li>使用cdef定义配合python的def定义</li><li>使用cpdef定义函数</li><li>使用python原生def</li></ul><p>示例分别为：</p><h4 id="使用cdef定义配合python的def定义"><a href="#使用cdef定义配合python的def定义" class="headerlink" title="使用cdef定义配合python的def定义"></a>使用cdef定义配合python的def定义</h4><pre><code class="lang-python">cdef int c_add(int a, int b):    return a + bdef add(a: int, b: int):    return c_add(a, b)</code></pre><h4 id="使用cpdef定义函数"><a href="#使用cpdef定义函数" class="headerlink" title="使用cpdef定义函数"></a>使用cpdef定义函数</h4><pre><code class="lang-python">cpdef double f(double x):    return sin(x*x)</code></pre><h4 id="使用python原生def"><a href="#使用python原生def" class="headerlink" title="使用python原生def"></a>使用python原生def</h4><pre><code class="lang-python">def sub(a: int, b: int):    return a - b</code></pre><h2 id="3-编写setup-py文件"><a href="#3-编写setup-py文件" class="headerlink" title="3.编写setup.py文件"></a>3.编写setup.py文件</h2><pre><code class="lang-python">from distutils.core import setupfrom Cython.Build import cythonizesetup(    ext_modules = cythonize(&quot;hello_world.pyx&quot;,    compiler_directives={&#39;language_level&#39; : &quot;3&quot;}))</code></pre><h2 id="4-生成链接库文件"><a href="#4-生成链接库文件" class="headerlink" title="4.生成链接库文件"></a>4.生成链接库文件</h2><pre><code class="lang-bash">python setup.py build_ext --inplace</code></pre><h2 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h2><pre><code class="lang-bash">(base) ➜  testCython pwd/root/Projects/CppProjects/testCython(base) ➜  testCython lsbuild          hello_world.cpython-38-x86_64-linux-gnu.so  setup.pyhello_world.c  hello_world.pyx(base) ➜  testCython pythonPython 3.8.3 (default, May 19 2020, 18:47:26) [GCC 7.3.0] :: Anaconda, Inc. on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import hello_worldHello World&gt;&gt;&gt; dir(hello_world)[&#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__spec__&#39;, &#39;__test__&#39;, &#39;add&#39;, &#39;f&#39;, &#39;sub&#39;]&gt;&gt;&gt; hello_world.add(3, 4)7&gt;&gt;&gt; hello_world.f(3.3)-0.9944322093031951&gt;&gt;&gt; hello_world.sub(3.4, 5.5)-2.1&gt;&gt;&gt; exit()</code></pre><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6.参考"></a>6.参考</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/24311879" target="_blank" rel="noopener">Cython 基本用法 - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/65900669" target="_blank" rel="noopener">Cython教程与代码之——Cython_tutorial之（5到完结） - 知乎</a></li><li><a href="https://www.coder.work/article/358350" target="_blank" rel="noopener">python - 如何在Cython的setup.py中指定Python 3源？ - IT工具网</a></li><li><a href="https://www.bookstack.cn/read/cython-doc-zh/docs-8.md" target="_blank" rel="noopener">Tutorials - 基础教程 - 《Cython 3.0 中文文档》 - 书栈网 · BookStack</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-安装Cython&quot;&gt;&lt;a href=&quot;#1-安装Cython&quot; class=&quot;headerlink&quot; title=&quot;1.安装Cython&quot;&gt;&lt;/a&gt;1.安装Cython&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;pip install cython
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://www.iamlightsmile.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.iamlightsmile.com/tags/Python/"/>
    
      <category term="Cython" scheme="https://www.iamlightsmile.com/tags/Cython/"/>
    
  </entry>
  
  <entry>
    <title>使用pybind11小记</title>
    <link href="https://www.iamlightsmile.com/articles/%E4%BD%BF%E7%94%A8pybind11%E5%B0%8F%E8%AE%B0/"/>
    <id>https://www.iamlightsmile.com/articles/%E4%BD%BF%E7%94%A8pybind11%E5%B0%8F%E8%AE%B0/</id>
    <published>2021-03-22T06:14:14.000Z</published>
    <updated>2021-03-22T07:04:14.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-下载pybind11"><a href="#1-下载pybind11" class="headerlink" title="1.下载pybind11"></a>1.下载pybind11</h2><pre><code class="lang-bash">git clone https://github.com/pybind/pybind11.git --depth=1</code></pre><a id="more"></a><h2 id="2-编写cpp代码"><a href="#2-编写cpp代码" class="headerlink" title="2.编写cpp代码"></a>2.编写cpp代码</h2><p>编写<code>example.cpp</code>文件内容如下：</p><pre><code class="lang-cpp">#include &lt;pybind11/pybind11.h&gt;namespace py = pybind11;int add(int i, int j){    return i + j;}int sub(int i, int j){    return i - j;}int multiply(int i, int j){    return i * j;}PYBIND11_MODULE(example, m){    m.doc() = &quot;pybind11 example plugin&quot;; // 可选的模块说明    m.def(&quot;add&quot;, &amp;add, &quot;A function which adds two numbers&quot;);    m.def(&quot;sub&quot;, &amp;sub, &quot;A function which subs two numbers&quot;);    m.def(&quot;multiply&quot;, &amp;multiply, &quot;A function which multiplies two numbers&quot;);}</code></pre><h2 id="3-使用CMake编译生成库文件"><a href="#3-使用CMake编译生成库文件" class="headerlink" title="3.使用CMake编译生成库文件"></a>3.使用CMake编译生成库文件</h2><h3 id="3-1-编写CMakeLists-txt文件"><a href="#3-1-编写CMakeLists-txt文件" class="headerlink" title="3.1 编写CMakeLists.txt文件"></a>3.1 编写<code>CMakeLists.txt</code>文件</h3><p>编写<code>CMakeLists.txt</code>文件，内容如下：</p><pre><code class="lang-txt">cmake_minimum_required(VERSION 3.11)project(learnPybind11)add_subdirectory(pybind11)pybind11_add_module(example example.cpp)</code></pre><h3 id="3-2-使用cmake和make命令生成库文件"><a href="#3-2-使用cmake和make命令生成库文件" class="headerlink" title="3.2 使用cmake和make命令生成库文件"></a>3.2 使用cmake和make命令生成库文件</h3><pre><code class="lang-bash">mkdir buildcmake ..make</code></pre><h2 id="4-项目整体目录"><a href="#4-项目整体目录" class="headerlink" title="4.项目整体目录"></a>4.项目整体目录</h2><pre><code class="lang-bash">(base) ➜  learnPybind11 lsbuild  CMakeLists.txt  example.cpp  pybind11(base) ➜  learnPybind11 tree -L 1.├── build├── CMakeLists.txt├── example.cpp└── pybind112 directories, 2 files(base) ➜  learnPybind11 tree -L 2.├── build│   ├── CMakeCache.txt│   ├── CMakeFiles│   ├── cmake_install.cmake│   ├── example.cpython-38-x86_64-linux-gnu.so│   ├── Makefile│   └── pybind11├── CMakeLists.txt├── example.cpp└── pybind11    ├── build    ├── CMakeFiles    ├── cmake_install.cmake    ├── CMakeLists.txt    ├── docs    ├── include    ├── LICENSE    ├── Makefile    ├── MANIFEST.in    ├── pybind11    ├── pyproject.toml    ├── README.rst    ├── setup.cfg    ├── setup.py    ├── tests    └── tools11 directories, 15 files</code></pre><h2 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h2><pre><code class="lang-bash">(base) ➜  build pwd/root/Projects/CppProjects/learnPybind11/build(base) ➜  build pythonPython 3.8.3 (default, May 19 2020, 18:47:26) [GCC 7.3.0] :: Anaconda, Inc. on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import example&gt;&gt;&gt; dir(example)[&#39;__doc__&#39;, &#39;__file__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__spec__&#39;, &#39;add&#39;, &#39;multiply&#39;, &#39;sub&#39;]&gt;&gt;&gt; example.add(3,4)7&gt;&gt;&gt; exit()</code></pre><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6.参考"></a>6.参考</h2><ol><li><a href="https://blog.csdn.net/fitzzhang/article/details/78988682" target="_blank" rel="noopener">python调用C++之pybind11入门_Fitzzhang-CSDN博客_pybind11</a></li><li><a href="https://www.cnblogs.com/jsxyhelu/p/12827052.html" target="_blank" rel="noopener">基于pybind11实现Python调用c++编写的CV算法—下 （Linux+Cmake） - jsxyhelu - 博客园</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-下载pybind11&quot;&gt;&lt;a href=&quot;#1-下载pybind11&quot; class=&quot;headerlink&quot; title=&quot;1.下载pybind11&quot;&gt;&lt;/a&gt;1.下载pybind11&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;git clone https://github.com/pybind/pybind11.git --depth=1
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://www.iamlightsmile.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.iamlightsmile.com/tags/Python/"/>
    
      <category term="pybind11" scheme="https://www.iamlightsmile.com/tags/pybind11/"/>
    
  </entry>
  
  <entry>
    <title>lightnlu:一个基于Python的小巧简单的模板匹配框架</title>
    <link href="https://www.iamlightsmile.com/articles/lightnlu-%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8EPython%E7%9A%84%E5%B0%8F%E5%B7%A7%E7%AE%80%E5%8D%95%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D%E6%A1%86%E6%9E%B6/"/>
    <id>https://www.iamlightsmile.com/articles/lightnlu-%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8EPython%E7%9A%84%E5%B0%8F%E5%B7%A7%E7%AE%80%E5%8D%95%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D%E6%A1%86%E6%9E%B6/</id>
    <published>2021-03-11T09:14:01.000Z</published>
    <updated>2021-03-11T13:27:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一个基于Python实现的小巧简单的基于模板匹配的自然语言理解框架。<br>这里的自然语言理解仅指意图识别和词槽提取。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="lang-bash">pip install lightnlu</code></pre><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>特别轻量</li><li>模板文件使用yml格式</li><li>支持多源数据导入</li><li>模板语法简明易懂</li></ul><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="step1-定制词表规则"><a href="#step1-定制词表规则" class="headerlink" title="step1:定制词表规则"></a>step1:定制词表规则</h3><p>如编写<code>words.yml</code>文件如下：</p><pre><code class="lang-yaml">-  name: person  aliases:    - 人物  type: json  config:    path: data/person.json-  name: place  aliases:    - 地点    - 位置    - 城市    - 区域  type: csv  config:    path: data/place.csv-  name: relation  aliases: []  type: yml  config:    path: data/relation.yml-  name: predicate  aliases: []  type: yml  config:    path: data/predicate.yml</code></pre><p>其中对应的各yml、json、csv文件内容如下：</p><p><code>person.json</code>中内容如下：</p><pre><code class="lang-json">{&quot;name&quot;: &quot;曹操&quot;, &quot;id&quot;: &quot;1&quot;}{&quot;name&quot;: &quot;刘备&quot;, &quot;id&quot;: &quot;2&quot;}{&quot;name&quot;: &quot;诸葛亮&quot;, &quot;id&quot;: &quot;3&quot;}{&quot;name&quot;: &quot;曹丕&quot;, &quot;id&quot;: &quot;4&quot;}{&quot;name&quot;: &quot;曹植&quot;, &quot;id&quot;: &quot;5&quot;}</code></pre><p><code>place.csv</code>中内容如下：</p><pre><code class="lang-csv">name,id洛阳,1长安,2新野,3赤壁,4宛城,5</code></pre><p><code>relation.yml</code>中内容如下：</p><pre><code class="lang-yaml">son:  - 儿子father:  - 父亲  - 爸爸</code></pre><p><code>predicatel.yml</code>中内容如下：</p><pre><code class="lang-yaml">is:  - 是  - 为isnot:  - 不是  - 不为</code></pre><h3 id="step2-定制模板规则"><a href="#step2-定制模板规则" class="headerlink" title="step2:定制模板规则"></a>step2:定制模板规则</h3><p>如编写<code>pattern.yml</code>文件如下：</p><pre><code class="lang-yaml">-  name: father_son_relation  patterns:    -      - [person, ~, son] # 规则为 [类型, id值, 词槽名称]      - [relation, father, ~]      - [predicate, is, null]      - [person, ~, father]    -      - [ person, ~, father ]      - [ predicate, is, null ]      - [ person, ~, son ]      - [ relation, father, ~ ]-  name: test  patterns:    -      - [person, ~, person]      - [ predicate, is, null ]      - [&#39;@person&#39;, ~, ttt]</code></pre><p>在以上的模板规则中，对于每一个模板规则，需要指定其名字（name）及相应的模板（patterns）。<br>由于存在多个相近但不相同的模板对应同一种意图及词槽，所以这里的patterns是一个列表。<br>在以上的pattern.yml文件中，包含一个<code>&#39;@person&#39;</code>，这里可以映射到person这个类别所对应的所有别名，具体来说，可以对应到<code>[&quot;人物&quot;]</code>列表中的所有词汇。</p><h3 id="step3-编写源代码及触发函数"><a href="#step3-编写源代码及触发函数" class="headerlink" title="step3:编写源代码及触发函数"></a>step3:编写源代码及触发函数</h3><p>示例如下：</p><pre><code class="lang-python"># -*- coding: utf-8 -*-import osimport sysproject_path = os.path.abspath(os.path.join(__file__, &quot;../..&quot;))sys.path.insert(0, project_path)from lightnlu.core import NER, Ruleif __name__ == &#39;__main__&#39;:    path = os.path.join(project_path, &#39;data/words.yml&#39;)    ner = NER()    ner.build_from_yml(path, base_dir=project_path)    print(ner.entities)    path = os.path.join(project_path, &#39;data/pattern.yml&#39;)    rule = Rule()    rule.build_from_yml(path)    @rule.bind(rule_name=&quot;father_son_relation&quot;, act_name=&quot;test&quot;)    def test(father: str, son: str):        return {            &quot;father&quot;: father,            &quot;son&quot;: son        }    @rule.bind(rule_name=&quot;test&quot;, act_name=&quot;ppp&quot;)    def ppp(person: str, ttt: str):        return {            &quot;person&quot;: person,            &quot;ttt&quot;: ttt        }    print(rule.actors)    text = &quot;刘备和诸葛亮在新野旅游，途中遇上了曹操&quot;    slots = ner.extract(text)    print(slots)    print(rule.match(slots))    text = &quot;曹丕的父亲是曹操&quot;    slots = ner.extract(text)    print(rule.match(slots))    print(rule.match_and_act(slots))    text = &quot;曹操是曹丕的父亲&quot;    slots = ner.extract(text)    print(rule.match(slots))    print(rule.match_and_act(slots))    text = &quot;曹操是个人物&quot;    slots = ner.extract(text)    print(rule.match(slots))    print(rule.match_and_act(slots))</code></pre><p>执行结果如下：</p><pre><code class="lang-text">defaultdict(&lt;function default_type at 0x7f88a96b00d0&gt;, {&#39;曹操&#39;: [{&#39;type&#39;: &#39;person&#39;, &#39;id&#39;: &#39;1&#39;}], &#39;刘备&#39;: [{&#39;type&#39;: &#39;person&#39;, &#39;id&#39;: &#39;2&#39;}], &#39;诸葛亮&#39;: [{&#39;type&#39;: &#39;person&#39;, &#39;id&#39;: &#39;3&#39;}], &#39;曹丕&#39;: [{&#39;type&#39;: &#39;person&#39;, &#39;id&#39;: &#39;4&#39;}], &#39;曹植&#39;: [{&#39;type&#39;: &#39;person&#39;, &#39;id&#39;: &#39;5&#39;}], &#39;人物&#39;: [{&#39;type&#39;: &#39;@person&#39;, &#39;id&#39;: None}], &#39;洛阳&#39;: [{&#39;type&#39;: &#39;place&#39;, &#39;id&#39;: &#39;1&#39;}], &#39;长安&#39;: [{&#39;type&#39;: &#39;place&#39;, &#39;id&#39;: &#39;2&#39;}], &#39;新野&#39;: [{&#39;type&#39;: &#39;place&#39;, &#39;id&#39;: &#39;3&#39;}], &#39;赤壁&#39;: [{&#39;type&#39;: &#39;place&#39;, &#39;id&#39;: &#39;4&#39;}], &#39;宛城&#39;: [{&#39;type&#39;: &#39;place&#39;, &#39;id&#39;: &#39;5&#39;}], &#39;地点&#39;: [{&#39;type&#39;: &#39;@place&#39;, &#39;id&#39;: None}], &#39;位置&#39;: [{&#39;type&#39;: &#39;@place&#39;, &#39;id&#39;: None}], &#39;城市&#39;: [{&#39;type&#39;: &#39;@place&#39;, &#39;id&#39;: None}], &#39;区域&#39;: [{&#39;type&#39;: &#39;@place&#39;, &#39;id&#39;: None}], &#39;电站&#39;: [{&#39;type&#39;: &#39;ban_words&#39;, &#39;id&#39;: &#39;&#39;}], &#39;正在站&#39;: [{&#39;type&#39;: &#39;ban_words&#39;, &#39;id&#39;: &#39;&#39;}], &#39;引流线&#39;: [{&#39;type&#39;: &#39;ban_words&#39;, &#39;id&#39;: &#39;&#39;}], &#39;子导线&#39;: [{&#39;type&#39;: &#39;ban_words&#39;, &#39;id&#39;: &#39;&#39;}], &#39;甲母线&#39;: [{&#39;type&#39;: &#39;ban_words&#39;, &#39;id&#39;: &#39;&#39;}], &#39;规则&#39;: [{&#39;type&#39;: &#39;@ban_words&#39;, &#39;id&#39;: None}], &#39;所属厂站&#39;: [{&#39;type&#39;: &#39;attr&#39;, &#39;id&#39;: &#39;attr_ST_ID&#39;}], &#39;所属电厂&#39;: [{&#39;type&#39;: &#39;attr&#39;, &#39;id&#39;: &#39;attr_ST_ID&#39;}], &#39;属于哪个厂站&#39;: [{&#39;type&#39;: &#39;attr&#39;, &#39;id&#39;: &#39;attr_ST_ID&#39;}], &#39;属于哪个电厂&#39;: [{&#39;type&#39;: &#39;attr&#39;, &#39;id&#39;: &#39;attr_ST_ID&#39;}], &#39;电压等级&#39;: [{&#39;type&#39;: &#39;attr&#39;, &#39;id&#39;: &#39;attr_VOLTAGE_TYPE&#39;}], &#39;儿子&#39;: [{&#39;type&#39;: &#39;relation&#39;, &#39;id&#39;: &#39;son&#39;}], &#39;父亲&#39;: [{&#39;type&#39;: &#39;relation&#39;, &#39;id&#39;: &#39;father&#39;}], &#39;爸爸&#39;: [{&#39;type&#39;: &#39;relation&#39;, &#39;id&#39;: &#39;father&#39;}], &#39;是&#39;: [{&#39;type&#39;: &#39;predicate&#39;, &#39;id&#39;: &#39;is&#39;}], &#39;为&#39;: [{&#39;type&#39;: &#39;predicate&#39;, &#39;id&#39;: &#39;is&#39;}], &#39;不是&#39;: [{&#39;type&#39;: &#39;predicate&#39;, &#39;id&#39;: &#39;isnot&#39;}], &#39;不为&#39;: [{&#39;type&#39;: &#39;predicate&#39;, &#39;id&#39;: &#39;isnot&#39;}]})defaultdict(&lt;class &#39;dict&#39;&gt;, {&#39;father_son_relation&#39;: {&#39;test&#39;: &lt;function test at 0x7f88a967e940&gt;}, &#39;test&#39;: {&#39;ppp&#39;: &lt;function ppp at 0x7f88a967e9d0&gt;}})[(&#39;刘备&#39;, {&#39;type&#39;: &#39;person&#39;, &#39;id&#39;: &#39;2&#39;}, 0, 2), (&#39;诸葛亮&#39;, {&#39;type&#39;: &#39;person&#39;, &#39;id&#39;: &#39;3&#39;}, 3, 6), (&#39;新野&#39;, {&#39;type&#39;: &#39;place&#39;, &#39;id&#39;: &#39;3&#39;}, 7, 9), (&#39;曹操&#39;, {&#39;type&#39;: &#39;person&#39;, &#39;id&#39;: &#39;1&#39;}, 17, 19)][][{&#39;name&#39;: &#39;father_son_relation&#39;, &#39;slots&#39;: {&#39;son&#39;: &#39;曹丕&#39;, &#39;father&#39;: &#39;曹操&#39;}}]{&#39;father_son_relation&#39;: {&#39;test&#39;: {&#39;father&#39;: &#39;曹操&#39;, &#39;son&#39;: &#39;曹丕&#39;}}}[{&#39;name&#39;: &#39;father_son_relation&#39;, &#39;slots&#39;: {&#39;father&#39;: &#39;曹操&#39;, &#39;son&#39;: &#39;曹丕&#39;}}]{&#39;father_son_relation&#39;: {&#39;test&#39;: {&#39;father&#39;: &#39;曹操&#39;, &#39;son&#39;: &#39;曹丕&#39;}}}[{&#39;name&#39;: &#39;test&#39;, &#39;slots&#39;: {&#39;person&#39;: &#39;曹操&#39;, &#39;ttt&#39;: &#39;人物&#39;}}]{&#39;test&#39;: {&#39;ppp&#39;: {&#39;person&#39;: &#39;曹操&#39;, &#39;ttt&#39;: &#39;人物&#39;}}}</code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>csv文件和json文件中必须包含name和id两个属性或列。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://github.com/keyue123/poemElasticDemo" target="_blank" rel="noopener">keyue123/poemElasticDemo: 基于Elasticsearch的KBQA</a></li><li><a href="https://github.com/liuhuanyong/QAonMilitaryKG" target="_blank" rel="noopener">liuhuanyong/QAonMilitaryKG: QAonMilitaryKG，QaSystem based on military knowledge graph that stores in mongodb which is different from the previous one, 基于mongodb存储的军事领域知识图谱问答项目，包括飞行器、太空装备等8大类，100余小类，共计5800项的军事武器知识库，该项目不使用图数据库进行存储，通过jieba进行问句解析，问句实体项识别，基于查询模板完成多类问题的查询，主要是提供一种工业界的问答思想demo。</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;一个基于Python实现的小巧简单的基于模板匹配的自然语言理解框架。&lt;br&gt;这里的自然语言理解仅指意图识别和词槽提取。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://www.iamlightsmile.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.iamlightsmile.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>创建ubuntu容器注意事项</title>
    <link href="https://www.iamlightsmile.com/articles/%E5%88%9B%E5%BB%BAubuntu%E5%AE%B9%E5%99%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>https://www.iamlightsmile.com/articles/%E5%88%9B%E5%BB%BAubuntu%E5%AE%B9%E5%99%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</id>
    <published>2021-03-04T07:46:10.000Z</published>
    <updated>2021-03-11T09:25:15.702Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>以下为部分创建Ubuntu容器的注意事项：</p><a id="more"></a><h3 id="1-设置时间区时"><a href="#1-设置时间区时" class="headerlink" title="1. 设置时间区时"></a>1. 设置时间区时</h3><p>执行<code>apt install tzdata</code>命令，安装完成后，即可设置区时，首先设置洲为Asia（亚洲），然后设置城市为Shanghai（70，上海）。</p><h3 id="2-清除缓存"><a href="#2-清除缓存" class="headerlink" title="2. 清除缓存"></a>2. 清除缓存</h3><pre><code class="lang-bash">apt clean &amp;&amp; apt autoclean &amp;&amp; apt autoremove</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/xo19882011/article/details/83789702" target="_blank" rel="noopener">ubuntu16.04 docker 时区设置问题_xo19882011的专栏-CSDN博客</a></li><li><a href="https://www.jianshu.com/p/ee70f9736930" target="_blank" rel="noopener">docker 构建ubuntu镜像设置时区时间 - 简书</a></li><li><a href="https://zhuanlan.zhihu.com/p/93088751" target="_blank" rel="noopener">使用 apt-get 清理 - 知乎</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h2&gt;&lt;p&gt;以下为部分创建Ubuntu容器的注意事项：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.iamlightsmile.com/categories/Linux/"/>
    
    
      <category term="Docker" scheme="https://www.iamlightsmile.com/tags/Docker/"/>
    
      <category term="ubuntu" scheme="https://www.iamlightsmile.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Python配置文件选择策略</title>
    <link href="https://www.iamlightsmile.com/articles/Python%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5/"/>
    <id>https://www.iamlightsmile.com/articles/Python%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5/</id>
    <published>2021-03-03T09:10:10.000Z</published>
    <updated>2021-03-03T09:18:22.158Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-正文"><a href="#0-正文" class="headerlink" title="0.正文"></a>0.正文</h2><p>现在想来，大致使用Python配置变量或配置文件的策略有以下几种：</p><ol><li>硬编码字符串</li><li>配置脚本，如py文件</li><li>配置文件如yml或cfg、ini格式</li><li>环境变量</li><li>命令参数</li><li>数据库中的数据</li></ol><a id="more"></a><p>其中各种选择各有利弊，具体在项目中如何使用需要具体情况具体分析。</p><h2 id="1-参考"><a href="#1-参考" class="headerlink" title="1.参考"></a>1.参考</h2><ul><li><a href="https://segmentfault.com/a/1190000022638813" target="_blank" rel="noopener">Python 配置管理的几种方式 - SegmentFault 思否</a></li><li><a href="https://zhuanlan.zhihu.com/p/54764686" target="_blank" rel="noopener">Python项目读取配置的正确姿势 - 知乎</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-正文&quot;&gt;&lt;a href=&quot;#0-正文&quot; class=&quot;headerlink&quot; title=&quot;0.正文&quot;&gt;&lt;/a&gt;0.正文&lt;/h2&gt;&lt;p&gt;现在想来，大致使用Python配置变量或配置文件的策略有以下几种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;硬编码字符串&lt;/li&gt;
&lt;li&gt;配置脚本，如py文件&lt;/li&gt;
&lt;li&gt;配置文件如yml或cfg、ini格式&lt;/li&gt;
&lt;li&gt;环境变量&lt;/li&gt;
&lt;li&gt;命令参数&lt;/li&gt;
&lt;li&gt;数据库中的数据&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://www.iamlightsmile.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.iamlightsmile.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>为flask添加统一路由</title>
    <link href="https://www.iamlightsmile.com/articles/%E4%B8%BAflask%E6%B7%BB%E5%8A%A0%E7%BB%9F%E4%B8%80%E8%B7%AF%E7%94%B1/"/>
    <id>https://www.iamlightsmile.com/articles/%E4%B8%BAflask%E6%B7%BB%E5%8A%A0%E7%BB%9F%E4%B8%80%E8%B7%AF%E7%94%B1/</id>
    <published>2021-03-03T08:57:13.000Z</published>
    <updated>2021-03-03T09:08:51.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>今天重构项目觉得可以为flask项目各接口添加统一的前缀，而不是全部都是字符串拼接。</p><a id="more"></a><h2 id="2-正文"><a href="#2-正文" class="headerlink" title="2.正文"></a>2.正文</h2><p>其中代码大致如下：</p><pre><code class="lang-python">from flask import Flask, request, jsonify, send_filefrom flask_cors import CORSfrom werkzeug.routing import Rulefrom werkzeug.serving import run_simplefrom werkzeug.middleware.dispatcher import DispatcherMiddlewarePREFIX_PATH = &quot;/prefix&quot;HOST = &quot;127.0.0.1&quot;PORT = 8501if __name__ == &#39;__main__&#39;:    app = Flask(__name__)    @app.route(&quot;/hello_world&quot;, methods=[&#39;POST&#39;, &#39;GET&#39;])    def hello_world():        return jsonify({            &#39;text&#39;: &quot;Hello World!&quot;        })    application = DispatcherMiddleware(app, {PREFIX_PATH: app})    run_simple(HOST, PORT, application, use_debugger=False, threaded=True)</code></pre><h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3.参考"></a>3.参考</h2><ul><li><a href="https://stackoverflow.com/questions/18967441/add-a-prefix-to-all-flask-routes" target="_blank" rel="noopener">python - Add a prefix to all Flask routes - Stack Overflow</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h2&gt;&lt;p&gt;今天重构项目觉得可以为flask项目各接口添加统一的前缀，而不是全部都是字符串拼接。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://www.iamlightsmile.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.iamlightsmile.com/tags/Python/"/>
    
      <category term="flask" scheme="https://www.iamlightsmile.com/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>近日随感</title>
    <link href="https://www.iamlightsmile.com/articles/%E8%BF%91%E6%97%A5%E9%9A%8F%E6%84%9F/"/>
    <id>https://www.iamlightsmile.com/articles/%E8%BF%91%E6%97%A5%E9%9A%8F%E6%84%9F/</id>
    <published>2021-02-21T07:55:35.000Z</published>
    <updated>2021-02-21T08:08:41.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>不是所有的女生都很物质。爱情、呵护、陪伴等同样在她们心中占据相当重要的比重。</li><li>女生或许有身高控、颜控等部分外在筛选条件，但是她们的内心都比较柔弱，在她们心中更重要的是男生应该像一座大山一样，是她们最坚实的依靠，是她们灵魂休憩的港湾。</li><li>不是所有的女生都不敢和男生吃苦，陪男生一起成长；男生更要不负期待，用行动去证明自己值得爱与被爱，用行动去证明女生当时的孤注一掷是正确的。</li><li>最最最重要的是，男生们永远不要让喜欢自己、曾经选择了自己的女生失望难过。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;不是所有的女生都很物质。爱情、呵护、陪伴等同样在她们心中占据相当重要的比重。&lt;/li&gt;
&lt;li&gt;女生或许有身高控、颜控等部分外在筛选条件，但是她们的内心都比较柔弱，在她们心中更重要的是男生应该像一座大山一样，是她们最坚实的依靠，是她们灵魂休憩的港湾。&lt;/li&gt;

      
    
    </summary>
    
    
      <category term="随念" scheme="https://www.iamlightsmile.com/categories/%E9%9A%8F%E5%BF%B5/"/>
    
    
      <category term="感情" scheme="https://www.iamlightsmile.com/tags/%E6%84%9F%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>python38的logging模块的bug</title>
    <link href="https://www.iamlightsmile.com/articles/python38%E7%9A%84logging%E6%A8%A1%E5%9D%97%E7%9A%84bug/"/>
    <id>https://www.iamlightsmile.com/articles/python38%E7%9A%84logging%E6%A8%A1%E5%9D%97%E7%9A%84bug/</id>
    <published>2021-02-18T09:43:17.000Z</published>
    <updated>2021-02-19T02:53:02.869Z</updated>
    
    <content type="html"><![CDATA[<p>今天写代码遇到了一个难以解决的状况，即python38的logging模块存在bug。</p><p>具体内容参见：<a href="https://blog.csdn.net/Mrchuncui/article/details/107606961" target="_blank" rel="noopener">FindCaller() takes from 1 to 2 positional arguments but 3 were given错误纠正_Mrchuncui的博客-CSDN博客</a>，经过几番尝试之后，最终还是通过将python3.7版本的logging模块替换掉3.8版本的logging模块才得以解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天写代码遇到了一个难以解决的状况，即python38的logging模块存在bug。&lt;/p&gt;
&lt;p&gt;具体内容参见：&lt;a href=&quot;https://blog.csdn.net/Mrchuncui/article/details/107606961&quot; target=&quot;_bl
      
    
    </summary>
    
    
      <category term="Python" scheme="https://www.iamlightsmile.com/categories/Python/"/>
    
    
      <category term="python38" scheme="https://www.iamlightsmile.com/tags/python38/"/>
    
      <category term="logging" scheme="https://www.iamlightsmile.com/tags/logging/"/>
    
      <category term="bug" scheme="https://www.iamlightsmile.com/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>Jupyter添加Scala和Spark内核</title>
    <link href="https://www.iamlightsmile.com/articles/Jupyter%E6%B7%BB%E5%8A%A0Scala%E5%92%8CSpark%E5%86%85%E6%A0%B8/"/>
    <id>https://www.iamlightsmile.com/articles/Jupyter%E6%B7%BB%E5%8A%A0Scala%E5%92%8CSpark%E5%86%85%E6%A0%B8/</id>
    <published>2021-02-17T02:39:38.000Z</published>
    <updated>2021-02-17T04:14:04.279Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h2><p>Jupyter大法好！</p><a id="more"></a><h2 id="1-修改Jupyter-notebook配置方法"><a href="#1-修改Jupyter-notebook配置方法" class="headerlink" title="1.修改Jupyter notebook配置方法"></a>1.修改Jupyter notebook配置方法</h2><pre><code class="lang-bash">jupyter notebook --generate-config</code></pre><p>使用以上命令得到notebook的配置文件，路径为：<code>~/.jupyter/jupyter_notebook_config.py</code>，然后我们可以在其中修改是否允许以root用户启动，以及启动目录等。</p><h2 id="2-添加Scala-kernel"><a href="#2-添加Scala-kernel" class="headerlink" title="2.添加Scala kernel"></a>2.添加Scala kernel</h2><p>需要借助<code>almond</code>工具，首先需要先安装<code>almond</code>，如下：</p><pre><code class="lang-bash">curl -Lo coursier https://git.io/coursier-clichmod +x coursier</code></pre><p>然后执行如下命令安装：</p><pre><code class="lang-bash">./coursier launch --fork almond -- --install</code></pre><p>或者是指定almond或scala版本：</p><pre><code class="lang-bash">./coursier launch --fork almond:0.10.0 --scala 2.13 -- --install</code></pre><blockquote><p><strong>注释</strong>：使用<code>scala -version</code>命令查看scala版本。</p></blockquote><p>以上的安装需要耗费一些时间，如果安装过程最后的输出信息为<code>Installed scala kernel under /root/.local/share/jupyter/kernels/scala</code>，则说明安装成功。</p><h2 id="3-添加Spark-kernel"><a href="#3-添加Spark-kernel" class="headerlink" title="3.添加Spark kernel"></a>3.添加Spark kernel</h2><p>这里的kernel更准确的来说应该是pyspark kernel。</p><p>安装命令如下：</p><pre><code class="lang-bash">pip install spylon-kernelpython -m spylon_kernel install</code></pre><h2 id="4-jupyter-notebook内核创建成功示例"><a href="#4-jupyter-notebook内核创建成功示例" class="headerlink" title="4.jupyter notebook内核创建成功示例"></a>4.jupyter notebook内核创建成功示例</h2><p>如下图，为scala kernel：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/scala-kernel.png" alt=""></p><p>如下图，为spark kernel：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/spark-kernel.png" alt=""></p><p>如下图，为jupyter notebook的所有kernels：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/jupyter-notebook-kernels.png" alt=""></p><h2 id="5-Jupyter-notebook内核管理"><a href="#5-Jupyter-notebook内核管理" class="headerlink" title="5.Jupyter notebook内核管理"></a>5.Jupyter notebook内核管理</h2><h3 id="5-1-列出内核"><a href="#5-1-列出内核" class="headerlink" title="5.1 列出内核"></a>5.1 列出内核</h3><pre><code class="lang-bash">jupyter kernelspec list Available kernels:  scala            /root/.local/share/jupyter/kernels/scala  python3          /opt/miniconda3/share/jupyter/kernels/python3  spylon-kernel    /usr/local/share/jupyter/kernels/spylon-kernel</code></pre><h3 id="5-2-移除内核"><a href="#5-2-移除内核" class="headerlink" title="5.2 移除内核"></a>5.2 移除内核</h3><pre><code class="lang-bash">jupyter kernelspec remove &lt;kernel-name&gt;</code></pre><h3 id="5-3-修改kernel名称"><a href="#5-3-修改kernel名称" class="headerlink" title="5.3 修改kernel名称"></a>5.3 修改kernel名称</h3><p>首先使用<code>jupyter kernelspec list</code>找到kernel所在的位置，然后在该文件夹下编辑<code>kernel.json</code>文件，修改<code>display_name</code>属性即可。</p><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6.参考"></a>6.参考</h2><ul><li><a href="https://blog.csdn.net/u014552678/article/details/62046638" target="_blank" rel="noopener">总结：修改Anaconda中的Jupyter Notebook默认工作路径的三种方式_u014552678的博客-CSDN博客</a></li><li><a href="https://almond.sh/docs/quick-start-install" target="_blank" rel="noopener">Installation · almond</a></li><li><a href="https://queirozf.com/entries/jupyter-kernels-how-to-add-change-remove#add-apache-spark-kernel" target="_blank" rel="noopener">Jupyter Notebook Kernels: How to Add, Change, Remove</a></li><li><a href="https://blog.csdn.net/moledyzhang/article/details/78850820" target="_blank" rel="noopener">jupyter安装及配置scala、spark、pyspark内核_moledyzhang的博客-CSDN博客</a></li><li><a href="https://github.com/Valassis-Digital-Media/spylon-kernel" target="_blank" rel="noopener">Valassis-Digital-Media/spylon-kernel: Jupyter kernel for scala and spark</a></li><li><a href="https://blog.csdn.net/rosefun96/article/details/105500856" target="_blank" rel="noopener">Jupyter notebook安装Scala_rosefun96的博客-CSDN博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0.前言&quot;&gt;&lt;/a&gt;0.前言&lt;/h2&gt;&lt;p&gt;Jupyter大法好！&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="https://www.iamlightsmile.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="Jupyter" scheme="https://www.iamlightsmile.com/tags/Jupyter/"/>
    
      <category term="Scala" scheme="https://www.iamlightsmile.com/tags/Scala/"/>
    
      <category term="Spark" scheme="https://www.iamlightsmile.com/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>Spark搞起来！</title>
    <link href="https://www.iamlightsmile.com/articles/Spark%E6%90%9E%E8%B5%B7%E6%9D%A5%EF%BC%81/"/>
    <id>https://www.iamlightsmile.com/articles/Spark%E6%90%9E%E8%B5%B7%E6%9D%A5%EF%BC%81/</id>
    <published>2021-02-16T12:36:08.000Z</published>
    <updated>2021-02-17T02:41:39.491Z</updated>
    
    <content type="html"><![CDATA[<p>Spark搞起来，嘿嘿嘿！</p><a id="more"></a><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/Spark-ui-1.png" alt=""><br><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/spark-ui-2.png" alt=""><br><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/spakr-ui-3.png" alt=""><br><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/spark-ui-4.png" alt=""><br><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/spark-ui-5.png" alt=""></p><p>大爱VS Code~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spark搞起来，嘿嘿嘿！&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="https://www.iamlightsmile.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="Spark" scheme="https://www.iamlightsmile.com/tags/Spark/"/>
    
      <category term="VS Code" scheme="https://www.iamlightsmile.com/tags/VS-Code/"/>
    
  </entry>
  
  <entry>
    <title>centos安装spark</title>
    <link href="https://www.iamlightsmile.com/articles/centos%E5%AE%89%E8%A3%85spark/"/>
    <id>https://www.iamlightsmile.com/articles/centos%E5%AE%89%E8%A3%85spark/</id>
    <published>2021-02-10T12:56:49.000Z</published>
    <updated>2021-02-17T02:41:39.629Z</updated>
    
    <content type="html"><![CDATA[<p>迄今为止，已经有五次因为安装hadoop被黑客入侵导致重装服务器的系统了。经过不断的排查摸索，终于初步确定了就是因为hadoop开放端口的原因。</p><p>在安装spark之前，我们首先需要安装好以下几个组件：</p><ul><li>java</li><li>hadoop</li><li>scala</li></ul><a id="more"></a><h2 id="1-安装java"><a href="#1-安装java" class="headerlink" title="1.安装java"></a>1.安装java</h2><p>关于java的安装，可以选择java8或者java11。使用以下命令搜索相关yum源程序：</p><pre><code class="lang-bash">yum search java</code></pre><p>如下图：<br><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/yum-search-java.png" alt="yum search java"></p><p>之后可以使用如下命令安装java：</p><pre><code class="lang-bash">yum install java-1.8.0-openjdk-devel.x86_64</code></pre><p>或</p><pre><code class="lang-bash">yum install java-11-openjdk-devel.x86_64</code></pre><h2 id="2-安装hadoop"><a href="#2-安装hadoop" class="headerlink" title="2.安装hadoop"></a>2.安装hadoop</h2><p>关于安装hadoop，之前已经写过相关文章如<a href="https://www.iamlightsmile.com/articles/CentOS%E5%AE%89%E8%A3%85Hadoop/">CentOS安装Hadoop - lightsmile’s Blog</a>。关于hadoop的下载，我们可以通过清华源来下载，具体下载地址为：<a href="https://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/core/hadoop-3.3.0/" target="_blank" rel="noopener">Index of /apache/hadoop/core/hadoop-3.3.0</a>。</p><p>需要注意的是设置ssh免密登录过程可能会出现问题，在设置完成后可能还需要提示输入密码才可以。</p><p>这时可以输入：</p><pre><code class="lang-bash">ssh -vvv localhost</code></pre><p>查看详细的登录日志信息，以确定问题所在。其中的问题主要包括<code>~/.ssh</code>文件夹的权限不对以及<code>authorized_keys</code>的权限不对，以及用户自定义ssh秘钥文件名等等。</p><h3 id="2-1-hadoop设置ssh免密登录失败常见原因及解决措施"><a href="#2-1-hadoop设置ssh免密登录失败常见原因及解决措施" class="headerlink" title="2.1 hadoop设置ssh免密登录失败常见原因及解决措施"></a>2.1 hadoop设置ssh免密登录失败常见原因及解决措施</h3><h4 id="ssh文件夹权限"><a href="#ssh文件夹权限" class="headerlink" title="~/.ssh文件夹权限"></a>~/.ssh文件夹权限</h4><p>可以输入以下命令以修改ssh文件夹权限：</p><pre><code class="lang-bash">chmod 700 ~/.ssh</code></pre><h4 id="authorized-keys文件权限"><a href="#authorized-keys文件权限" class="headerlink" title="authorized_keys文件权限"></a>authorized_keys文件权限</h4><pre><code class="lang-bash">chmod 0600 authorized_keys</code></pre><h4 id="找不到ssh秘钥文件或用户自定义ssh秘钥文件名"><a href="#找不到ssh秘钥文件或用户自定义ssh秘钥文件名" class="headerlink" title="找不到ssh秘钥文件或用户自定义ssh秘钥文件名"></a>找不到ssh秘钥文件或用户自定义ssh秘钥文件名</h4><p>如果用户不将ssh秘钥文件设置为默认的id_dsa或id_rsa等，那么用户还需要在~/.ssh文件夹下新增一个config文件以配置相关信息，具体内容大致如下：</p><pre><code class="lang-text">Host localhost    HostName localhost    User hadoop    Port 22    PreferredAuthentications publickey    IdentityFile ~/.ssh/id_rsa</code></pre><p>其中Host后面的localhost是指用户自定义的主机名，用于之后免密登录时ssh后面的地址，HostName则为实际的主机名，User指用户名，Port指ssh登录所使用的端口，IdentityFile指秘钥所对应的路径。</p><p>在新增config文件之后，同时也还需要设置该文件的权限，如：</p><pre><code class="lang-bash">chmod 0600 config</code></pre><h2 id="3-安装scala"><a href="#3-安装scala" class="headerlink" title="3.安装scala"></a>3.安装scala</h2><p>首先需要到Scala<a href="https://www.scala-lang.org/download/" target="_blank" rel="noopener">Download | The Scala Programming Language</a>官网下载scala，可以下载如下文件：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/download_scala.png" alt=""></p><p>在下载完成之后，将其解压到合适的文件夹，并将bin目录添加到系统PATH环境变量中即可。</p><p>我是将hadoop、spark和scala都放到了/opt路径下，同时新增了<code>/etc/profile.d/hadoop.sh</code>文件，里面内容为：</p><pre><code class="lang-bash">export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-11.0.9.11-3.el8_3.x86_64  export HADOOP_HOME=/opt/hadoop-3.3.0export SCALA_HOME=/opt/scala-2.13.4export SPARK_HOME=/opt/spark-3.0.1export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$SCALA_HOME/bin:$SPARK_HOME/bin</code></pre><p>安装完成之后，可以简单验证一下，如下图：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/hello_scala.png" alt=""></p><h2 id="4-安装spark"><a href="#4-安装spark" class="headerlink" title="4.安装spark"></a>4.安装spark</h2><p>对于spark的下载，可以通过国内清华源下载以提高下载速度。具体网址为：<a href="https://mirrors.tuna.tsinghua.edu.cn/apache/spark/" target="_blank" rel="noopener">Index of /apache/spark</a>，当前最新版本的下载链接为：<a href="https://mirrors.tuna.tsinghua.edu.cn/apache/spark/spark-3.0.1/spark-3.0.1-bin-hadoop3.2.tgz" target="_blank" rel="noopener">spark-3.0.1-bin-hadoop3.2.tgz</a>。</p><p>在下载好spark后，解压到合适的位置并配置环境变量与配置scala类似，此处不表。在安装完成之后，可以简单验证一下，如下命令：</p><pre><code class="lang-bash">(base) ➜  ~ run-example SparkPi 10  2&gt;&amp;1 | grep &quot;Pi is&quot;Pi is roughly 3.144179144179144</code></pre><h2 id="5-通过安全组控制hadoop服务所开放的端口"><a href="#5-通过安全组控制hadoop服务所开放的端口" class="headerlink" title="5.通过安全组控制hadoop服务所开放的端口"></a>5.通过安全组控制hadoop服务所开放的端口</h2><p>通过以下命令排查得到java所对应端口：</p><pre><code class="lang-bash">(base) ➜  ~ netstat -tunlp | grep javatcp        0      0 0.0.0.0:8030            0.0.0.0:*               LISTEN      81914/java          tcp        0      0 0.0.0.0:8031            0.0.0.0:*               LISTEN      81914/java          tcp        0      0 0.0.0.0:8032            0.0.0.0:*               LISTEN      81914/java          tcp        0      0 0.0.0.0:8033            0.0.0.0:*               LISTEN      81914/java          tcp        0      0 0.0.0.0:8040            0.0.0.0:*               LISTEN      82046/java          tcp        0      0 127.0.0.1:9000          0.0.0.0:*               LISTEN      81255/java          tcp        0      0 0.0.0.0:8042            0.0.0.0:*               LISTEN      82046/java          tcp        0      0 0.0.0.0:9868            0.0.0.0:*               LISTEN      81632/java          tcp        0      0 0.0.0.0:9870            0.0.0.0:*               LISTEN      81255/java          tcp        0      0 0.0.0.0:36563           0.0.0.0:*               LISTEN      82046/java          tcp        0      0 0.0.0.0:8088            0.0.0.0:*               LISTEN      81914/java</code></pre><p>通过jps命令查看java进程信息：</p><pre><code class="lang-bash">(base) ➜  ~ jps81632 SecondaryNameNode81255 NameNode81914 ResourceManager82046 NodeManager190765 Jps</code></pre><p>然后根据对应的端口号配置安全组，如下图：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/hadoop安全组.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;迄今为止，已经有五次因为安装hadoop被黑客入侵导致重装服务器的系统了。经过不断的排查摸索，终于初步确定了就是因为hadoop开放端口的原因。&lt;/p&gt;
&lt;p&gt;在安装spark之前，我们首先需要安装好以下几个组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;java&lt;/li&gt;
&lt;li&gt;hadoop&lt;/li&gt;
&lt;li&gt;scala&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="https://www.iamlightsmile.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="centos" scheme="https://www.iamlightsmile.com/tags/centos/"/>
    
      <category term="spark" scheme="https://www.iamlightsmile.com/tags/spark/"/>
    
      <category term="hadoop" scheme="https://www.iamlightsmile.com/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>服务器被挖矿的入侵了</title>
    <link href="https://www.iamlightsmile.com/articles/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A2%AB%E6%8C%96%E7%9F%BF%E7%9A%84%E5%85%A5%E4%BE%B5%E4%BA%86/"/>
    <id>https://www.iamlightsmile.com/articles/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A2%AB%E6%8C%96%E7%9F%BF%E7%9A%84%E5%85%A5%E4%BE%B5%E4%BA%86/</id>
    <published>2020-12-31T08:06:16.000Z</published>
    <updated>2020-12-31T08:17:47.639Z</updated>
    
    <content type="html"><![CDATA[<p>今天连一台腾讯云服务器的时候，发现网络可以建立连接，但是特别的卡，不知道咋回事，最开始还以为是网络慢。后来<code>htop</code>命令查看了一下进程，好家伙，CPU都被占满了，这是什么鬼？！并且怎么还跑着奇奇怪怪的不知道啥名字的程序？！</p><p>此时心里一惊，坏了，不会被黑客入侵了吧。。。然后大概网上搜了一下，果然情况和参考中两篇链接几乎一致，淦！</p><a id="more"></a><p>我是昨天刚在服务器上配置的hadoop用户密码，结果今天就被入侵了，然而腾讯云也没有任何报警提示，我服了。偷袭我一个Linux新手？我大意了啊，没防住~</p><p>担心自己处理不好还是留下后门，于是乎只能把服务器上的数据拷贝到本地，然后再重装系统了。</p><p>哎，2020果然不顺，最后一天都是如此悲催，希望2021能有好运气和好收获吧。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.v2ex.com/t/683249" target="_blank" rel="noopener">跟着网上博客的教程安装 hadoop，然后我的服务器就被入侵了 - V2EX</a></li><li><a href="https://blog.csdn.net/subfate/article/details/106546646" target="_blank" rel="noopener">记一次ubuntu虚拟机被挖矿木马攻击的过程_李迟的专栏-CSDN博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天连一台腾讯云服务器的时候，发现网络可以建立连接，但是特别的卡，不知道咋回事，最开始还以为是网络慢。后来&lt;code&gt;htop&lt;/code&gt;命令查看了一下进程，好家伙，CPU都被占满了，这是什么鬼？！并且怎么还跑着奇奇怪怪的不知道啥名字的程序？！&lt;/p&gt;
&lt;p&gt;此时心里一惊，坏了，不会被黑客入侵了吧。。。然后大概网上搜了一下，果然情况和参考中两篇链接几乎一致，淦！&lt;/p&gt;
    
    </summary>
    
    
      <category term="其他" scheme="https://www.iamlightsmile.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="hadoop" scheme="https://www.iamlightsmile.com/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch设置自定义词典与停用词</title>
    <link href="https://www.iamlightsmile.com/articles/elasticsearch%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%8D%E5%85%B8%E4%B8%8E%E5%81%9C%E7%94%A8%E8%AF%8D/"/>
    <id>https://www.iamlightsmile.com/articles/elasticsearch%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%8D%E5%85%B8%E4%B8%8E%E5%81%9C%E7%94%A8%E8%AF%8D/</id>
    <published>2020-12-29T06:40:57.000Z</published>
    <updated>2020-12-29T07:10:06.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>处于项目需要，我们需要在elasticsearch中设置自定义的词典与停用词，这里简单说明下其配置方法。</p><p>自己这里是通过docker以及docker-compose的方式来使用的，直接使用elasticsearch的方法流程与之类似，可以看下面的参考。</p><a id="more"></a><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h3><p>项目目录结构大致如下：</p><pre><code class="lang-bash">(base) ➜  elasticsearch tree ..├── config│   ├── IKAnalyzer.cfg.xml│   ├── stopwords.dic│   └── userwords.dic├── docker-compose.yml└── Dockerfile1 directory, 5 files</code></pre><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a><code>Dockerfile</code></h3><p>其中<code>Dockerfile</code>中内容如下：</p><pre><code class="lang-Dockerfile">FROM elasticsearch:7.7.1RUN yes | ./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.7.1/elasticsearch-analysis-ik-7.7.1.zip</code></pre><h3 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a><code>docker-compose.yml</code></h3><p>其中<code>docker-compose.yml</code>中内容如下：</p><pre><code class="lang-yaml">version: &#39;3&#39;services:    es:        image: elasticsearch-ik:7.7.1        container_name: elasticsearch        network_mode: &quot;host&quot;        environment:             - discovery.type=single-node        ports:            - 9200:9200            - 9300:9300        volumes:             - ./config/IKAnalyzer.cfg.xml:/usr/share/elasticsearch/config/analysis-ik/IKAnalyzer.cfg.xml            - ./config/userwords.dic:/usr/share/elasticsearch/config/analysis-ik/userwords.dic            - ./config/stopwords.dic:/usr/share/elasticsearch/config/analysis-ik/stopwords.dic</code></pre><h3 id="IKAnalyzer-cfg-xml"><a href="#IKAnalyzer-cfg-xml" class="headerlink" title="IKAnalyzer.cfg.xml"></a><code>IKAnalyzer.cfg.xml</code></h3><p>其中<code>IKAnalyzer.cfg.xml</code>中内容如下：</p><pre><code class="lang-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;&lt;properties&gt;    &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;    &lt;!--用户可以在这里配置自己的扩展字典 --&gt;    &lt;entry key=&quot;ext_dict&quot;&gt;userwords.dic&lt;/entry&gt;     &lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;    &lt;entry key=&quot;ext_stopwords&quot;&gt;stopwords.dic&lt;/entry&gt;    &lt;!--用户可以在这里配置远程扩展字典 --&gt;    &lt;!-- &lt;entry key=&quot;remote_ext_dict&quot;&gt;words_location&lt;/entry&gt; --&gt;    &lt;!--用户可以在这里配置远程扩展停止词字典--&gt;    &lt;!-- &lt;entry key=&quot;remote_ext_stopwords&quot;&gt;words_location&lt;/entry&gt; --&gt;&lt;/properties&gt;</code></pre><h3 id="stopwords-dic"><a href="#stopwords-dic" class="headerlink" title="stopwords.dic"></a><code>stopwords.dic</code></h3><p>其中<code>stopwords.dic</code>内容如下：</p><pre><code class="lang-dic">吃</code></pre><h3 id="userwords-dic"><a href="#userwords-dic" class="headerlink" title="userwords.dic"></a><code>userwords.dic</code></h3><p>其中<code>userwords.dic</code>内容如下：</p><pre><code class="lang-dic">曹操和李德方</code></pre><h2 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h2><pre><code class="lang-bash">docker-compose up -d</code></pre><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>效果如图：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/elasticsearch_userdict.png" alt="elasticsearch_userdict"></p><p>可以看到，里面<code>李德方</code>、<code>曹操和</code>分别作为词语被拆分出来，同时<code>吃</code>这个词直接就被过滤掉了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="noopener">medcl/elasticsearch-analysis-ik: The IK Analysis plugin integrates Lucene IK analyzer into elasticsearch, support customized dictionary.</a></li><li><a href="https://www.jianshu.com/p/f178e59ffaf2" target="_blank" rel="noopener">ElasticSearch-IK分词使用踩坑总结 - 简书</a></li><li><a href="https://zq99299.github.io/note-book/elasticsearch-senior/ik/31-config.html#%E4%B8%BB%E8%A6%81%E9%85%8D%E7%BD%AE%E8%A7%A3%E8%AF%B4" target="_blank" rel="noopener">IK 分词器配置文件和自定义词库 | Mrcode 笔记本</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;处于项目需要，我们需要在elasticsearch中设置自定义的词典与停用词，这里简单说明下其配置方法。&lt;/p&gt;
&lt;p&gt;自己这里是通过docker以及docker-compose的方式来使用的，直接使用elasticsearch的方法流程与之类似，可以看下面的参考。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="https://www.iamlightsmile.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="elasticsearch" scheme="https://www.iamlightsmile.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>折腾tmux</title>
    <link href="https://www.iamlightsmile.com/articles/%E6%8A%98%E8%85%BEtmux/"/>
    <id>https://www.iamlightsmile.com/articles/%E6%8A%98%E8%85%BEtmux/</id>
    <published>2020-12-17T01:47:15.000Z</published>
    <updated>2020-12-28T07:00:20.883Z</updated>
    
    <content type="html"><![CDATA[<p>有2台腾讯云服务器，一台之前装过brat，成功了。后来打算在新的更好配置的服务器上装brat，没想到总是失败，要么浏览器显示的样式有问题，要么就是打开链接直接重定向要下载文件。</p><a id="more"></a><p>于是乎决定只能在原来的服务器上做标注，考虑到持续使用，所以打算用tmux。没想到直接tmux报错，tmux报<code>can&#39;t create socket</code>的错误，yum提示<code>could not resolve host: mirrors.tencentyun.com; unknown error</code>的错误，更可怕的是ping 外网都ping不通。</p><p>后来参考<a href="https://www.jianshu.com/p/a80189d68104" target="_blank" rel="noopener">腾讯云服务器 “Could not resolve host: mirrors.tencentyun.com; Unknown error” - 简书</a>、<a href="https://blog.csdn.net/shengshengshiwo/article/details/84191515" target="_blank" rel="noopener">mirrors.tencentyun.com 又挂了！_BLUEHEART-CSDN博客</a>以及<a href="https://cloud.tencent.com/developer/article/1464422" target="_blank" rel="noopener">CentOS修改各大yum源(centos5,centos6,centos7) - 云+社区 - 腾讯云</a>对yum源进行了配置，如：</p><pre><code class="lang-bash">cd /etc/yum.repos.dmv CentOS-Base.repo CentOS-Base.repo.backupwget -O CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repoyum clean allyum makecacheyum update</code></pre><p>以及修改了<code>/etc/yum.repos.d/CentOS-Epel.repo</code>文件，如下：</p><pre><code class="lang-conf">[epel]name=EPEL for redhat/centos $releasever - $basearchfailovermethod=prioritygpgcheck=1gpgkey=http://mirrors.163.com/epel/RPM-GPG-KEY-EPEL-7enabled=0baseurl=http://mirrors.163.com/epel/$releasever/$basearch/</code></pre><p>然后解决了yum问题。</p><p>没想到tmux还是不行，后来找到了<a href="https://github.com/MachinaCore/CygwinPortable/issues/28" target="_blank" rel="noopener">tmux can’t create socket: Permission denied · Issue #28 · MachinaCore/CygwinPortable</a>通过在zshrc中配置<code>alias tmux=&#39;tmux -S ~/.tmsock new -ADsCyg&#39;</code>暂时解决了这个问题。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.jianshu.com/p/a80189d68104" target="_blank" rel="noopener">腾讯云服务器 “Could not resolve host: mirrors.tencentyun.com; Unknown error” - 简书</a></li><li><a href="https://blog.csdn.net/shengshengshiwo/article/details/84191515" target="_blank" rel="noopener">mirrors.tencentyun.com 又挂了！_BLUEHEART-CSDN博客</a></li><li><a href="https://cloud.tencent.com/developer/article/1464422" target="_blank" rel="noopener">CentOS修改各大yum源(centos5,centos6,centos7) - 云+社区 - 腾讯云</a></li><li><a href="https://github.com/MachinaCore/CygwinPortable/issues/28" target="_blank" rel="noopener">tmux can’t create socket: Permission denied · Issue #28 · MachinaCore/CygwinPortable</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有2台腾讯云服务器，一台之前装过brat，成功了。后来打算在新的更好配置的服务器上装brat，没想到总是失败，要么浏览器显示的样式有问题，要么就是打开链接直接重定向要下载文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="https://www.iamlightsmile.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="centos" scheme="https://www.iamlightsmile.com/tags/centos/"/>
    
      <category term="tmux" scheme="https://www.iamlightsmile.com/tags/tmux/"/>
    
      <category term="brat" scheme="https://www.iamlightsmile.com/tags/brat/"/>
    
  </entry>
  
  <entry>
    <title>python离线安装包及其依赖包（转载）</title>
    <link href="https://www.iamlightsmile.com/articles/python%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8C%85%E5%8F%8A%E5%85%B6%E4%BE%9D%E8%B5%96%E5%8C%85%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
    <id>https://www.iamlightsmile.com/articles/python%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8C%85%E5%8F%8A%E5%85%B6%E4%BE%9D%E8%B5%96%E5%8C%85%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/</id>
    <published>2020-12-14T00:57:38.000Z</published>
    <updated>2020-12-14T01:24:34.222Z</updated>
    
    <content type="html"><![CDATA[<p>在内网环境只能本地方式安装需要的包，需要在公网机器上下载需要的包及相应依赖包，传输至内网进行安装。以win10系统python 3.7.3为例：</p><a id="more"></a><p>安装pipdeptree：</p><pre><code class="lang-bash">PS D:\test&gt; pip install pipdeptree</code></pre><p>假如想在内网安装flask，先在外网下载安装：</p><pre><code class="lang-bash">PS D:\test&gt; pip install flask</code></pre><p>使用pipdeptree 查看并生成requirements.txt</p><pre><code class="lang-bash">PS D:\test&gt; pipdeptree -f  -p flaskFlask==1.1.2  click==7.1.2  itsdangerous==1.1.0  Jinja2==2.11.2    MarkupSafe==1.1.1  Werkzeug==1.0.1PS D:\test&gt; pipdeptree -f  -p flask &gt; .\requirements.txt</code></pre><p>下载所有包至本地</p><pre><code class="lang-bash">PS D:\test&gt; pip download -r .\requirements.txt</code></pre><p>将test文件夹拷贝至内网机器（如F:/test），进入test目录执行如下命令离线安装</p><pre><code class="lang-bash">PS F:\test&gt; pip install --no-index --find-links=./ -r requirements.txt</code></pre><p>转自：<a href="https://www.jianshu.com/p/9a726dc64e2b" target="_blank" rel="noopener">python 离线安装包及其依赖包 - 简书</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在内网环境只能本地方式安装需要的包，需要在公网机器上下载需要的包及相应依赖包，传输至内网进行安装。以win10系统python 3.7.3为例：&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>支持正版</title>
    <link href="https://www.iamlightsmile.com/articles/%E6%94%AF%E6%8C%81%E6%AD%A3%E7%89%88/"/>
    <id>https://www.iamlightsmile.com/articles/%E6%94%AF%E6%8C%81%E6%AD%A3%E7%89%88/</id>
    <published>2020-12-03T02:23:12.000Z</published>
    <updated>2020-12-03T02:38:58.150Z</updated>
    
    <content type="html"><![CDATA[<p>昨天Pycharm又提示激活码失效了。</p><a id="more"></a><p>关于Python开发，对我个人而言目前来说Pycharm专业版占主体，VSCode用于轻量开发场景。</p><p>关于Pycharm的破解使用，最开始是网上找的博客教程里面提到的免费的破解码，后来是通过淘宝购买的公用教育邮箱的法子，不过今天终于下决心决定支持正版了。</p><p>关于Pycharm，目前个人理解是自己这几年里使用这个工具收获良多，心怀感激之情，所以也应该为信仰充值，一如在Steam上购买正版游戏一样。</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/pycharm2.png" alt="Pycharm2"></p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/pycharm.png" alt="Pycharm"></p><p>另外，其实JetBrains的产品也不算太贵，通过数码荔枝渠道：<a href="https://store.lizhi.io/site/products/id/291" target="_blank" rel="noopener">PyCharm: JetBrains 专业级Python IDE - 荔枝软件商店</a>单购买Pycharm目前一年只需要569，并且可以永久使用该版本。</p><p>实在不想花这份钱的也可以选择通过开源项目申请的方式，具体可以参考：<a href="https://zhuanlan.zhihu.com/p/87370573" target="_blank" rel="noopener">免费获取JetBrains全家桶正版License教程!! - 知乎</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天Pycharm又提示激活码失效了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随念" scheme="https://www.iamlightsmile.com/categories/%E9%9A%8F%E5%BF%B5/"/>
    
    
      <category term="JetBrains" scheme="https://www.iamlightsmile.com/tags/JetBrains/"/>
    
      <category term="Pycharm" scheme="https://www.iamlightsmile.com/tags/Pycharm/"/>
    
      <category term="正版" scheme="https://www.iamlightsmile.com/tags/%E6%AD%A3%E7%89%88/"/>
    
  </entry>
  
  <entry>
    <title>使用frp实现通过ssh访问内网机器</title>
    <link href="https://www.iamlightsmile.com/articles/%E4%BD%BF%E7%94%A8frp%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%BF%87ssh%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%E6%9C%BA%E5%99%A8/"/>
    <id>https://www.iamlightsmile.com/articles/%E4%BD%BF%E7%94%A8frp%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%BF%87ssh%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%E6%9C%BA%E5%99%A8/</id>
    <published>2020-11-28T02:30:09.000Z</published>
    <updated>2020-11-28T02:40:29.963Z</updated>
    
    <content type="html"><![CDATA[<p>内网机配置如下：</p><pre><code class="lang-ini">[common]server_addr = x.x.x.xserver_port = 7000[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 8555</code></pre><p>公网代理机器配置：</p><pre><code class="lang-ini">[common]bind_port = 7000</code></pre><p>然后便可以通过<code>ssh -p 8555 username@x.x.x.x</code>方式连接了。</p><p>参考：<a href="https://gofrp.org/docs/examples/ssh/" target="_blank" rel="noopener">通过 SSH 访问内网机器 | frp</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;内网机配置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ini&quot;&gt;[common]
server_addr = x.x.x.x
server_port = 7000

[ssh]
type = tcp
local_ip = 127.0.0.1
local_p
      
    
    </summary>
    
    
      <category term="计算机" scheme="https://www.iamlightsmile.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="frp" scheme="https://www.iamlightsmile.com/tags/frp/"/>
    
      <category term="内网穿透" scheme="https://www.iamlightsmile.com/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>centos安装mkcert</title>
    <link href="https://www.iamlightsmile.com/articles/centos%E5%AE%89%E8%A3%85mkcert/"/>
    <id>https://www.iamlightsmile.com/articles/centos%E5%AE%89%E8%A3%85mkcert/</id>
    <published>2020-11-19T02:26:47.000Z</published>
    <updated>2020-11-19T02:28:29.627Z</updated>
    
    <content type="html"><![CDATA[<p>没想到安装个mkcert还挺麻烦的，在网上找到教程，基本上都是直接<code>brew install mkcert</code>，但是这个brew基本上是mac专属命令，当然安装到linux上之后提示不能以root权限运行brew，-_-||。</p><a id="more"></a><p>按照mkcert Github上的安装说明通过源码安装，又首先需要安装go，安装完之后又提示有其他问题，终于发现了这个mkcert的预构建版本。</p><p>在centos下安装命令大致如下：</p><pre><code class="lang-bash">wget https://github.com/FiloSottile/mkcert/releases/download/v1.4.2/mkcert-v1.4.2-linux-amd64cp mkcert-v1.4.2-linux-amd64 /usr/local/bin/mkcertchmod +x /usr/local/bin/mkcertln -snvf /usr/local/bin/mkcert /usr/bin/mkcert</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;没想到安装个mkcert还挺麻烦的，在网上找到教程，基本上都是直接&lt;code&gt;brew install mkcert&lt;/code&gt;，但是这个brew基本上是mac专属命令，当然安装到linux上之后提示不能以root权限运行brew，-_-||。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.iamlightsmile.com/categories/Linux/"/>
    
    
      <category term="centos" scheme="https://www.iamlightsmile.com/tags/centos/"/>
    
      <category term="mkcert" scheme="https://www.iamlightsmile.com/tags/mkcert/"/>
    
  </entry>
  
  <entry>
    <title>部署自签名https</title>
    <link href="https://www.iamlightsmile.com/articles/%E9%83%A8%E7%BD%B2%E8%87%AA%E7%AD%BE%E5%90%8Dhttps/"/>
    <id>https://www.iamlightsmile.com/articles/%E9%83%A8%E7%BD%B2%E8%87%AA%E7%AD%BE%E5%90%8Dhttps/</id>
    <published>2020-11-19T02:24:02.000Z</published>
    <updated>2020-11-19T03:11:36.999Z</updated>
    
    <content type="html"><![CDATA[<p>需要用到<code>mkcert</code>，安装方式请参考：<a href="http://www.iamlightsmile.com/articles/centos%E5%AE%89%E8%A3%85mkcert/">centos安装mkcert - lightsmile’s Blog</a></p><a id="more"></a><h2 id="1-部署流程"><a href="#1-部署流程" class="headerlink" title="1.部署流程"></a>1.部署流程</h2><h3 id="1-1-将CA证书加入本地可信CA（可选）"><a href="#1-1-将CA证书加入本地可信CA（可选）" class="headerlink" title="1.1 将CA证书加入本地可信CA（可选）"></a>1.1 将CA证书加入本地可信CA（可选）</h3><pre><code class="lang-bash">(base) ➜  ~ mkcert -installCreated a new local CA 💥The local CA is now installed in the system trust store! ⚡️The local CA is now installed in the Firefox and/or Chrome/Chromium trust store (requires browser restart)! 🦊The local CA is already installed in Java&#39;s trust store! 👍</code></pre><p>这一条其实可选，当执行了这一步流程之后，mkcert使用的根证书就加入了本地可信CA中，以后由该CA签发的证书在本地都是可信的。</p><h3 id="1-2-生成自签名证书"><a href="#1-2-生成自签名证书" class="headerlink" title="1.2 生成自签名证书"></a>1.2 生成自签名证书</h3><pre><code class="lang-bash">(base) ➜  ~ mkcert localhost 127.0.0.1 ::1 49.232.27.108Created a new certificate valid for the following names 📜 - &quot;localhost&quot; - &quot;127.0.0.1&quot; - &quot;::1&quot; - &quot;49.232.27.108&quot;The certificate is at &quot;./localhost+3.pem&quot; and the key at &quot;./localhost+3-key.pem&quot; ✅It will expire on 19 February 2023 🗓</code></pre><p>以上命令会在当前路径生成证书文件和私钥文件，为便于后面使用，可以将该文件放到别的路径，以个人为例，我放到了<code>/root/Data/Web/ssl/</code>下。</p><h3 id="1-3-nginx配置证书文件和私钥文件"><a href="#1-3-nginx配置证书文件和私钥文件" class="headerlink" title="1.3 nginx配置证书文件和私钥文件"></a>1.3 nginx配置证书文件和私钥文件</h3><p>nginx中配置文件内容（默认路径为<code>/etc/nginx/nginx.conf</code>）大致如下：</p><pre><code class="lang-conf">user  root;worker_processes  2;error_log  /var/log/nginx/error.log warn;pid        /var/run/nginx.pid;events {    worker_connections  1024;}http {    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    access_log  /var/log/nginx/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    #gzip  on;    include /etc/nginx/conf.d/*.conf;    server {        listen 8089 ssl;        # listen 8089;        server_name localhost;        root /root/Data/Web/;        charset utf-8;        index index.html;        ssl_certificate /root/Data/Web/ssl/localhost+3.pem;        ssl_certificate_key /root/Data/Web/ssl/localhost+3-key.pem;        ssl_session_timeout 5m;        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;        ssl_ciphers  HIGH:!aNULL:!MD5;  # 密码加密方式        ssl_prefer_server_ciphers on;        ssl_session_cache shared:SSL:1m;        location / {            root /root/Data/Web/html;            index index.html;        }    }}</code></pre><p>其中<code>/root/Data/Web/ssl/html/index.html</code>内容如下：</p><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;p&gt;Hello world!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="1-4-将CA证书发放给其他用户"><a href="#1-4-将CA证书发放给其他用户" class="headerlink" title="1.4 将CA证书发放给其他用户"></a>1.4 将CA证书发放给其他用户</h3><p>使用以下命令查看CA证书路径并生成crt格式：</p><pre><code class="lang-bash">(base) ➜  ~ mkcert -CAROOT/root/.local/share/mkcert(base) ➜  ~ cd .local/share/mkcert(base) ➜  mkcert lsrootCA-key.pem  rootCA.pem(base) ➜  mkcert cp rootCA.pem rootCA.crt(base) ➜  mkcert lsrootCA.crt  rootCA-key.pem  rootCA.pem</code></pre><p>然后将<code>rootCA.crt</code>文件通过文件传输方式分发给局域网其他电脑。</p><h3 id="1-5-导入CA证书"><a href="#1-5-导入CA证书" class="headerlink" title="1.5 导入CA证书"></a>1.5 导入CA证书</h3><p>Windows和MacOS的导入方式为双击这个文件，在<code>证书导入向导</code>中选择将证书导入<code>受信任的根证书颁发机构</code>，导入成功后我们可以在开始运行中输入<code>certmgr.msc</code>查看证书，如图：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/mkcert3.png" alt="mkcert3"></p><h3 id="1-6-使用https访问服务"><a href="#1-6-使用https访问服务" class="headerlink" title="1.6 使用https访问服务"></a>1.6 使用https访问服务</h3><p>导入该CA证书的局域网其他用户便也可以通过https方法来访问该服务器了，然而需要注意的是浏览器需要先退出然后重新打开，以便于浏览器重新加载信任证书，否则的话还是会提示不安全。</p><p>重新打开后，访问服务可以看到结果如下：</p><p><img src="https://lightsmile-img.oss-cn-beijing.aliyuncs.com/mkcert2.png" alt="mkcert-https"></p><h2 id="2-参考"><a href="#2-参考" class="headerlink" title="2.参考"></a>2.参考</h2><ul><li><a href="https://www.jianshu.com/p/7cb5c2cffaaa" target="_blank" rel="noopener">本地https快速解决方案——mkcert - 简书</a></li><li><a href="https://blog.csdn.net/maokexu123/article/details/42773599" target="_blank" rel="noopener">windows 怎样查看计算机本地安装的证书_如山石的系统虚拟化之路-CSDN博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;需要用到&lt;code&gt;mkcert&lt;/code&gt;，安装方式请参考：&lt;a href=&quot;http://www.iamlightsmile.com/articles/centos%E5%AE%89%E8%A3%85mkcert/&quot;&gt;centos安装mkcert - lightsmile’s Blog&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.iamlightsmile.com/categories/Linux/"/>
    
    
      <category term="mkcert" scheme="https://www.iamlightsmile.com/tags/mkcert/"/>
    
      <category term="https" scheme="https://www.iamlightsmile.com/tags/https/"/>
    
      <category term="ssl" scheme="https://www.iamlightsmile.com/tags/ssl/"/>
    
  </entry>
  
  <entry>
    <title>Linux内网通过windows主机代理访问外网</title>
    <link href="https://www.iamlightsmile.com/articles/Linux%E5%86%85%E7%BD%91%E9%80%9A%E8%BF%87windows%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86%E8%AE%BF%E9%97%AE%E5%A4%96%E7%BD%91/"/>
    <id>https://www.iamlightsmile.com/articles/Linux%E5%86%85%E7%BD%91%E9%80%9A%E8%BF%87windows%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86%E8%AE%BF%E9%97%AE%E5%A4%96%E7%BD%91/</id>
    <published>2020-11-18T12:37:45.000Z</published>
    <updated>2020-11-19T00:49:19.384Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h2><p>有时我们会有这样一个场景，即自己的终端设备（如笔记本或台式机）可以通过手机热点或WiFi等形式联网，然而局域网内公司的服务器不能联网，并且有时需要在这台服务器上更新软件等。对于这种需求，我们可以通过搭建代理的方式访问外网。</p><a id="more"></a><h2 id="1-下载并配置代理工具"><a href="#1-下载并配置代理工具" class="headerlink" title="1.下载并配置代理工具"></a>1.下载并配置代理工具</h2><p>具体内容请参考：<a href="https://blog.csdn.net/lxl1531/article/details/109224706" target="_blank" rel="noopener">Linux内网通过windows主机代理访问外网（centos7.6）_lxl1531的博客-CSDN博客</a></p><h2 id="2-配置服务器"><a href="#2-配置服务器" class="headerlink" title="2.配置服务器"></a>2.配置服务器</h2><p>具体内容请参考：<a href="https://www.cnblogs.com/Shepherdzhao/p/7552276.html" target="_blank" rel="noopener">解决CentOS内网机通过Windows下架设代理来访问网络 - XuepengZ - 博客园</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/Shepherdzhao/p/7552276.html" target="_blank" rel="noopener">解决CentOS内网机通过Windows下架设代理来访问网络 - XuepengZ - 博客园</a></li><li><a href="https://blog.csdn.net/lxl1531/article/details/109224706" target="_blank" rel="noopener">Linux内网通过windows主机代理访问外网（centos7.6）_lxl1531的博客-CSDN博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0.前言&quot;&gt;&lt;/a&gt;0.前言&lt;/h2&gt;&lt;p&gt;有时我们会有这样一个场景，即自己的终端设备（如笔记本或台式机）可以通过手机热点或WiFi等形式联网，然而局域网内公司的服务器不能联网，并且有时需要在这台服务器上更新软件等。对于这种需求，我们可以通过搭建代理的方式访问外网。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.iamlightsmile.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.iamlightsmile.com/tags/Linux/"/>
    
  </entry>
  
</feed>
